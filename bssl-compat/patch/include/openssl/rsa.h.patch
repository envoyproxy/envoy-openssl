--- a/include/openssl/rsa.h
+++ b/include/openssl/rsa.h
@@ -54,18 +54,18 @@
  * copied and put under another distribution licence
  * [including the GNU Public Licence.] */
 
-// #ifndef OPENSSL_HEADER_RSA_H
-// #define OPENSSL_HEADER_RSA_H
+#ifndef OPENSSL_HEADER_RSA_H
+#define OPENSSL_HEADER_RSA_H
 
-// #include <openssl/base.h>
+#include <openssl/base.h>
 
-// #include <openssl/engine.h>
-// #include <openssl/ex_data.h>
-// #include <openssl/thread.h>
-
-// #if defined(__cplusplus)
-// extern "C" {
-// #endif
+#include <openssl/engine.h>
+#include <openssl/ex_data.h>
+#include <openssl/thread.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 
 // rsa.h contains functions for handling encryption and signature using RSA.
@@ -87,7 +87,7 @@
 
 // RSA_free decrements the reference count of |rsa| and frees it if the
 // reference count drops to zero.
-// OPENSSL_EXPORT void RSA_free(RSA *rsa);
+OPENSSL_EXPORT void RSA_free(RSA *rsa);
 
 // RSA_up_ref increments the reference count of |rsa| and returns one. It does
 // not mutate |rsa| for thread-safety purposes and may be used concurrently.
@@ -297,9 +297,9 @@
 // WARNING: |digest| must be the result of hashing the data to be signed with
 // |hash_nid|. Passing unhashed inputs will not result in a secure signature
 // scheme.
-// OPENSSL_EXPORT int RSA_sign(int hash_nid, const uint8_t *digest,
-//                             unsigned digest_len, uint8_t *out,
-//                             unsigned *out_len, RSA *rsa);
+OPENSSL_EXPORT int RSA_sign(int hash_nid, const uint8_t *digest,
+                            unsigned digest_len, uint8_t *out,
+                            unsigned *out_len, RSA *rsa);
 
 // RSA_sign_pss_mgf1 signs |digest_len| bytes from |digest| with the public key
 // from |rsa| using RSASSA-PSS with MGF1 as the mask generation function. It
@@ -441,7 +441,7 @@
 
 // RSA_size returns the number of bytes in the modulus, which is also the size
 // of a signature or encrypted value using |rsa|.
-// OPENSSL_EXPORT unsigned RSA_size(const RSA *rsa);
+OPENSSL_EXPORT unsigned RSA_size(const RSA *rsa);
 
 // RSA_is_opaque returns one if |rsa| is opaque and doesn't expose its key
 // material. Otherwise it returns zero.
@@ -789,21 +789,21 @@
 // };
 
 
-// #if defined(__cplusplus)
-// }  // extern C
+#if defined(__cplusplus)
+}  // extern C
 
-// extern "C++" {
+extern "C++" {
 
-// BSSL_NAMESPACE_BEGIN
+BSSL_NAMESPACE_BEGIN
 
-// BORINGSSL_MAKE_DELETER(RSA, RSA_free)
+BORINGSSL_MAKE_DELETER(RSA, RSA_free)
 // BORINGSSL_MAKE_UP_REF(RSA, RSA_up_ref)
 
-// BSSL_NAMESPACE_END
+BSSL_NAMESPACE_END
 
-// }  // extern C++
+}  // extern C++
 
-// #endif
+#endif
 
 #ifdef ossl_RSA_R_BAD_ENCODING
 #define RSA_R_BAD_ENCODING ossl_RSA_R_BAD_ENCODING
@@ -953,4 +953,4 @@
 #define RSA_R_BLOCK_TYPE_IS_NOT_02 ossl_RSA_R_BLOCK_TYPE_IS_NOT_02
 #endif
 
-// #endif  // OPENSSL_HEADER_RSA_H
+#endif  // OPENSSL_HEADER_RSA_H
