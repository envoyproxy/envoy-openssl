--- a/source/crypto/pkcs8/pkcs12_test.cc
+++ b/source/crypto/pkcs8/pkcs12_test.cc
@@ -12,173 +12,173 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
-// #include <gtest/gtest.h>
+#include <gtest/gtest.h>
 
-// #include <openssl/bio.h>
-// #include <openssl/bytestring.h>
-// #include <openssl/crypto.h>
-// #include <openssl/err.h>
-// #include <openssl/evp.h>
-// #include <openssl/pkcs8.h>
-// #include <openssl/mem.h>
-// #include <openssl/span.h>
-// #include <openssl/stack.h>
-// #include <openssl/x509.h>
+#include <openssl/bio.h>
+#include <openssl/bytestring.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/pkcs8.h>
+#include <openssl/mem.h>
+#include <openssl/span.h>
+#include <openssl/stack.h>
+#include <openssl/x509.h>
 
-// #include "../test/test_util.h"
+#include "../test/test_util.h"
 
 
-// std::string GetTestData(const char *path);
+std::string GetTestData(const char *path);
 
 // kPassword is the password shared by most of the sample PKCS#12 files.
-// static const char kPassword[] = "foo";
+static const char kPassword[] = "foo";
 
 // kUnicodePassword is the password for unicode_password.p12
-// static const char kUnicodePassword[] = "Hello, 世界";
+static const char kUnicodePassword[] = "Hello, 世界";
 
-// static bssl::Span<const uint8_t> StringToBytes(const std::string &str) {
-//   return bssl::MakeConstSpan(reinterpret_cast<const uint8_t *>(str.data()),
-//                              str.size());
-// }
-
-// static void TestImpl(const char *name, bssl::Span<const uint8_t> der,
-//                      const char *password,
-//                      const char *friendly_name) {
-//   SCOPED_TRACE(name);
-//   bssl::UniquePtr<STACK_OF(X509)> certs(sk_X509_new_null());
-//   ASSERT_TRUE(certs);
-
-//   EVP_PKEY *key = nullptr;
-//   CBS pkcs12 = der;
-//   ASSERT_TRUE(PKCS12_get_key_and_certs(&key, certs.get(), &pkcs12, password));
-//   bssl::UniquePtr<EVP_PKEY> delete_key(key);
-
-//   ASSERT_EQ(1u, sk_X509_num(certs.get()));
-//   ASSERT_TRUE(key);
-
-//   int actual_name_len;
-//   const uint8_t *actual_name =
-//       X509_alias_get0(sk_X509_value(certs.get(), 0), &actual_name_len);
-//   if (friendly_name == nullptr) {
-//     EXPECT_EQ(nullptr, actual_name);
-//   } else {
-//     EXPECT_EQ(friendly_name,
-//               std::string(reinterpret_cast<const char *>(actual_name),
-//                           static_cast<size_t>(actual_name_len)));
-//   }
-// }
-
-// static void TestCompat(bssl::Span<const uint8_t> der) {
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(der.data(), der.size()));
-//   ASSERT_TRUE(bio);
-
-//   bssl::UniquePtr<PKCS12> p12(d2i_PKCS12_bio(bio.get(), nullptr));
-//   ASSERT_TRUE(p12);
-
-//   ASSERT_FALSE(PKCS12_verify_mac(p12.get(), "badpass", 7));
-//   ASSERT_TRUE(PKCS12_verify_mac(p12.get(), kPassword, sizeof(kPassword) - 1));
-
-//   EVP_PKEY *key = nullptr;
-//   X509 *cert = nullptr;
-//   STACK_OF(X509) *ca_certs = nullptr;
-//   ASSERT_TRUE(PKCS12_parse(p12.get(), kPassword, &key, &cert, &ca_certs));
-
-//   bssl::UniquePtr<EVP_PKEY> delete_key(key);
-//   bssl::UniquePtr<X509> delete_cert(cert);
-//   bssl::UniquePtr<STACK_OF(X509)> delete_ca_certs(ca_certs);
-
-//   ASSERT_TRUE(key);
-//   ASSERT_TRUE(cert);
-//   ASSERT_EQ(0u, sk_X509_num(ca_certs));
-// }
-
-// TEST(PKCS12Test, TestOpenSSL) {
-//   // openssl.p12 was generated by OpenSSL with:
-//   //   openssl pkcs12 -export -inkey key.pem -in cacert.pem
-//   std::string data = GetTestData("crypto/pkcs8/test/openssl.p12");
-//   TestImpl("OpenSSL", StringToBytes(data), kPassword, nullptr);
-// }
-
-// TEST(PKCS12Test, TestNSS) {
-//   // nss.p12 is the result of importing the OpenSSL example PKCS#12 into Chrome
-//   // on Linux and then exporting it again.
-//   std::string data = GetTestData("crypto/pkcs8/test/nss.p12");
-//   TestImpl("NSS", StringToBytes(data), kPassword, "Internet Widgits Pty Ltd");
-// }
-
-// TEST(PKCS12Test, TestWindows) {
-//   // windows.p12 is a dummy key and certificate exported from the certificate
-//   // manager on Windows 7. It has a friendlyName, but only on the key, where we
-//   // ignore it, and not the certificate.
-//   std::string data = GetTestData("crypto/pkcs8/test/windows.p12");
-//   TestImpl("Windows", StringToBytes(data), kPassword, nullptr);
-// }
-
-// TEST(PKCS12Test, TestPBES2) {
-//   // pbes2_sha1.p12 is a PKCS#12 file using PBES2 and HMAC-SHA-1 created with:
-//   // openssl pkcs12 -export -inkey key.pem -in cert.pem -keypbe AES-128-CBC
-//   // -certpbe AES-128-CBC
-//   //
-//   // This was generated with an older OpenSSL, which used hmacWithSHA1 as the
-//   // PRF. (There is currently no way to specify the PRF in the pkcs12 command.)
-//   std::string data = GetTestData("crypto/pkcs8/test/pbes2_sha1.p12");
-//   TestImpl("kPBES2WithSHA1", StringToBytes(data), kPassword, nullptr);
-
-//   // pbes2_sha256.p12 is a PKCS#12 file using PBES2 and HMAC-SHA-256. It was
-//   // generated in the same way as pbes2_sha1.p12, but using OpenSSL 1.1.1b,
-//   // which uses hmacWithSHA256 as the PRF.
-//   data = GetTestData("crypto/pkcs8/test/pbes2_sha256.p12");
-//   TestImpl("kPBES2WithSHA256", StringToBytes(data), kPassword, nullptr);
-// }
-
-// TEST(PKCS12Test, TestNoEncryption) {
-//   // no_encryption.p12 is a PKCS#12 file with neither the key or certificate is
-//   // encrypted. It was generated with:
-//   //
-//   //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -keypbe NONE -certpbe NONE -password pass:foo
-//   std::string data = GetTestData("crypto/pkcs8/test/no_encryption.p12");
-//   TestImpl("kNoEncryption", StringToBytes(data), kPassword, nullptr);
-// }
-
-// TEST(PKCS12Test, TestEmptyPassword) {
-// #if defined(BORINGSSL_UNSAFE_FUZZER_MODE)
-//   return;  // The MAC check always passes in fuzzer mode.
-// #endif
-
-//   // Generated with
-//   //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -password pass:  
-//   std::string data = GetTestData("crypto/pkcs8/test/empty_password.p12");
-//   TestImpl("EmptyPassword (empty password)", StringToBytes(data), "", nullptr);
-//   TestImpl("EmptyPassword (null password)", StringToBytes(data), nullptr,
-//            nullptr);
-// }
-
-// TEST(PKCS12Test, TestNullPassword) {
-// #if defined(BORINGSSL_UNSAFE_FUZZER_MODE)
-//   return;  // The MAC check always passes in fuzzer mode.
-// #endif
-
-//   // Generated with
-//   //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -password pass:
-//   // But with OpenSSL patched to pass NULL into PKCS12_create and
-//   // PKCS12_set_mac.
-//   std::string data = GetTestData("crypto/pkcs8/test/null_password.p12");
-//   TestImpl("NullPassword (empty password)", StringToBytes(data), "", nullptr);
-//   TestImpl("NullPassword (null password)", StringToBytes(data), nullptr,
-//            nullptr);
-// }
-
-// TEST(PKCS12Test, TestUnicode) {
-//   // Generated with
-//   //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -password pass:"Hello, 世界"
-//   std::string data = GetTestData("crypto/pkcs8/test/unicode_password.p12");
-//   TestImpl("Unicode", StringToBytes(data), kUnicodePassword, nullptr);
-// }
-
-// TEST(PKCS12Test, TestWindowsCompat) {
-//   std::string data = GetTestData("crypto/pkcs8/test/windows.p12");
-//   TestCompat(StringToBytes(data));
-// }
+static bssl::Span<const uint8_t> StringToBytes(const std::string &str) {
+  return bssl::MakeConstSpan(reinterpret_cast<const uint8_t *>(str.data()),
+                             str.size());
+}
+
+static void TestImpl(const char *name, bssl::Span<const uint8_t> der,
+                     const char *password,
+                     const char *friendly_name) {
+  SCOPED_TRACE(name);
+  bssl::UniquePtr<STACK_OF(X509)> certs(sk_X509_new_null());
+  ASSERT_TRUE(certs);
+
+  EVP_PKEY *key = nullptr;
+  CBS pkcs12 = der;
+  ASSERT_TRUE(PKCS12_get_key_and_certs(&key, certs.get(), &pkcs12, password));
+  bssl::UniquePtr<EVP_PKEY> delete_key(key);
+
+  ASSERT_EQ(1u, sk_X509_num(certs.get()));
+  ASSERT_TRUE(key);
+
+  int actual_name_len;
+  const uint8_t *actual_name =
+      X509_alias_get0(sk_X509_value(certs.get(), 0), &actual_name_len);
+  if (friendly_name == nullptr) {
+    EXPECT_EQ(nullptr, actual_name);
+  } else {
+    EXPECT_EQ(friendly_name,
+              std::string(reinterpret_cast<const char *>(actual_name),
+                          static_cast<size_t>(actual_name_len)));
+  }
+}
+
+static void TestCompat(bssl::Span<const uint8_t> der) {
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(der.data(), der.size()));
+  ASSERT_TRUE(bio);
+
+  bssl::UniquePtr<PKCS12> p12(d2i_PKCS12_bio(bio.get(), nullptr));
+  ASSERT_TRUE(p12);
+
+  ASSERT_FALSE(PKCS12_verify_mac(p12.get(), "badpass", 7));
+  ASSERT_TRUE(PKCS12_verify_mac(p12.get(), kPassword, sizeof(kPassword) - 1));
+
+  EVP_PKEY *key = nullptr;
+  X509 *cert = nullptr;
+  STACK_OF(X509) *ca_certs = nullptr;
+  ASSERT_TRUE(PKCS12_parse(p12.get(), kPassword, &key, &cert, &ca_certs));
+
+  bssl::UniquePtr<EVP_PKEY> delete_key(key);
+  bssl::UniquePtr<X509> delete_cert(cert);
+  bssl::UniquePtr<STACK_OF(X509)> delete_ca_certs(ca_certs);
+
+  ASSERT_TRUE(key);
+  ASSERT_TRUE(cert);
+  ASSERT_EQ(0u, sk_X509_num(ca_certs));
+}
+
+TEST(PKCS12Test, TestOpenSSL) {
+  // openssl.p12 was generated by OpenSSL with:
+  //   openssl pkcs12 -export -inkey key.pem -in cacert.pem
+  std::string data = GetTestData("crypto/pkcs8/test/openssl.p12");
+  TestImpl("OpenSSL", StringToBytes(data), kPassword, nullptr);
+}
+
+TEST(PKCS12Test, TestNSS) {
+  // nss.p12 is the result of importing the OpenSSL example PKCS#12 into Chrome
+  // on Linux and then exporting it again.
+  std::string data = GetTestData("crypto/pkcs8/test/nss.p12");
+  TestImpl("NSS", StringToBytes(data), kPassword, "Internet Widgits Pty Ltd");
+}
+
+TEST(PKCS12Test, TestWindows) {
+  // windows.p12 is a dummy key and certificate exported from the certificate
+  // manager on Windows 7. It has a friendlyName, but only on the key, where we
+  // ignore it, and not the certificate.
+  std::string data = GetTestData("crypto/pkcs8/test/windows.p12");
+  TestImpl("Windows", StringToBytes(data), kPassword, nullptr);
+}
+
+TEST(PKCS12Test, TestPBES2) {
+  // pbes2_sha1.p12 is a PKCS#12 file using PBES2 and HMAC-SHA-1 created with:
+  // openssl pkcs12 -export -inkey key.pem -in cert.pem -keypbe AES-128-CBC
+  // -certpbe AES-128-CBC
+  //
+  // This was generated with an older OpenSSL, which used hmacWithSHA1 as the
+  // PRF. (There is currently no way to specify the PRF in the pkcs12 command.)
+  std::string data = GetTestData("crypto/pkcs8/test/pbes2_sha1.p12");
+  TestImpl("kPBES2WithSHA1", StringToBytes(data), kPassword, nullptr);
+
+  // pbes2_sha256.p12 is a PKCS#12 file using PBES2 and HMAC-SHA-256. It was
+  // generated in the same way as pbes2_sha1.p12, but using OpenSSL 1.1.1b,
+  // which uses hmacWithSHA256 as the PRF.
+  data = GetTestData("crypto/pkcs8/test/pbes2_sha256.p12");
+  TestImpl("kPBES2WithSHA256", StringToBytes(data), kPassword, nullptr);
+}
+
+TEST(PKCS12Test, TestNoEncryption) {
+  // no_encryption.p12 is a PKCS#12 file with neither the key or certificate is
+  // encrypted. It was generated with:
+  //
+  //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -keypbe NONE -certpbe NONE -password pass:foo
+  std::string data = GetTestData("crypto/pkcs8/test/no_encryption.p12");
+  TestImpl("kNoEncryption", StringToBytes(data), kPassword, nullptr);
+}
+
+TEST(PKCS12Test, TestEmptyPassword) {
+#if defined(BORINGSSL_UNSAFE_FUZZER_MODE)
+  return;  // The MAC check always passes in fuzzer mode.
+#endif
+
+  // Generated with
+  //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -password pass:  
+  std::string data = GetTestData("crypto/pkcs8/test/empty_password.p12");
+  TestImpl("EmptyPassword (empty password)", StringToBytes(data), "", nullptr);
+  TestImpl("EmptyPassword (null password)", StringToBytes(data), nullptr,
+           nullptr);
+}
+
+TEST(PKCS12Test, TestNullPassword) {
+#if defined(BORINGSSL_UNSAFE_FUZZER_MODE)
+  return;  // The MAC check always passes in fuzzer mode.
+#endif
+
+  // Generated with
+  //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -password pass:
+  // But with OpenSSL patched to pass NULL into PKCS12_create and
+  // PKCS12_set_mac.
+  std::string data = GetTestData("crypto/pkcs8/test/null_password.p12");
+  TestImpl("NullPassword (empty password)", StringToBytes(data), "", nullptr);
+  TestImpl("NullPassword (null password)", StringToBytes(data), nullptr,
+           nullptr);
+}
+
+TEST(PKCS12Test, TestUnicode) {
+  // Generated with
+  //   openssl pkcs12 -export -inkey ecdsa_p256_key.pem -in ecdsa_p256_cert.pem -password pass:"Hello, 世界"
+  std::string data = GetTestData("crypto/pkcs8/test/unicode_password.p12");
+  TestImpl("Unicode", StringToBytes(data), kUnicodePassword, nullptr);
+}
+
+TEST(PKCS12Test, TestWindowsCompat) {
+  std::string data = GetTestData("crypto/pkcs8/test/windows.p12");
+  TestCompat(StringToBytes(data));
+}
 
 // kTestKey is a test P-256 key.
 // static const uint8_t kTestKey[] = {
