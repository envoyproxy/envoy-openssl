--- a/source/crypto/bytestring/cbb.c
+++ b/source/crypto/bytestring/cbb.c
@@ -12,56 +12,56 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
-// #include <openssl/bytestring.h>
+#include <openssl/bytestring.h>
 
-// #include <assert.h>
-// #include <limits.h>
-// #include <string.h>
+#include <assert.h>
+#include <limits.h>
+#include <string.h>
 
-// #include <openssl/mem.h>
+#include <openssl/mem.h>
 
-// #include "../internal.h"
+#include "../internal.h"
 
 
-// void CBB_zero(CBB *cbb) {
-//   OPENSSL_memset(cbb, 0, sizeof(CBB));
-// }
+void CBB_zero(CBB *cbb) {
+  OPENSSL_memset(cbb, 0, sizeof(CBB));
+}
 
-// static int cbb_init(CBB *cbb, uint8_t *buf, size_t cap) {
-//   // This assumes that |cbb| has already been zeroed.
-//   struct cbb_buffer_st *base;
+static int cbb_init(CBB *cbb, uint8_t *buf, size_t cap) {
+  // This assumes that |cbb| has already been zeroed.
+  struct cbb_buffer_st *base;
 
-//   base = OPENSSL_malloc(sizeof(struct cbb_buffer_st));
-//   if (base == NULL) {
-//     return 0;
-//   }
+  base = OPENSSL_malloc(sizeof(struct cbb_buffer_st));
+  if (base == NULL) {
+    return 0;
+  }
 
-//   base->buf = buf;
-//   base->len = 0;
-//   base->cap = cap;
-//   base->can_resize = 1;
-//   base->error = 0;
+  base->buf = buf;
+  base->len = 0;
+  base->cap = cap;
+  base->can_resize = 1;
+  base->error = 0;
 
-//   cbb->base = base;
-//   cbb->is_child = 0;
-//   return 1;
-// }
+  cbb->base = base;
+  cbb->is_child = 0;
+  return 1;
+}
 
-// int CBB_init(CBB *cbb, size_t initial_capacity) {
-//   CBB_zero(cbb);
+int CBB_init(CBB *cbb, size_t initial_capacity) {
+  CBB_zero(cbb);
 
-//   uint8_t *buf = OPENSSL_malloc(initial_capacity);
-//   if (initial_capacity > 0 && buf == NULL) {
-//     return 0;
-//   }
+  uint8_t *buf = OPENSSL_malloc(initial_capacity);
+  if (initial_capacity > 0 && buf == NULL) {
+    return 0;
+  }
 
-//   if (!cbb_init(cbb, buf, initial_capacity)) {
-//     OPENSSL_free(buf);
-//     return 0;
-//   }
+  if (!cbb_init(cbb, buf, initial_capacity)) {
+    OPENSSL_free(buf);
+    return 0;
+  }
 
-//   return 1;
-// }
+  return 1;
+}
 
 // int CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len) {
 //   CBB_zero(cbb);
@@ -74,227 +74,227 @@
 //   return 1;
 // }
 
-// void CBB_cleanup(CBB *cbb) {
-//   // Child |CBB|s are non-owning. They are implicitly discarded and should not
-//   // be used with |CBB_cleanup| or |ScopedCBB|.
-//   assert(!cbb->is_child);
-//   if (cbb->is_child) {
-//     return;
-//   }
-
-//   if (cbb->base) {
-//     if (cbb->base->can_resize) {
-//       OPENSSL_free(cbb->base->buf);
-//     }
-//     OPENSSL_free(cbb->base);
-//   }
-//   cbb->base = NULL;
-// }
-
-// static int cbb_buffer_reserve(struct cbb_buffer_st *base, uint8_t **out,
-//                               size_t len) {
-//   size_t newlen;
-
-//   if (base == NULL) {
-//     return 0;
-//   }
-
-//   newlen = base->len + len;
-//   if (newlen < base->len) {
-//     // Overflow
-//     goto err;
-//   }
-
-//   if (newlen > base->cap) {
-//     size_t newcap = base->cap * 2;
-//     uint8_t *newbuf;
-
-//     if (!base->can_resize) {
-//       goto err;
-//     }
-
-//     if (newcap < base->cap || newcap < newlen) {
-//       newcap = newlen;
-//     }
-//     newbuf = OPENSSL_realloc(base->buf, newcap);
-//     if (newbuf == NULL) {
-//       goto err;
-//     }
-
-//     base->buf = newbuf;
-//     base->cap = newcap;
-//   }
-
-//   if (out) {
-//     *out = base->buf + base->len;
-//   }
-
-//   return 1;
-
-// err:
-//   base->error = 1;
-//   return 0;
-// }
-
-// static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
-//                           size_t len) {
-//   if (!cbb_buffer_reserve(base, out, len)) {
-//     return 0;
-//   }
-//   // This will not overflow or |cbb_buffer_reserve| would have failed.
-//   base->len += len;
-//   return 1;
-// }
-
-// static int cbb_buffer_add_u(struct cbb_buffer_st *base, uint64_t v,
-//                             size_t len_len) {
-//   if (len_len == 0) {
-//     return 1;
-//   }
-
-//   uint8_t *buf;
-//   if (!cbb_buffer_add(base, &buf, len_len)) {
-//     return 0;
-//   }
-
-//   for (size_t i = len_len - 1; i < len_len; i--) {
-//     buf[i] = v;
-//     v >>= 8;
-//   }
-
-//   if (v != 0) {
-//     base->error = 1;
-//     return 0;
-//   }
-
-//   return 1;
-// }
-
-// int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
-//   if (cbb->is_child) {
-//     return 0;
-//   }
-
-//   if (!CBB_flush(cbb)) {
-//     return 0;
-//   }
-
-//   if (cbb->base->can_resize && (out_data == NULL || out_len == NULL)) {
-//     // |out_data| and |out_len| can only be NULL if the CBB is fixed.
-//     return 0;
-//   }
-
-//   if (out_data != NULL) {
-//     *out_data = cbb->base->buf;
-//   }
-//   if (out_len != NULL) {
-//     *out_len = cbb->base->len;
-//   }
-//   cbb->base->buf = NULL;
-//   CBB_cleanup(cbb);
-//   return 1;
-// }
+void CBB_cleanup(CBB *cbb) {
+  // Child |CBB|s are non-owning. They are implicitly discarded and should not
+  // be used with |CBB_cleanup| or |ScopedCBB|.
+  assert(!cbb->is_child);
+  if (cbb->is_child) {
+    return;
+  }
+
+  if (cbb->base) {
+    if (cbb->base->can_resize) {
+      OPENSSL_free(cbb->base->buf);
+    }
+    OPENSSL_free(cbb->base);
+  }
+  cbb->base = NULL;
+}
+
+static int cbb_buffer_reserve(struct cbb_buffer_st *base, uint8_t **out,
+                              size_t len) {
+  size_t newlen;
+
+  if (base == NULL) {
+    return 0;
+  }
+
+  newlen = base->len + len;
+  if (newlen < base->len) {
+    // Overflow
+    goto err;
+  }
+
+  if (newlen > base->cap) {
+    size_t newcap = base->cap * 2;
+    uint8_t *newbuf;
+
+    if (!base->can_resize) {
+      goto err;
+    }
+
+    if (newcap < base->cap || newcap < newlen) {
+      newcap = newlen;
+    }
+    newbuf = OPENSSL_realloc(base->buf, newcap);
+    if (newbuf == NULL) {
+      goto err;
+    }
+
+    base->buf = newbuf;
+    base->cap = newcap;
+  }
+
+  if (out) {
+    *out = base->buf + base->len;
+  }
+
+  return 1;
+
+err:
+  base->error = 1;
+  return 0;
+}
+
+static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
+                          size_t len) {
+  if (!cbb_buffer_reserve(base, out, len)) {
+    return 0;
+  }
+  // This will not overflow or |cbb_buffer_reserve| would have failed.
+  base->len += len;
+  return 1;
+}
+
+static int cbb_buffer_add_u(struct cbb_buffer_st *base, uint64_t v,
+                            size_t len_len) {
+  if (len_len == 0) {
+    return 1;
+  }
+
+  uint8_t *buf;
+  if (!cbb_buffer_add(base, &buf, len_len)) {
+    return 0;
+  }
+
+  for (size_t i = len_len - 1; i < len_len; i--) {
+    buf[i] = v;
+    v >>= 8;
+  }
+
+  if (v != 0) {
+    base->error = 1;
+    return 0;
+  }
+
+  return 1;
+}
+
+int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
+  if (cbb->is_child) {
+    return 0;
+  }
+
+  if (!CBB_flush(cbb)) {
+    return 0;
+  }
+
+  if (cbb->base->can_resize && (out_data == NULL || out_len == NULL)) {
+    // |out_data| and |out_len| can only be NULL if the CBB is fixed.
+    return 0;
+  }
+
+  if (out_data != NULL) {
+    *out_data = cbb->base->buf;
+  }
+  if (out_len != NULL) {
+    *out_len = cbb->base->len;
+  }
+  cbb->base->buf = NULL;
+  CBB_cleanup(cbb);
+  return 1;
+}
 
 // CBB_flush recurses and then writes out any pending length prefix. The
 // current length of the underlying base is taken to be the length of the
 // length-prefixed data.
-// int CBB_flush(CBB *cbb) {
-//   size_t child_start, i, len;
+int CBB_flush(CBB *cbb) {
+  size_t child_start, i, len;
 
-//   // If |cbb->base| has hit an error, the buffer is in an undefined state, so
-//   // fail all following calls. In particular, |cbb->child| may point to invalid
-//   // memory.
-//   if (cbb->base == NULL || cbb->base->error) {
-//     return 0;
-//   }
-
-//   if (cbb->child == NULL || cbb->child->pending_len_len == 0) {
-//     return 1;
-//   }
-
-//   child_start = cbb->child->offset + cbb->child->pending_len_len;
-
-//   if (!CBB_flush(cbb->child) ||
-//       child_start < cbb->child->offset ||
-//       cbb->base->len < child_start) {
-//     goto err;
-//   }
-
-//   len = cbb->base->len - child_start;
-
-//   if (cbb->child->pending_is_asn1) {
-//     // For ASN.1 we assume that we'll only need a single byte for the length.
-//     // If that turned out to be incorrect, we have to move the contents along
-//     // in order to make space.
-//     uint8_t len_len;
-//     uint8_t initial_length_byte;
-
-//     assert (cbb->child->pending_len_len == 1);
-
-//     if (len > 0xfffffffe) {
-//       // Too large.
-//       goto err;
-//     } else if (len > 0xffffff) {
-//       len_len = 5;
-//       initial_length_byte = 0x80 | 4;
-//     } else if (len > 0xffff) {
-//       len_len = 4;
-//       initial_length_byte = 0x80 | 3;
-//     } else if (len > 0xff) {
-//       len_len = 3;
-//       initial_length_byte = 0x80 | 2;
-//     } else if (len > 0x7f) {
-//       len_len = 2;
-//       initial_length_byte = 0x80 | 1;
-//     } else {
-//       len_len = 1;
-//       initial_length_byte = (uint8_t)len;
-//       len = 0;
-//     }
-
-//     if (len_len != 1) {
-//       // We need to move the contents along in order to make space.
-//       size_t extra_bytes = len_len - 1;
-//       if (!cbb_buffer_add(cbb->base, NULL, extra_bytes)) {
-//         goto err;
-//       }
-//       OPENSSL_memmove(cbb->base->buf + child_start + extra_bytes,
-//                       cbb->base->buf + child_start, len);
-//     }
-//     cbb->base->buf[cbb->child->offset++] = initial_length_byte;
-//     cbb->child->pending_len_len = len_len - 1;
-//   }
-
-//   for (i = cbb->child->pending_len_len - 1; i < cbb->child->pending_len_len;
-//        i--) {
-//     cbb->base->buf[cbb->child->offset + i] = (uint8_t)len;
-//     len >>= 8;
-//   }
-//   if (len != 0) {
-//     goto err;
-//   }
-
-//   cbb->child->base = NULL;
-//   cbb->child = NULL;
-
-//   return 1;
+  // If |cbb->base| has hit an error, the buffer is in an undefined state, so
+  // fail all following calls. In particular, |cbb->child| may point to invalid
+  // memory.
+  if (cbb->base == NULL || cbb->base->error) {
+    return 0;
+  }
+
+  if (cbb->child == NULL || cbb->child->pending_len_len == 0) {
+    return 1;
+  }
+
+  child_start = cbb->child->offset + cbb->child->pending_len_len;
+
+  if (!CBB_flush(cbb->child) ||
+      child_start < cbb->child->offset ||
+      cbb->base->len < child_start) {
+    goto err;
+  }
+
+  len = cbb->base->len - child_start;
+
+  if (cbb->child->pending_is_asn1) {
+    // For ASN.1 we assume that we'll only need a single byte for the length.
+    // If that turned out to be incorrect, we have to move the contents along
+    // in order to make space.
+    uint8_t len_len;
+    uint8_t initial_length_byte;
+
+    assert (cbb->child->pending_len_len == 1);
+
+    if (len > 0xfffffffe) {
+      // Too large.
+      goto err;
+    } else if (len > 0xffffff) {
+      len_len = 5;
+      initial_length_byte = 0x80 | 4;
+    } else if (len > 0xffff) {
+      len_len = 4;
+      initial_length_byte = 0x80 | 3;
+    } else if (len > 0xff) {
+      len_len = 3;
+      initial_length_byte = 0x80 | 2;
+    } else if (len > 0x7f) {
+      len_len = 2;
+      initial_length_byte = 0x80 | 1;
+    } else {
+      len_len = 1;
+      initial_length_byte = (uint8_t)len;
+      len = 0;
+    }
+
+    if (len_len != 1) {
+      // We need to move the contents along in order to make space.
+      size_t extra_bytes = len_len - 1;
+      if (!cbb_buffer_add(cbb->base, NULL, extra_bytes)) {
+        goto err;
+      }
+      OPENSSL_memmove(cbb->base->buf + child_start + extra_bytes,
+                      cbb->base->buf + child_start, len);
+    }
+    cbb->base->buf[cbb->child->offset++] = initial_length_byte;
+    cbb->child->pending_len_len = len_len - 1;
+  }
+
+  for (i = cbb->child->pending_len_len - 1; i < cbb->child->pending_len_len;
+       i--) {
+    cbb->base->buf[cbb->child->offset + i] = (uint8_t)len;
+    len >>= 8;
+  }
+  if (len != 0) {
+    goto err;
+  }
+
+  cbb->child->base = NULL;
+  cbb->child = NULL;
+
+  return 1;
+
+err:
+  cbb->base->error = 1;
+  return 0;
+}
+
+const uint8_t *CBB_data(const CBB *cbb) {
+  assert(cbb->child == NULL);
+  return cbb->base->buf + cbb->offset + cbb->pending_len_len;
+}
+
+size_t CBB_len(const CBB *cbb) {
+  assert(cbb->child == NULL);
+  assert(cbb->offset + cbb->pending_len_len <= cbb->base->len);
 
-// err:
-//   cbb->base->error = 1;
-//   return 0;
-// }
-
-// const uint8_t *CBB_data(const CBB *cbb) {
-//   assert(cbb->child == NULL);
-//   return cbb->base->buf + cbb->offset + cbb->pending_len_len;
-// }
-
-// size_t CBB_len(const CBB *cbb) {
-//   assert(cbb->child == NULL);
-//   assert(cbb->offset + cbb->pending_len_len <= cbb->base->len);
-
-//   return cbb->base->len - cbb->offset - cbb->pending_len_len;
-// }
+  return cbb->base->len - cbb->offset - cbb->pending_len_len;
+}
 
 // static int cbb_add_length_prefixed(CBB *cbb, CBB *out_contents,
 //                                    uint8_t len_len) {
@@ -336,73 +336,73 @@
 // add_base128_integer encodes |v| as a big-endian base-128 integer where the
 // high bit of each byte indicates where there is more data. This is the
 // encoding used in DER for both high tag number form and OID components.
-// static int add_base128_integer(CBB *cbb, uint64_t v) {
-//   unsigned len_len = 0;
-//   uint64_t copy = v;
-//   while (copy > 0) {
-//     len_len++;
-//     copy >>= 7;
-//   }
-//   if (len_len == 0) {
-//     len_len = 1;  // Zero is encoded with one byte.
-//   }
-//   for (unsigned i = len_len - 1; i < len_len; i--) {
-//     uint8_t byte = (v >> (7 * i)) & 0x7f;
-//     if (i != 0) {
-//       // The high bit denotes whether there is more data.
-//       byte |= 0x80;
-//     }
-//     if (!CBB_add_u8(cbb, byte)) {
-//       return 0;
-//     }
-//   }
-//   return 1;
-// }
-
-// int CBB_add_asn1(CBB *cbb, CBB *out_contents, unsigned tag) {
-//   if (!CBB_flush(cbb)) {
-//     return 0;
-//   }
-
-//   // Split the tag into leading bits and tag number.
-//   uint8_t tag_bits = (tag >> CBS_ASN1_TAG_SHIFT) & 0xe0;
-//   unsigned tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
-//   if (tag_number >= 0x1f) {
-//     // Set all the bits in the tag number to signal high tag number form.
-//     if (!CBB_add_u8(cbb, tag_bits | 0x1f) ||
-//         !add_base128_integer(cbb, tag_number)) {
-//       return 0;
-//     }
-//   } else if (!CBB_add_u8(cbb, tag_bits | tag_number)) {
-//     return 0;
-//   }
-
-//   size_t offset = cbb->base->len;
-//   if (!CBB_add_u8(cbb, 0)) {
-//     return 0;
-//   }
-
-//   OPENSSL_memset(out_contents, 0, sizeof(CBB));
-//   out_contents->base = cbb->base;
-//   out_contents->is_child = 1;
-//   cbb->child = out_contents;
-//   cbb->child->offset = offset;
-//   cbb->child->pending_len_len = 1;
-//   cbb->child->pending_is_asn1 = 1;
-
-//   return 1;
-// }
-
-// int CBB_add_bytes(CBB *cbb, const uint8_t *data, size_t len) {
-//   uint8_t *dest;
-
-//   if (!CBB_flush(cbb) ||
-//       !cbb_buffer_add(cbb->base, &dest, len)) {
-//     return 0;
-//   }
-//   OPENSSL_memcpy(dest, data, len);
-//   return 1;
-// }
+static int add_base128_integer(CBB *cbb, uint64_t v) {
+  unsigned len_len = 0;
+  uint64_t copy = v;
+  while (copy > 0) {
+    len_len++;
+    copy >>= 7;
+  }
+  if (len_len == 0) {
+    len_len = 1;  // Zero is encoded with one byte.
+  }
+  for (unsigned i = len_len - 1; i < len_len; i--) {
+    uint8_t byte = (v >> (7 * i)) & 0x7f;
+    if (i != 0) {
+      // The high bit denotes whether there is more data.
+      byte |= 0x80;
+    }
+    if (!CBB_add_u8(cbb, byte)) {
+      return 0;
+    }
+  }
+  return 1;
+}
+
+int CBB_add_asn1(CBB *cbb, CBB *out_contents, unsigned tag) {
+  if (!CBB_flush(cbb)) {
+    return 0;
+  }
+
+  // Split the tag into leading bits and tag number.
+  uint8_t tag_bits = (tag >> CBS_ASN1_TAG_SHIFT) & 0xe0;
+  unsigned tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
+  if (tag_number >= 0x1f) {
+    // Set all the bits in the tag number to signal high tag number form.
+    if (!CBB_add_u8(cbb, tag_bits | 0x1f) ||
+        !add_base128_integer(cbb, tag_number)) {
+      return 0;
+    }
+  } else if (!CBB_add_u8(cbb, tag_bits | tag_number)) {
+    return 0;
+  }
+
+  size_t offset = cbb->base->len;
+  if (!CBB_add_u8(cbb, 0)) {
+    return 0;
+  }
+
+  OPENSSL_memset(out_contents, 0, sizeof(CBB));
+  out_contents->base = cbb->base;
+  out_contents->is_child = 1;
+  cbb->child = out_contents;
+  cbb->child->offset = offset;
+  cbb->child->pending_len_len = 1;
+  cbb->child->pending_is_asn1 = 1;
+
+  return 1;
+}
+
+int CBB_add_bytes(CBB *cbb, const uint8_t *data, size_t len) {
+  uint8_t *dest;
+
+  if (!CBB_flush(cbb) ||
+      !cbb_buffer_add(cbb->base, &dest, len)) {
+    return 0;
+  }
+  OPENSSL_memcpy(dest, data, len);
+  return 1;
+}
 
 // int CBB_add_zeros(CBB *cbb, size_t len) {
 //   uint8_t *out;
@@ -440,21 +440,21 @@
 //   return 1;
 // }
 
-// int CBB_add_u8(CBB *cbb, uint8_t value) {
-//   if (!CBB_flush(cbb)) {
-//     return 0;
-//   }
-
-//   return cbb_buffer_add_u(cbb->base, value, 1);
-// }
-
-// int CBB_add_u16(CBB *cbb, uint16_t value) {
-//   if (!CBB_flush(cbb)) {
-//     return 0;
-//   }
+int CBB_add_u8(CBB *cbb, uint8_t value) {
+  if (!CBB_flush(cbb)) {
+    return 0;
+  }
+
+  return cbb_buffer_add_u(cbb->base, value, 1);
+}
+
+int CBB_add_u16(CBB *cbb, uint16_t value) {
+  if (!CBB_flush(cbb)) {
+    return 0;
+  }
 
-//   return cbb_buffer_add_u(cbb->base, value, 2);
-// }
+  return cbb_buffer_add_u(cbb->base, value, 2);
+}
 
 // int CBB_add_u16le(CBB *cbb, uint16_t value) {
 //   return CBB_add_u16(cbb, CRYPTO_bswap2(value));
