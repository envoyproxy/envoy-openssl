--- a/source/crypto/bytestring/cbs.c
+++ b/source/crypto/bytestring/cbs.c
@@ -12,48 +12,48 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
-// #include <openssl/asn1.h>
-// #include <openssl/bytestring.h>
-// #include <openssl/mem.h>
-
-// #include <assert.h>
-// #include <ctype.h>
-// #include <inttypes.h>
-// #include <string.h>
+#include <openssl/asn1.h>
+#include <openssl/bytestring.h>
+#include <openssl/mem.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <string.h>
 
 // #include "../asn1/internal.h"
 // #include "../internal.h"
 // #include "internal.h"
 
 
-// void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
-//   cbs->data = data;
-//   cbs->len = len;
-// }
-
-// static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
-//   if (cbs->len < n) {
-//     return 0;
-//   }
-
-//   *p = cbs->data;
-//   cbs->data += n;
-//   cbs->len -= n;
-//   return 1;
-// }
-
-// int CBS_skip(CBS *cbs, size_t len) {
-//   const uint8_t *dummy;
-//   return cbs_get(cbs, &dummy, len);
-// }
+void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
+  cbs->data = data;
+  cbs->len = len;
+}
+
+static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
+  if (cbs->len < n) {
+    return 0;
+  }
+
+  *p = cbs->data;
+  cbs->data += n;
+  cbs->len -= n;
+  return 1;
+}
+
+int CBS_skip(CBS *cbs, size_t len) {
+  const uint8_t *dummy;
+  return cbs_get(cbs, &dummy, len);
+}
 
 // const uint8_t *CBS_data(const CBS *cbs) {
 //   return cbs->data;
 // }
 
-// size_t CBS_len(const CBS *cbs) {
-//   return cbs->len;
-// }
+size_t CBS_len(const CBS *cbs) {
+  return cbs->len;
+}
 
 // int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
 //   OPENSSL_free(*out_ptr);
@@ -90,20 +90,20 @@
 //   return CRYPTO_memcmp(cbs->data, data, len) == 0;
 // }
 
-// static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
-//   uint64_t result = 0;
-//   const uint8_t *data;
-
-//   if (!cbs_get(cbs, &data, len)) {
-//     return 0;
-//   }
-//   for (size_t i = 0; i < len; i++) {
-//     result <<= 8;
-//     result |= data[i];
-//   }
-//   *out = result;
-//   return 1;
-// }
+static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
+  uint64_t result = 0;
+  const uint8_t *data;
+
+  if (!cbs_get(cbs, &data, len)) {
+    return 0;
+  }
+  for (size_t i = 0; i < len; i++) {
+    result <<= 8;
+    result |= data[i];
+  }
+  *out = result;
+  return 1;
+}
 
 // int CBS_get_u8(CBS *cbs, uint8_t *out) {
 //   const uint8_t *v;
@@ -114,14 +114,14 @@
 //   return 1;
 // }
 
-// int CBS_get_u16(CBS *cbs, uint16_t *out) {
-//   uint64_t v;
-//   if (!cbs_get_u(cbs, &v, 2)) {
-//     return 0;
-//   }
-//   *out = v;
-//   return 1;
-// }
+int CBS_get_u16(CBS *cbs, uint16_t *out) {
+  uint64_t v;
+  if (!cbs_get_u(cbs, &v, 2)) {
+    return 0;
+  }
+  *out = v;
+  return 1;
+}
 
 // int CBS_get_u16le(CBS *cbs, uint16_t *out) {
 //   if (!CBS_get_u16(cbs, out)) {
