--- a/source/crypto/x509/x509_test.cc
+++ b/source/crypto/x509/x509_test.cc
@@ -12,248 +12,248 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
-// #include <algorithm>
-// #include <functional>
-// #include <string>
-// #include <vector>
-
-// #include <gtest/gtest.h>
-
-// #include <openssl/asn1.h>
-// #include <openssl/bio.h>
-// #include <openssl/bytestring.h>
-// #include <openssl/crypto.h>
-// #include <openssl/curve25519.h>
-// #include <openssl/digest.h>
-// #include <openssl/err.h>
-// #include <openssl/nid.h>
-// #include <openssl/pem.h>
-// #include <openssl/pool.h>
-// #include <openssl/x509.h>
-// #include <openssl/x509v3.h>
+#include <algorithm>
+#include <functional>
+#include <string>
+#include <vector>
+
+#include <gtest/gtest.h>
+
+#include <openssl/asn1.h>
+#include <openssl/bio.h>
+#include <openssl/bytestring.h>
+#include <openssl/crypto.h>
+#include <openssl/curve25519.h>
+#include <openssl/digest.h>
+#include <openssl/err.h>
+#include <openssl/nid.h>
+#include <openssl/pem.h>
+#include <openssl/pool.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
 
 // #include "internal.h"
-// #include "../internal.h"
-// #include "../test/test_util.h"
-// #include "../x509v3/internal.h"
-
-
-// std::string GetTestData(const char *path);
-
-// static const char kCrossSigningRootPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICcTCCAdqgAwIBAgIIagJHiPvE0MowDQYJKoZIhvcNAQELBQAwPDEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxHjAcBgNVBAMTFUNyb3NzLXNpZ25pbmcgUm9v
-// dCBDQTAgFw0xNTAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowPDEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxHjAcBgNVBAMTFUNyb3NzLXNpZ25pbmcgUm9v
-// dCBDQTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAwo3qFvSB9Zmlbpzn9wJp
-// ikI75Rxkatez8VkLqyxbOhPYl2Haz8F5p1gDG96dCI6jcLGgu3AKT9uhEQyyUko5
-// EKYasazSeA9CQrdyhPg0mkTYVETnPM1W/ebid1YtqQbq1CMWlq2aTDoSGAReGFKP
-// RTdXAbuAXzpCfi/d8LqV13UCAwEAAaN6MHgwDgYDVR0PAQH/BAQDAgIEMB0GA1Ud
-// JQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAPBgNVHRMBAf8EBTADAQH/MBkGA1Ud
-// DgQSBBBHKHC7V3Z/3oLvEZx0RZRwMBsGA1UdIwQUMBKAEEcocLtXdn/egu8RnHRF
-// lHAwDQYJKoZIhvcNAQELBQADgYEAnglibsy6mGtpIXivtlcz4zIEnHw/lNW+r/eC
-// CY7evZTmOoOuC/x9SS3MF9vawt1HFUummWM6ZgErqVBOXIB4//ykrcCgf5ZbF5Hr
-// +3EFprKhBqYiXdD8hpBkrBoXwn85LPYWNd2TceCrx0YtLIprE2R5MB2RIq8y4Jk3
-// YFXvkME=
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kRootCAPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICVTCCAb6gAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwLjEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxEDAOBgNVBAMTB1Jvb3QgQ0EwIBcNMTUwMTAx
-// MDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMC4xGjAYBgNVBAoTEUJvcmluZ1NTTCBU
-// RVNUSU5HMRAwDgYDVQQDEwdSb290IENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB
-// iQKBgQDpDn8RDOZa5oaDcPZRBy4CeBH1siSSOO4mYgLHlPE+oXdqwI/VImi2XeJM
-// 2uCFETXCknJJjYG0iJdrt/yyRFvZTQZw+QzGj+mz36NqhGxDWb6dstB2m8PX+plZ
-// w7jl81MDvUnWs8yiQ/6twgu5AbhWKZQDJKcNKCEpqa6UW0r5nwIDAQABo3oweDAO
-// BgNVHQ8BAf8EBAMCAgQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMA8G
-// A1UdEwEB/wQFMAMBAf8wGQYDVR0OBBIEEEA31wH7QC+4HH5UBCeMWQEwGwYDVR0j
-// BBQwEoAQQDfXAftAL7gcflQEJ4xZATANBgkqhkiG9w0BAQsFAAOBgQDXylEK77Za
-// kKeY6ZerrScWyZhrjIGtHFu09qVpdJEzrk87k2G7iHHR9CAvSofCgEExKtWNS9dN
-// +9WiZp/U48iHLk7qaYXdEuO07No4BYtXn+lkOykE+FUxmA4wvOF1cTd2tdj3MzX2
-// kfGIBAYhzGZWhY3JbhIfTEfY1PNM1pWChQ==
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kRootCrossSignedPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICYzCCAcygAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwPDEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxHjAcBgNVBAMTFUNyb3NzLXNpZ25pbmcgUm9v
-// dCBDQTAgFw0xNTAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowLjEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxEDAOBgNVBAMTB1Jvb3QgQ0EwgZ8wDQYJKoZI
-// hvcNAQEBBQADgY0AMIGJAoGBAOkOfxEM5lrmhoNw9lEHLgJ4EfWyJJI47iZiAseU
-// 8T6hd2rAj9UiaLZd4kza4IURNcKSckmNgbSIl2u3/LJEW9lNBnD5DMaP6bPfo2qE
-// bENZvp2y0Habw9f6mVnDuOXzUwO9SdazzKJD/q3CC7kBuFYplAMkpw0oISmprpRb
-// SvmfAgMBAAGjejB4MA4GA1UdDwEB/wQEAwICBDAdBgNVHSUEFjAUBggrBgEFBQcD
-// AQYIKwYBBQUHAwIwDwYDVR0TAQH/BAUwAwEB/zAZBgNVHQ4EEgQQQDfXAftAL7gc
-// flQEJ4xZATAbBgNVHSMEFDASgBBHKHC7V3Z/3oLvEZx0RZRwMA0GCSqGSIb3DQEB
-// CwUAA4GBAErTxYJ0en9HVRHAAr5OO5wuk5Iq3VMc79TMyQLCXVL8YH8Uk7KEwv+q
-// 9MEKZv2eR/Vfm4HlXlUuIqfgUXbwrAYC/YVVX86Wnbpy/jc73NYVCq8FEZeO+0XU
-// 90SWAPDdp+iL7aZdimnMtG1qlM1edmz8AKbrhN/R3IbA2CL0nCWV
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kIntermediatePEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICXjCCAcegAwIBAgIJAKJMH+7rscPcMA0GCSqGSIb3DQEBCwUAMC4xGjAYBgNV
-// BAoTEUJvcmluZ1NTTCBURVNUSU5HMRAwDgYDVQQDEwdSb290IENBMCAXDTE1MDEw
-// MTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjA2MRowGAYDVQQKExFCb3JpbmdTU0wg
-// VEVTVElORzEYMBYGA1UEAxMPSW50ZXJtZWRpYXRlIENBMIGfMA0GCSqGSIb3DQEB
-// AQUAA4GNADCBiQKBgQC7YtI0l8ocTYJ0gKyXTtPL4iMJCNY4OcxXl48jkncVG1Hl
-// blicgNUa1r9m9YFtVkxvBinb8dXiUpEGhVg4awRPDcatlsBSEBuJkiZGYbRcAmSu
-// CmZYnf6u3aYQ18SU8WqVERPpE4cwVVs+6kwlzRw0+XDoZAczu8ZezVhCUc6NbQID
-// AQABo3oweDAOBgNVHQ8BAf8EBAMCAgQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsG
-// AQUFBwMCMA8GA1UdEwEB/wQFMAMBAf8wGQYDVR0OBBIEEIwaaKi1dttdV3sfjRSy
-// BqMwGwYDVR0jBBQwEoAQQDfXAftAL7gcflQEJ4xZATANBgkqhkiG9w0BAQsFAAOB
-// gQCvnolNWEHuQS8PFVVyuLR+FKBeUUdrVbSfHSzTqNAqQGp0C9fk5oCzDq6ZgTfY
-// ESXM4cJhb3IAnW0UM0NFsYSKQJ50JZL2L3z5ZLQhHdbs4RmODGoC40BVdnJ4/qgB
-// aGSh09eQRvAVmbVCviDK2ipkWNegdyI19jFfNP5uIkGlYg==
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kIntermediateSelfSignedPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICZjCCAc+gAwIBAgIJAKJMH+7rscPcMA0GCSqGSIb3DQEBCwUAMDYxGjAYBgNV
-// BAoTEUJvcmluZ1NTTCBURVNUSU5HMRgwFgYDVQQDEw9JbnRlcm1lZGlhdGUgQ0Ew
-// IBcNMTUwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMDYxGjAYBgNVBAoTEUJv
-// cmluZ1NTTCBURVNUSU5HMRgwFgYDVQQDEw9JbnRlcm1lZGlhdGUgQ0EwgZ8wDQYJ
-// KoZIhvcNAQEBBQADgY0AMIGJAoGBALti0jSXyhxNgnSArJdO08viIwkI1jg5zFeX
-// jyOSdxUbUeVuWJyA1RrWv2b1gW1WTG8GKdvx1eJSkQaFWDhrBE8Nxq2WwFIQG4mS
-// JkZhtFwCZK4KZlid/q7dphDXxJTxapURE+kThzBVWz7qTCXNHDT5cOhkBzO7xl7N
-// WEJRzo1tAgMBAAGjejB4MA4GA1UdDwEB/wQEAwICBDAdBgNVHSUEFjAUBggrBgEF
-// BQcDAQYIKwYBBQUHAwIwDwYDVR0TAQH/BAUwAwEB/zAZBgNVHQ4EEgQQjBpoqLV2
-// 211Xex+NFLIGozAbBgNVHSMEFDASgBCMGmiotXbbXVd7H40UsgajMA0GCSqGSIb3
-// DQEBCwUAA4GBALcccSrAQ0/EqQBsx0ZDTUydHXXNP2DrUkpUKmAXIe8McqIVSlkT
-// 6H4xz7z8VRKBo9j+drjjtCw2i0CQc8aOLxRb5WJ8eVLnaW2XRlUqAzhF0CrulfVI
-// E4Vs6ZLU+fra1WAuIj6qFiigRja+3YkZArG8tMA9vtlhTX/g7YBZIkqH
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kLeafPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICXjCCAcegAwIBAgIIWjO48ufpunYwDQYJKoZIhvcNAQELBQAwNjEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxGDAWBgNVBAMTD0ludGVybWVkaWF0ZSBDQTAg
-// Fw0xNTAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowMjEaMBgGA1UEChMRQm9y
-// aW5nU1NMIFRFU1RJTkcxFDASBgNVBAMTC2V4YW1wbGUuY29tMIGfMA0GCSqGSIb3
-// DQEBAQUAA4GNADCBiQKBgQDD0U0ZYgqShJ7oOjsyNKyVXEHqeafmk/bAoPqY/h1c
-// oPw2E8KmeqiUSoTPjG5IXSblOxcqpbAXgnjPzo8DI3GNMhAf8SYNYsoH7gc7Uy7j
-// 5x8bUrisGnuTHqkqH6d4/e7ETJ7i3CpR8bvK16DggEvQTudLipz8FBHtYhFakfdh
-// TwIDAQABo3cwdTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEG
-// CCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwGQYDVR0OBBIEEKN5pvbur7mlXjeMEYA0
-// 4nUwGwYDVR0jBBQwEoAQjBpoqLV2211Xex+NFLIGozANBgkqhkiG9w0BAQsFAAOB
-// gQBj/p+JChp//LnXWC1k121LM/ii7hFzQzMrt70bny406SGz9jAjaPOX4S3gt38y
-// rhjpPukBlSzgQXFg66y6q5qp1nQTD1Cw6NkKBe9WuBlY3iYfmsf7WT8nhlT1CttU
-// xNCwyMX9mtdXdQicOfNjIGUCD5OLV5PgHFPRKiHHioBAhg==
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kLeafNoKeyUsagePEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICNTCCAZ6gAwIBAgIJAIFQGaLQ0G2mMA0GCSqGSIb3DQEBCwUAMDYxGjAYBgNV
-// BAoTEUJvcmluZ1NTTCBURVNUSU5HMRgwFgYDVQQDEw9JbnRlcm1lZGlhdGUgQ0Ew
-// IBcNMTUwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMDcxGjAYBgNVBAoTEUJv
-// cmluZ1NTTCBURVNUSU5HMRkwFwYDVQQDExBldmlsLmV4YW1wbGUuY29tMIGfMA0G
-// CSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOKoZe75NPz77EOaMMl4/0s3PyQw++zJvp
-// ejHAxZiTPCJgMbEHLrSzNoHdopg+CLUH5bE4wTXM8w9Inv5P8OAFJt7gJuPUunmk
-// j+NoU3QfzOR6BroePcz1vXX9jyVHRs087M/sLqWRHu9IR+/A+UTcBaWaFiDVUxtJ
-// YOwFMwjNPQIDAQABo0gwRjAMBgNVHRMBAf8EAjAAMBkGA1UdDgQSBBBJfLEUWHq1
-// 27rZ1AVx2J5GMBsGA1UdIwQUMBKAEIwaaKi1dttdV3sfjRSyBqMwDQYJKoZIhvcN
-// AQELBQADgYEALVKN2Y3LZJOtu6SxFIYKxbLaXhTGTdIjxipZhmbBRDFjbZjZZOTe
-// 6Oo+VDNPYco4rBexK7umYXJyfTqoY0E8dbiImhTcGTEj7OAB3DbBomgU1AYe+t2D
-// uwBqh4Y3Eto+Zn4pMVsxGEfUpjzjZDel7bN1/oU/9KWPpDfywfUmjgk=
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kForgeryPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICZzCCAdCgAwIBAgIIdTlMzQoKkeMwDQYJKoZIhvcNAQELBQAwNzEaMBgGA1UE
-// ChMRQm9yaW5nU1NMIFRFU1RJTkcxGTAXBgNVBAMTEGV2aWwuZXhhbXBsZS5jb20w
-// IBcNMTUwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMDoxGjAYBgNVBAoTEUJv
-// cmluZ1NTTCBURVNUSU5HMRwwGgYDVQQDExNmb3JnZXJ5LmV4YW1wbGUuY29tMIGf
-// MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDADTwruBQZGb7Ay6s9HiYv5d1lwtEy
-// xQdA2Sy8Rn8uA20Q4KgqwVY7wzIZ+z5Butrsmwb70gdG1XU+yRaDeE7XVoW6jSpm
-// 0sw35/5vJbTcL4THEFbnX0OPZnvpuZDFUkvVtq5kxpDWsVyM24G8EEq7kPih3Sa3
-// OMhXVXF8kso6UQIDAQABo3cwdTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI
-// KwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwGQYDVR0OBBIEEEYJ/WHM
-// 8p64erPWIg4/liwwGwYDVR0jBBQwEoAQSXyxFFh6tdu62dQFcdieRjANBgkqhkiG
-// 9w0BAQsFAAOBgQA+zH7bHPElWRWJvjxDqRexmYLn+D3Aivs8XgXQJsM94W0EzSUf
-// DSLfRgaQwcb2gg2xpDFoG+W0vc6O651uF23WGt5JaFFJJxqjII05IexfCNhuPmp4
-// 4UZAXPttuJXpn74IY1tuouaM06B3vXKZR+/ityKmfJvSwxacmFcK+2ziAg==
-// -----END CERTIFICATE-----
-// )";
+#include "../internal.h"
+#include "../test/test_util.h"
+#include "../x509v3/internal.h"
+
+
+std::string GetTestData(const char *path);
+
+static const char kCrossSigningRootPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICcTCCAdqgAwIBAgIIagJHiPvE0MowDQYJKoZIhvcNAQELBQAwPDEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxHjAcBgNVBAMTFUNyb3NzLXNpZ25pbmcgUm9v
+dCBDQTAgFw0xNTAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowPDEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxHjAcBgNVBAMTFUNyb3NzLXNpZ25pbmcgUm9v
+dCBDQTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAwo3qFvSB9Zmlbpzn9wJp
+ikI75Rxkatez8VkLqyxbOhPYl2Haz8F5p1gDG96dCI6jcLGgu3AKT9uhEQyyUko5
+EKYasazSeA9CQrdyhPg0mkTYVETnPM1W/ebid1YtqQbq1CMWlq2aTDoSGAReGFKP
+RTdXAbuAXzpCfi/d8LqV13UCAwEAAaN6MHgwDgYDVR0PAQH/BAQDAgIEMB0GA1Ud
+JQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAPBgNVHRMBAf8EBTADAQH/MBkGA1Ud
+DgQSBBBHKHC7V3Z/3oLvEZx0RZRwMBsGA1UdIwQUMBKAEEcocLtXdn/egu8RnHRF
+lHAwDQYJKoZIhvcNAQELBQADgYEAnglibsy6mGtpIXivtlcz4zIEnHw/lNW+r/eC
+CY7evZTmOoOuC/x9SS3MF9vawt1HFUummWM6ZgErqVBOXIB4//ykrcCgf5ZbF5Hr
++3EFprKhBqYiXdD8hpBkrBoXwn85LPYWNd2TceCrx0YtLIprE2R5MB2RIq8y4Jk3
+YFXvkME=
+-----END CERTIFICATE-----
+)";
+
+static const char kRootCAPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICVTCCAb6gAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwLjEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxEDAOBgNVBAMTB1Jvb3QgQ0EwIBcNMTUwMTAx
+MDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMC4xGjAYBgNVBAoTEUJvcmluZ1NTTCBU
+RVNUSU5HMRAwDgYDVQQDEwdSb290IENBMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB
+iQKBgQDpDn8RDOZa5oaDcPZRBy4CeBH1siSSOO4mYgLHlPE+oXdqwI/VImi2XeJM
+2uCFETXCknJJjYG0iJdrt/yyRFvZTQZw+QzGj+mz36NqhGxDWb6dstB2m8PX+plZ
+w7jl81MDvUnWs8yiQ/6twgu5AbhWKZQDJKcNKCEpqa6UW0r5nwIDAQABo3oweDAO
+BgNVHQ8BAf8EBAMCAgQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMA8G
+A1UdEwEB/wQFMAMBAf8wGQYDVR0OBBIEEEA31wH7QC+4HH5UBCeMWQEwGwYDVR0j
+BBQwEoAQQDfXAftAL7gcflQEJ4xZATANBgkqhkiG9w0BAQsFAAOBgQDXylEK77Za
+kKeY6ZerrScWyZhrjIGtHFu09qVpdJEzrk87k2G7iHHR9CAvSofCgEExKtWNS9dN
++9WiZp/U48iHLk7qaYXdEuO07No4BYtXn+lkOykE+FUxmA4wvOF1cTd2tdj3MzX2
+kfGIBAYhzGZWhY3JbhIfTEfY1PNM1pWChQ==
+-----END CERTIFICATE-----
+)";
+
+static const char kRootCrossSignedPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICYzCCAcygAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwPDEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxHjAcBgNVBAMTFUNyb3NzLXNpZ25pbmcgUm9v
+dCBDQTAgFw0xNTAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowLjEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxEDAOBgNVBAMTB1Jvb3QgQ0EwgZ8wDQYJKoZI
+hvcNAQEBBQADgY0AMIGJAoGBAOkOfxEM5lrmhoNw9lEHLgJ4EfWyJJI47iZiAseU
+8T6hd2rAj9UiaLZd4kza4IURNcKSckmNgbSIl2u3/LJEW9lNBnD5DMaP6bPfo2qE
+bENZvp2y0Habw9f6mVnDuOXzUwO9SdazzKJD/q3CC7kBuFYplAMkpw0oISmprpRb
+SvmfAgMBAAGjejB4MA4GA1UdDwEB/wQEAwICBDAdBgNVHSUEFjAUBggrBgEFBQcD
+AQYIKwYBBQUHAwIwDwYDVR0TAQH/BAUwAwEB/zAZBgNVHQ4EEgQQQDfXAftAL7gc
+flQEJ4xZATAbBgNVHSMEFDASgBBHKHC7V3Z/3oLvEZx0RZRwMA0GCSqGSIb3DQEB
+CwUAA4GBAErTxYJ0en9HVRHAAr5OO5wuk5Iq3VMc79TMyQLCXVL8YH8Uk7KEwv+q
+9MEKZv2eR/Vfm4HlXlUuIqfgUXbwrAYC/YVVX86Wnbpy/jc73NYVCq8FEZeO+0XU
+90SWAPDdp+iL7aZdimnMtG1qlM1edmz8AKbrhN/R3IbA2CL0nCWV
+-----END CERTIFICATE-----
+)";
+
+static const char kIntermediatePEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICXjCCAcegAwIBAgIJAKJMH+7rscPcMA0GCSqGSIb3DQEBCwUAMC4xGjAYBgNV
+BAoTEUJvcmluZ1NTTCBURVNUSU5HMRAwDgYDVQQDEwdSb290IENBMCAXDTE1MDEw
+MTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjA2MRowGAYDVQQKExFCb3JpbmdTU0wg
+VEVTVElORzEYMBYGA1UEAxMPSW50ZXJtZWRpYXRlIENBMIGfMA0GCSqGSIb3DQEB
+AQUAA4GNADCBiQKBgQC7YtI0l8ocTYJ0gKyXTtPL4iMJCNY4OcxXl48jkncVG1Hl
+blicgNUa1r9m9YFtVkxvBinb8dXiUpEGhVg4awRPDcatlsBSEBuJkiZGYbRcAmSu
+CmZYnf6u3aYQ18SU8WqVERPpE4cwVVs+6kwlzRw0+XDoZAczu8ZezVhCUc6NbQID
+AQABo3oweDAOBgNVHQ8BAf8EBAMCAgQwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsG
+AQUFBwMCMA8GA1UdEwEB/wQFMAMBAf8wGQYDVR0OBBIEEIwaaKi1dttdV3sfjRSy
+BqMwGwYDVR0jBBQwEoAQQDfXAftAL7gcflQEJ4xZATANBgkqhkiG9w0BAQsFAAOB
+gQCvnolNWEHuQS8PFVVyuLR+FKBeUUdrVbSfHSzTqNAqQGp0C9fk5oCzDq6ZgTfY
+ESXM4cJhb3IAnW0UM0NFsYSKQJ50JZL2L3z5ZLQhHdbs4RmODGoC40BVdnJ4/qgB
+aGSh09eQRvAVmbVCviDK2ipkWNegdyI19jFfNP5uIkGlYg==
+-----END CERTIFICATE-----
+)";
+
+static const char kIntermediateSelfSignedPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICZjCCAc+gAwIBAgIJAKJMH+7rscPcMA0GCSqGSIb3DQEBCwUAMDYxGjAYBgNV
+BAoTEUJvcmluZ1NTTCBURVNUSU5HMRgwFgYDVQQDEw9JbnRlcm1lZGlhdGUgQ0Ew
+IBcNMTUwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMDYxGjAYBgNVBAoTEUJv
+cmluZ1NTTCBURVNUSU5HMRgwFgYDVQQDEw9JbnRlcm1lZGlhdGUgQ0EwgZ8wDQYJ
+KoZIhvcNAQEBBQADgY0AMIGJAoGBALti0jSXyhxNgnSArJdO08viIwkI1jg5zFeX
+jyOSdxUbUeVuWJyA1RrWv2b1gW1WTG8GKdvx1eJSkQaFWDhrBE8Nxq2WwFIQG4mS
+JkZhtFwCZK4KZlid/q7dphDXxJTxapURE+kThzBVWz7qTCXNHDT5cOhkBzO7xl7N
+WEJRzo1tAgMBAAGjejB4MA4GA1UdDwEB/wQEAwICBDAdBgNVHSUEFjAUBggrBgEF
+BQcDAQYIKwYBBQUHAwIwDwYDVR0TAQH/BAUwAwEB/zAZBgNVHQ4EEgQQjBpoqLV2
+211Xex+NFLIGozAbBgNVHSMEFDASgBCMGmiotXbbXVd7H40UsgajMA0GCSqGSIb3
+DQEBCwUAA4GBALcccSrAQ0/EqQBsx0ZDTUydHXXNP2DrUkpUKmAXIe8McqIVSlkT
+6H4xz7z8VRKBo9j+drjjtCw2i0CQc8aOLxRb5WJ8eVLnaW2XRlUqAzhF0CrulfVI
+E4Vs6ZLU+fra1WAuIj6qFiigRja+3YkZArG8tMA9vtlhTX/g7YBZIkqH
+-----END CERTIFICATE-----
+)";
+
+static const char kLeafPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICXjCCAcegAwIBAgIIWjO48ufpunYwDQYJKoZIhvcNAQELBQAwNjEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxGDAWBgNVBAMTD0ludGVybWVkaWF0ZSBDQTAg
+Fw0xNTAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowMjEaMBgGA1UEChMRQm9y
+aW5nU1NMIFRFU1RJTkcxFDASBgNVBAMTC2V4YW1wbGUuY29tMIGfMA0GCSqGSIb3
+DQEBAQUAA4GNADCBiQKBgQDD0U0ZYgqShJ7oOjsyNKyVXEHqeafmk/bAoPqY/h1c
+oPw2E8KmeqiUSoTPjG5IXSblOxcqpbAXgnjPzo8DI3GNMhAf8SYNYsoH7gc7Uy7j
+5x8bUrisGnuTHqkqH6d4/e7ETJ7i3CpR8bvK16DggEvQTudLipz8FBHtYhFakfdh
+TwIDAQABo3cwdTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEG
+CCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwGQYDVR0OBBIEEKN5pvbur7mlXjeMEYA0
+4nUwGwYDVR0jBBQwEoAQjBpoqLV2211Xex+NFLIGozANBgkqhkiG9w0BAQsFAAOB
+gQBj/p+JChp//LnXWC1k121LM/ii7hFzQzMrt70bny406SGz9jAjaPOX4S3gt38y
+rhjpPukBlSzgQXFg66y6q5qp1nQTD1Cw6NkKBe9WuBlY3iYfmsf7WT8nhlT1CttU
+xNCwyMX9mtdXdQicOfNjIGUCD5OLV5PgHFPRKiHHioBAhg==
+-----END CERTIFICATE-----
+)";
+
+static const char kLeafNoKeyUsagePEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICNTCCAZ6gAwIBAgIJAIFQGaLQ0G2mMA0GCSqGSIb3DQEBCwUAMDYxGjAYBgNV
+BAoTEUJvcmluZ1NTTCBURVNUSU5HMRgwFgYDVQQDEw9JbnRlcm1lZGlhdGUgQ0Ew
+IBcNMTUwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMDcxGjAYBgNVBAoTEUJv
+cmluZ1NTTCBURVNUSU5HMRkwFwYDVQQDExBldmlsLmV4YW1wbGUuY29tMIGfMA0G
+CSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOKoZe75NPz77EOaMMl4/0s3PyQw++zJvp
+ejHAxZiTPCJgMbEHLrSzNoHdopg+CLUH5bE4wTXM8w9Inv5P8OAFJt7gJuPUunmk
+j+NoU3QfzOR6BroePcz1vXX9jyVHRs087M/sLqWRHu9IR+/A+UTcBaWaFiDVUxtJ
+YOwFMwjNPQIDAQABo0gwRjAMBgNVHRMBAf8EAjAAMBkGA1UdDgQSBBBJfLEUWHq1
+27rZ1AVx2J5GMBsGA1UdIwQUMBKAEIwaaKi1dttdV3sfjRSyBqMwDQYJKoZIhvcN
+AQELBQADgYEALVKN2Y3LZJOtu6SxFIYKxbLaXhTGTdIjxipZhmbBRDFjbZjZZOTe
+6Oo+VDNPYco4rBexK7umYXJyfTqoY0E8dbiImhTcGTEj7OAB3DbBomgU1AYe+t2D
+uwBqh4Y3Eto+Zn4pMVsxGEfUpjzjZDel7bN1/oU/9KWPpDfywfUmjgk=
+-----END CERTIFICATE-----
+)";
+
+static const char kForgeryPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICZzCCAdCgAwIBAgIIdTlMzQoKkeMwDQYJKoZIhvcNAQELBQAwNzEaMBgGA1UE
+ChMRQm9yaW5nU1NMIFRFU1RJTkcxGTAXBgNVBAMTEGV2aWwuZXhhbXBsZS5jb20w
+IBcNMTUwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMDoxGjAYBgNVBAoTEUJv
+cmluZ1NTTCBURVNUSU5HMRwwGgYDVQQDExNmb3JnZXJ5LmV4YW1wbGUuY29tMIGf
+MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDADTwruBQZGb7Ay6s9HiYv5d1lwtEy
+xQdA2Sy8Rn8uA20Q4KgqwVY7wzIZ+z5Butrsmwb70gdG1XU+yRaDeE7XVoW6jSpm
+0sw35/5vJbTcL4THEFbnX0OPZnvpuZDFUkvVtq5kxpDWsVyM24G8EEq7kPih3Sa3
+OMhXVXF8kso6UQIDAQABo3cwdTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI
+KwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwGQYDVR0OBBIEEEYJ/WHM
+8p64erPWIg4/liwwGwYDVR0jBBQwEoAQSXyxFFh6tdu62dQFcdieRjANBgkqhkiG
+9w0BAQsFAAOBgQA+zH7bHPElWRWJvjxDqRexmYLn+D3Aivs8XgXQJsM94W0EzSUf
+DSLfRgaQwcb2gg2xpDFoG+W0vc6O651uF23WGt5JaFFJJxqjII05IexfCNhuPmp4
+4UZAXPttuJXpn74IY1tuouaM06B3vXKZR+/ityKmfJvSwxacmFcK+2ziAg==
+-----END CERTIFICATE-----
+)";
 
 // kExamplePSSCert is an example RSA-PSS self-signed certificate, signed with
 // the default hash functions.
-// static const char kExamplePSSCert[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICYjCCAcagAwIBAgIJAI3qUyT6SIfzMBIGCSqGSIb3DQEBCjAFogMCAWowRTEL
-// MAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVy
-// bmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xNDEwMDkxOTA5NTVaFw0xNTEwMDkxOTA5
-// NTVaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQK
-// DBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwgZ8wDQYJKoZIhvcNAQEBBQADgY0A
-// MIGJAoGBAPi4bIO0vNmoV8CltFl2jFQdeesiUgR+0zfrQf2D+fCmhRU0dXFahKg8
-// 0u9aTtPel4rd/7vPCqqGkr64UOTNb4AzMHYTj8p73OxaymPHAyXvqIqDWHYg+hZ3
-// 13mSYwFIGth7Z/FSVUlO1m5KXNd6NzYM3t2PROjCpywrta9kS2EHAgMBAAGjUDBO
-// MB0GA1UdDgQWBBTQQfuJQR6nrVrsNF1JEflVgXgfEzAfBgNVHSMEGDAWgBTQQfuJ
-// QR6nrVrsNF1JEflVgXgfEzAMBgNVHRMEBTADAQH/MBIGCSqGSIb3DQEBCjAFogMC
-// AWoDgYEASUy2RZcgNbNQZA0/7F+V1YTLEXwD16bm+iSVnzGwtexmQVEYIZG74K/w
-// xbdZQdTbpNJkp1QPjPfh0zsatw6dmt5QoZ8K8No0DjR9dgf+Wvv5WJvJUIQBoAVN
-// Z0IL+OQFz6+LcTHxD27JJCebrATXZA0wThGTQDm7crL+a+SujBY=
-// -----END CERTIFICATE-----
-// )";
+static const char kExamplePSSCert[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICYjCCAcagAwIBAgIJAI3qUyT6SIfzMBIGCSqGSIb3DQEBCjAFogMCAWowRTEL
+MAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVy
+bmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0xNDEwMDkxOTA5NTVaFw0xNTEwMDkxOTA5
+NTVaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQK
+DBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwgZ8wDQYJKoZIhvcNAQEBBQADgY0A
+MIGJAoGBAPi4bIO0vNmoV8CltFl2jFQdeesiUgR+0zfrQf2D+fCmhRU0dXFahKg8
+0u9aTtPel4rd/7vPCqqGkr64UOTNb4AzMHYTj8p73OxaymPHAyXvqIqDWHYg+hZ3
+13mSYwFIGth7Z/FSVUlO1m5KXNd6NzYM3t2PROjCpywrta9kS2EHAgMBAAGjUDBO
+MB0GA1UdDgQWBBTQQfuJQR6nrVrsNF1JEflVgXgfEzAfBgNVHSMEGDAWgBTQQfuJ
+QR6nrVrsNF1JEflVgXgfEzAMBgNVHRMEBTADAQH/MBIGCSqGSIb3DQEBCjAFogMC
+AWoDgYEASUy2RZcgNbNQZA0/7F+V1YTLEXwD16bm+iSVnzGwtexmQVEYIZG74K/w
+xbdZQdTbpNJkp1QPjPfh0zsatw6dmt5QoZ8K8No0DjR9dgf+Wvv5WJvJUIQBoAVN
+Z0IL+OQFz6+LcTHxD27JJCebrATXZA0wThGTQDm7crL+a+SujBY=
+-----END CERTIFICATE-----
+)";
 
 // kBadPSSCertPEM is a self-signed RSA-PSS certificate with bad parameters.
-// static const char kBadPSSCertPEM[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIDdjCCAjqgAwIBAgIJANcwZLyfEv7DMD4GCSqGSIb3DQEBCjAxoA0wCwYJYIZI
-// AWUDBAIBoRowGAYJKoZIhvcNAQEIMAsGCWCGSAFlAwQCAaIEAgIA3jAnMSUwIwYD
-// VQQDDBxUZXN0IEludmFsaWQgUFNTIGNlcnRpZmljYXRlMB4XDTE1MTEwNDE2MDIz
-// NVoXDTE1MTIwNDE2MDIzNVowJzElMCMGA1UEAwwcVGVzdCBJbnZhbGlkIFBTUyBj
-// ZXJ0aWZpY2F0ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMTaM7WH
-// qVCAGAIA+zL1KWvvASTrhlq+1ePdO7wsrWX2KiYoTYrJYTnxhLnn0wrHqApt79nL
-// IBG7cfShyZqFHOY/IzlYPMVt+gPo293gw96Fds5JBsjhjkyGnOyr9OUntFqvxDbT
-// IIFU7o9IdxD4edaqjRv+fegVE+B79pDk4s0ujsk6dULtCg9Rst0ucGFo19mr+b7k
-// dbfn8pZ72ZNDJPueVdrUAWw9oll61UcYfk75XdrLk6JlL41GrYHc8KlfXf43gGQq
-// QfrpHkg4Ih2cI6Wt2nhFGAzrlcorzLliQIUJRIhM8h4IgDfpBpaPdVQLqS2pFbXa
-// 5eQjqiyJwak2vJ8CAwEAAaNQME4wHQYDVR0OBBYEFCt180N4oGUt5LbzBwQ4Ia+2
-// 4V97MB8GA1UdIwQYMBaAFCt180N4oGUt5LbzBwQ4Ia+24V97MAwGA1UdEwQFMAMB
-// Af8wMQYJKoZIhvcNAQEKMCSgDTALBglghkgBZQMEAgGhDTALBgkqhkiG9w0BAQii
-// BAICAN4DggEBAAjBtm90lGxgddjc4Xu/nbXXFHVs2zVcHv/mqOZoQkGB9r/BVgLb
-// xhHrFZ2pHGElbUYPfifdS9ztB73e1d4J+P29o0yBqfd4/wGAc/JA8qgn6AAEO/Xn
-// plhFeTRJQtLZVl75CkHXgUGUd3h+ADvKtcBuW9dSUncaUrgNKR8u/h/2sMG38RWY
-// DzBddC/66YTa3r7KkVUfW7yqRQfELiGKdcm+bjlTEMsvS+EhHup9CzbpoCx2Fx9p
-// NPtFY3yEObQhmL1JyoCRWqBE75GzFPbRaiux5UpEkns+i3trkGssZzsOuVqHNTNZ
-// lC9+9hPHIoc9UMmAQNo1vGIW3NWVoeGbaJ8=
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kRSAKey[] = R"(
-// -----BEGIN RSA PRIVATE KEY-----
-// MIICXgIBAAKBgQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92
-// kWdGMdAQhLciHnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiF
-// KKAnHmUcrgfVW28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQAB
-// AoGBAIBy09Fd4DOq/Ijp8HeKuCMKTHqTW1xGHshLQ6jwVV2vWZIn9aIgmDsvkjCe
-// i6ssZvnbjVcwzSoByhjN8ZCf/i15HECWDFFh6gt0P5z0MnChwzZmvatV/FXCT0j+
-// WmGNB/gkehKjGXLLcjTb6dRYVJSCZhVuOLLcbWIV10gggJQBAkEA8S8sGe4ezyyZ
-// m4e9r95g6s43kPqtj5rewTsUxt+2n4eVodD+ZUlCULWVNAFLkYRTBCASlSrm9Xhj
-// QpmWAHJUkQJBAOVzQdFUaewLtdOJoPCtpYoY1zd22eae8TQEmpGOR11L6kbxLQsk
-// aMly/DOnOaa82tqAGTdqDEZgSNmCeKKknmECQAvpnY8GUOVAubGR6c+W90iBuQLj
-// LtFp/9ihd2w/PoDwrHZaoUYVcT4VSfJQog/k7kjE4MYXYWL8eEKg3WTWQNECQQDk
-// 104Wi91Umd1PzF0ijd2jXOERJU1wEKe6XLkYYNHWQAe5l4J4MWj9OdxFXAxIuuR/
-// tfDwbqkta4xcux67//khAkEAvvRXLHTaa6VFzTaiiO8SaFsHV3lQyXOtMrBpB5jd
-// moZWgjHvB2W9Ckn7sDqsPB+U2tyX0joDdQEyuiMECDY8oQ==
-// -----END RSA PRIVATE KEY-----
-// )";
-
-// static const char kP256Key[] = R"(
-// -----BEGIN PRIVATE KEY-----
-// MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgBw8IcnrUoEqc3VnJ
-// TYlodwi1b8ldMHcO6NHJzgqLtGqhRANCAATmK2niv2Wfl74vHg2UikzVl2u3qR4N
-// Rvvdqakendy6WgHn1peoChj5w8SjHlbifINI2xYaHPUdfvGULUvPciLB
-// -----END PRIVATE KEY-----
-// )";
+static const char kBadPSSCertPEM[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIDdjCCAjqgAwIBAgIJANcwZLyfEv7DMD4GCSqGSIb3DQEBCjAxoA0wCwYJYIZI
+AWUDBAIBoRowGAYJKoZIhvcNAQEIMAsGCWCGSAFlAwQCAaIEAgIA3jAnMSUwIwYD
+VQQDDBxUZXN0IEludmFsaWQgUFNTIGNlcnRpZmljYXRlMB4XDTE1MTEwNDE2MDIz
+NVoXDTE1MTIwNDE2MDIzNVowJzElMCMGA1UEAwwcVGVzdCBJbnZhbGlkIFBTUyBj
+ZXJ0aWZpY2F0ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMTaM7WH
+qVCAGAIA+zL1KWvvASTrhlq+1ePdO7wsrWX2KiYoTYrJYTnxhLnn0wrHqApt79nL
+IBG7cfShyZqFHOY/IzlYPMVt+gPo293gw96Fds5JBsjhjkyGnOyr9OUntFqvxDbT
+IIFU7o9IdxD4edaqjRv+fegVE+B79pDk4s0ujsk6dULtCg9Rst0ucGFo19mr+b7k
+dbfn8pZ72ZNDJPueVdrUAWw9oll61UcYfk75XdrLk6JlL41GrYHc8KlfXf43gGQq
+QfrpHkg4Ih2cI6Wt2nhFGAzrlcorzLliQIUJRIhM8h4IgDfpBpaPdVQLqS2pFbXa
+5eQjqiyJwak2vJ8CAwEAAaNQME4wHQYDVR0OBBYEFCt180N4oGUt5LbzBwQ4Ia+2
+4V97MB8GA1UdIwQYMBaAFCt180N4oGUt5LbzBwQ4Ia+24V97MAwGA1UdEwQFMAMB
+Af8wMQYJKoZIhvcNAQEKMCSgDTALBglghkgBZQMEAgGhDTALBgkqhkiG9w0BAQii
+BAICAN4DggEBAAjBtm90lGxgddjc4Xu/nbXXFHVs2zVcHv/mqOZoQkGB9r/BVgLb
+xhHrFZ2pHGElbUYPfifdS9ztB73e1d4J+P29o0yBqfd4/wGAc/JA8qgn6AAEO/Xn
+plhFeTRJQtLZVl75CkHXgUGUd3h+ADvKtcBuW9dSUncaUrgNKR8u/h/2sMG38RWY
+DzBddC/66YTa3r7KkVUfW7yqRQfELiGKdcm+bjlTEMsvS+EhHup9CzbpoCx2Fx9p
+NPtFY3yEObQhmL1JyoCRWqBE75GzFPbRaiux5UpEkns+i3trkGssZzsOuVqHNTNZ
+lC9+9hPHIoc9UMmAQNo1vGIW3NWVoeGbaJ8=
+-----END CERTIFICATE-----
+)";
+
+static const char kRSAKey[] = R"(
+-----BEGIN RSA PRIVATE KEY-----
+MIICXgIBAAKBgQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92
+kWdGMdAQhLciHnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiF
+KKAnHmUcrgfVW28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQAB
+AoGBAIBy09Fd4DOq/Ijp8HeKuCMKTHqTW1xGHshLQ6jwVV2vWZIn9aIgmDsvkjCe
+i6ssZvnbjVcwzSoByhjN8ZCf/i15HECWDFFh6gt0P5z0MnChwzZmvatV/FXCT0j+
+WmGNB/gkehKjGXLLcjTb6dRYVJSCZhVuOLLcbWIV10gggJQBAkEA8S8sGe4ezyyZ
+m4e9r95g6s43kPqtj5rewTsUxt+2n4eVodD+ZUlCULWVNAFLkYRTBCASlSrm9Xhj
+QpmWAHJUkQJBAOVzQdFUaewLtdOJoPCtpYoY1zd22eae8TQEmpGOR11L6kbxLQsk
+aMly/DOnOaa82tqAGTdqDEZgSNmCeKKknmECQAvpnY8GUOVAubGR6c+W90iBuQLj
+LtFp/9ihd2w/PoDwrHZaoUYVcT4VSfJQog/k7kjE4MYXYWL8eEKg3WTWQNECQQDk
+104Wi91Umd1PzF0ijd2jXOERJU1wEKe6XLkYYNHWQAe5l4J4MWj9OdxFXAxIuuR/
+tfDwbqkta4xcux67//khAkEAvvRXLHTaa6VFzTaiiO8SaFsHV3lQyXOtMrBpB5jd
+moZWgjHvB2W9Ckn7sDqsPB+U2tyX0joDdQEyuiMECDY8oQ==
+-----END RSA PRIVATE KEY-----
+)";
+
+static const char kP256Key[] = R"(
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgBw8IcnrUoEqc3VnJ
+TYlodwi1b8ldMHcO6NHJzgqLtGqhRANCAATmK2niv2Wfl74vHg2UikzVl2u3qR4N
+Rvvdqakendy6WgHn1peoChj5w8SjHlbifINI2xYaHPUdfvGULUvPciLB
+-----END PRIVATE KEY-----
+)";
 
 // kCRLTestRoot is a test root certificate. It has private key:
 //
@@ -333,19 +333,19 @@
 // -----END CERTIFICATE-----
 // )";
 
-// static const char kBasicCRL[] = R"(
-// -----BEGIN X509 CRL-----
-// MIIBpzCBkAIBATANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJVUzETMBEGA1UE
-// CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzESMBAGA1UECgwJ
-// Qm9yaW5nU1NMFw0xNjA5MjYxNTEwNTVaFw0xNjEwMjYxNTEwNTVaoA4wDDAKBgNV
-// HRQEAwIBATANBgkqhkiG9w0BAQsFAAOCAQEAnrBKKgvd9x9zwK9rtUvVeFeJ7+LN
-// ZEAc+a5oxpPNEsJx6hXoApYEbzXMxuWBQoCs5iEBycSGudct21L+MVf27M38KrWo
-// eOkq0a2siqViQZO2Fb/SUFR0k9zb8xl86Zf65lgPplALun0bV/HT7MJcl04Tc4os
-// dsAReBs5nqTGNEd5AlC1iKHvQZkM//MD51DspKnDpsDiUVi54h9C1SpfZmX8H2Vv
-// diyu0fZ/bPAM3VAGawatf/SyWfBMyKpoPXEG39oAzmjjOj8en82psn7m474IGaho
-// /vBbhl1ms5qQiLYPjm4YELtnXQoFyC72tBjbdFd/ZE9k4CNKDbxFUXFbkw==
-// -----END X509 CRL-----
-// )";
+static const char kBasicCRL[] = R"(
+-----BEGIN X509 CRL-----
+MIIBpzCBkAIBATANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJVUzETMBEGA1UE
+CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzESMBAGA1UECgwJ
+Qm9yaW5nU1NMFw0xNjA5MjYxNTEwNTVaFw0xNjEwMjYxNTEwNTVaoA4wDDAKBgNV
+HRQEAwIBATANBgkqhkiG9w0BAQsFAAOCAQEAnrBKKgvd9x9zwK9rtUvVeFeJ7+LN
+ZEAc+a5oxpPNEsJx6hXoApYEbzXMxuWBQoCs5iEBycSGudct21L+MVf27M38KrWo
+eOkq0a2siqViQZO2Fb/SUFR0k9zb8xl86Zf65lgPplALun0bV/HT7MJcl04Tc4os
+dsAReBs5nqTGNEd5AlC1iKHvQZkM//MD51DspKnDpsDiUVi54h9C1SpfZmX8H2Vv
+diyu0fZ/bPAM3VAGawatf/SyWfBMyKpoPXEG39oAzmjjOj8en82psn7m474IGaho
+/vBbhl1ms5qQiLYPjm4YELtnXQoFyC72tBjbdFd/ZE9k4CNKDbxFUXFbkw==
+-----END X509 CRL-----
+)";
 
 // static const char kRevokedCRL[] = R"(
 // -----BEGIN X509 CRL-----
@@ -479,19 +479,19 @@
 // )";
 
 // kEd25519Cert is a self-signed Ed25519 certificate.
-// static const char kEd25519Cert[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBkTCCAUOgAwIBAgIJAJwooam0UCDmMAUGAytlcDBFMQswCQYDVQQGEwJBVTET
-// MBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQ
-// dHkgTHRkMB4XDTE0MDQyMzIzMjE1N1oXDTE0MDUyMzIzMjE1N1owRTELMAkGA1UE
-// BhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVybmV0IFdp
-// ZGdpdHMgUHR5IEx0ZDAqMAUGAytlcAMhANdamAGCsQq31Uv+08lkBzoO4XLz2qYj
-// Ja8CGmj3B1Eao1AwTjAdBgNVHQ4EFgQUoux7eV+fJK2v3ah6QPU/lj1/+7UwHwYD
-// VR0jBBgwFoAUoux7eV+fJK2v3ah6QPU/lj1/+7UwDAYDVR0TBAUwAwEB/zAFBgMr
-// ZXADQQBuCzqji8VP9xU8mHEMjXGChX7YP5J664UyVKHKH9Z1u4wEbB8dJ3ScaWSL
-// r+VHVKUhsrvcdCelnXRrrSD7xWAL
-// -----END CERTIFICATE-----
-// )";
+static const char kEd25519Cert[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBkTCCAUOgAwIBAgIJAJwooam0UCDmMAUGAytlcDBFMQswCQYDVQQGEwJBVTET
+MBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQ
+dHkgTHRkMB4XDTE0MDQyMzIzMjE1N1oXDTE0MDUyMzIzMjE1N1owRTELMAkGA1UE
+BhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVybmV0IFdp
+ZGdpdHMgUHR5IEx0ZDAqMAUGAytlcAMhANdamAGCsQq31Uv+08lkBzoO4XLz2qYj
+Ja8CGmj3B1Eao1AwTjAdBgNVHQ4EFgQUoux7eV+fJK2v3ah6QPU/lj1/+7UwHwYD
+VR0jBBgwFoAUoux7eV+fJK2v3ah6QPU/lj1/+7UwDAYDVR0TBAUwAwEB/zAFBgMr
+ZXADQQBuCzqji8VP9xU8mHEMjXGChX7YP5J664UyVKHKH9Z1u4wEbB8dJ3ScaWSL
+r+VHVKUhsrvcdCelnXRrrSD7xWAL
+-----END CERTIFICATE-----
+)";
 
 // kEd25519CertNull is an invalid self-signed Ed25519 with an explicit NULL in
 // the signature algorithm.
@@ -562,23 +562,23 @@
 // YvJUG1zoHwUVrxxbR3DbpTODlktLcl/0b97D0IkH3w==
 // -----END RSA PRIVATE KEY-----
 
-// static const char kSANTypesRoot[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIICTTCCAbagAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwKzEXMBUGA1UE
-// ChMOQm9yaW5nU1NMIFRlc3QxEDAOBgNVBAMTB1Jvb3QgQ0EwHhcNMTUwMTAxMDAw
-// MDAwWhcNMjUwMTAxMDAwMDAwWjArMRcwFQYDVQQKEw5Cb3JpbmdTU0wgVGVzdDEQ
-// MA4GA1UEAxMHUm9vdCBDQTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA6Q5/
-// EQzmWuaGg3D2UQcuAngR9bIkkjjuJmICx5TxPqF3asCP1SJotl3iTNrghRE1wpJy
-// SY2BtIiXa7f8skRb2U0GcPkMxo/ps9+jaoRsQ1m+nbLQdpvD1/qZWcO45fNTA71J
-// 1rPMokP+rcILuQG4VimUAySnDSghKamulFtK+Z8CAwEAAaN6MHgwDgYDVR0PAQH/
-// BAQDAgIEMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAPBgNVHRMBAf8E
-// BTADAQH/MBkGA1UdDgQSBBBAN9cB+0AvuBx+VAQnjFkBMBsGA1UdIwQUMBKAEEA3
-// 1wH7QC+4HH5UBCeMWQEwDQYJKoZIhvcNAQELBQADgYEAc4N6hTE62/3gwg+kyc2f
-// c/Jj1mHrOt+0NRaBnmvbmNpsEjHS96Ef4Wt/ZlPXPkkv1C1VosJnOIMF3Q522wRH
-// bqaxARldS12VAa3gcWisDWD+SqSyDxjyojz0XDiJkTrFuCTCUiZO+1GLB7SO10Ms
-// d5YVX0c90VMnUhF/dlrqS9U=
-// -----END CERTIFICATE-----
-// )";
+static const char kSANTypesRoot[] = R"(
+-----BEGIN CERTIFICATE-----
+MIICTTCCAbagAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwKzEXMBUGA1UE
+ChMOQm9yaW5nU1NMIFRlc3QxEDAOBgNVBAMTB1Jvb3QgQ0EwHhcNMTUwMTAxMDAw
+MDAwWhcNMjUwMTAxMDAwMDAwWjArMRcwFQYDVQQKEw5Cb3JpbmdTU0wgVGVzdDEQ
+MA4GA1UEAxMHUm9vdCBDQTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA6Q5/
+EQzmWuaGg3D2UQcuAngR9bIkkjjuJmICx5TxPqF3asCP1SJotl3iTNrghRE1wpJy
+SY2BtIiXa7f8skRb2U0GcPkMxo/ps9+jaoRsQ1m+nbLQdpvD1/qZWcO45fNTA71J
+1rPMokP+rcILuQG4VimUAySnDSghKamulFtK+Z8CAwEAAaN6MHgwDgYDVR0PAQH/
+BAQDAgIEMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAPBgNVHRMBAf8E
+BTADAQH/MBkGA1UdDgQSBBBAN9cB+0AvuBx+VAQnjFkBMBsGA1UdIwQUMBKAEEA3
+1wH7QC+4HH5UBCeMWQEwDQYJKoZIhvcNAQELBQADgYEAc4N6hTE62/3gwg+kyc2f
+c/Jj1mHrOt+0NRaBnmvbmNpsEjHS96Ef4Wt/ZlPXPkkv1C1VosJnOIMF3Q522wRH
+bqaxARldS12VAa3gcWisDWD+SqSyDxjyojz0XDiJkTrFuCTCUiZO+1GLB7SO10Ms
+d5YVX0c90VMnUhF/dlrqS9U=
+-----END CERTIFICATE-----
+)";
 
 // -----BEGIN RSA PRIVATE KEY-----
 // MIICXAIBAAKBgQDpDn8RDOZa5oaDcPZRBy4CeBH1siSSOO4mYgLHlPE+oXdqwI/V
@@ -675,62 +675,62 @@
 
 // kNoBasicConstraintsCertSignIntermediate doesn't have isCA set, but contains
 // certSign in the keyUsage.
-// static const char kNoBasicConstraintsCertSignIntermediate[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBqjCCAROgAwIBAgIBAjANBgkqhkiG9w0BAQsFADArMRcwFQYDVQQKEw5Cb3Jp
-// bmdTU0wgVGVzdDEQMA4GA1UEAxMHUm9vdCBDQTAgFw0wMDAxMDEwMDAwMDBaGA8y
-// MDk5MDEwMTAwMDAwMFowHzEdMBsGA1UEAxMUTm8gQmFzaWMgQ29uc3RyYWludHMw
-// WTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASEFMblfxIEDO8My7wHtHWTuDzNyID1
-// OsPkMGkn32O/pSyXxXuAqDeFoMVffUMTyfm8JcYugSEbrv2qEXXM4bZRoy8wLTAO
-// BgNVHQ8BAf8EBAMCAgQwGwYDVR0jBBQwEoAQQDfXAftAL7gcflQEJ4xZATANBgkq
-// hkiG9w0BAQsFAAOBgQC1Lh6hIAm3K5kRh5iIydU0YAEm7eV6ZSskERDUq3DLJyl9
-// ZUZCHUzvb464dkwZjeNzaUVS1pdElJslwX3DtGgeJLJGCnk8zUjBjaNrrDm0kzPW
-// xKt/6oif1ci/KCKqKNXJAIFbc4e+IiBpenwpxHk3If4NM+Ek0nKoO8Uj0NkgTQ==
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kNoBasicConstraintsCertSignLeaf[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBUDCB96ADAgECAgEDMAoGCCqGSM49BAMCMB8xHTAbBgNVBAMTFE5vIEJhc2lj
-// IENvbnN0cmFpbnRzMCAXDTAwMDEwMTAwMDAwMFoYDzIwOTkwMTAxMDAwMDAwWjAx
-// MS8wLQYDVQQDEyZMZWFmIGZyb20gQ0Egd2l0aCBubyBCYXNpYyBDb25zdHJhaW50
-// czBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEsYPMwzdJKjB+2gpC90ib2ilHoB
-// w/arQ6ikUX0CNUDDaKaOu/jF39ogzVlg4lDFrjCKShSfCCcrwgONv70IZGijEDAO
-// MAwGA1UdEwEB/wQCMAAwCgYIKoZIzj0EAwIDSAAwRQIgbV7R99yM+okXSIs6Fp3o
-// eCOXiDL60IBxaTOcLS44ywcCIQDbn87Gj5cFgHBYAkzdHqDsyGXkxQTHDq9jmX24
-// Djy3Zw==
-// -----END CERTIFICATE-----
-// )";
+static const char kNoBasicConstraintsCertSignIntermediate[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBqjCCAROgAwIBAgIBAjANBgkqhkiG9w0BAQsFADArMRcwFQYDVQQKEw5Cb3Jp
+bmdTU0wgVGVzdDEQMA4GA1UEAxMHUm9vdCBDQTAgFw0wMDAxMDEwMDAwMDBaGA8y
+MDk5MDEwMTAwMDAwMFowHzEdMBsGA1UEAxMUTm8gQmFzaWMgQ29uc3RyYWludHMw
+WTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASEFMblfxIEDO8My7wHtHWTuDzNyID1
+OsPkMGkn32O/pSyXxXuAqDeFoMVffUMTyfm8JcYugSEbrv2qEXXM4bZRoy8wLTAO
+BgNVHQ8BAf8EBAMCAgQwGwYDVR0jBBQwEoAQQDfXAftAL7gcflQEJ4xZATANBgkq
+hkiG9w0BAQsFAAOBgQC1Lh6hIAm3K5kRh5iIydU0YAEm7eV6ZSskERDUq3DLJyl9
+ZUZCHUzvb464dkwZjeNzaUVS1pdElJslwX3DtGgeJLJGCnk8zUjBjaNrrDm0kzPW
+xKt/6oif1ci/KCKqKNXJAIFbc4e+IiBpenwpxHk3If4NM+Ek0nKoO8Uj0NkgTQ==
+-----END CERTIFICATE-----
+)";
+
+static const char kNoBasicConstraintsCertSignLeaf[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBUDCB96ADAgECAgEDMAoGCCqGSM49BAMCMB8xHTAbBgNVBAMTFE5vIEJhc2lj
+IENvbnN0cmFpbnRzMCAXDTAwMDEwMTAwMDAwMFoYDzIwOTkwMTAxMDAwMDAwWjAx
+MS8wLQYDVQQDEyZMZWFmIGZyb20gQ0Egd2l0aCBubyBCYXNpYyBDb25zdHJhaW50
+czBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEsYPMwzdJKjB+2gpC90ib2ilHoB
+w/arQ6ikUX0CNUDDaKaOu/jF39ogzVlg4lDFrjCKShSfCCcrwgONv70IZGijEDAO
+MAwGA1UdEwEB/wQCMAAwCgYIKoZIzj0EAwIDSAAwRQIgbV7R99yM+okXSIs6Fp3o
+eCOXiDL60IBxaTOcLS44ywcCIQDbn87Gj5cFgHBYAkzdHqDsyGXkxQTHDq9jmX24
+Djy3Zw==
+-----END CERTIFICATE-----
+)";
 
 // kNoBasicConstraintsNetscapeCAIntermediate doesn't have isCA set, but contains
 // a Netscape certificate-type extension that asserts a type of "SSL CA".
-// static const char kNoBasicConstraintsNetscapeCAIntermediate[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBuDCCASGgAwIBAgIBAjANBgkqhkiG9w0BAQsFADArMRcwFQYDVQQKEw5Cb3Jp
-// bmdTU0wgVGVzdDEQMA4GA1UEAxMHUm9vdCBDQTAgFw0wMDAxMDEwMDAwMDBaGA8y
-// MDk5MDEwMTAwMDAwMFowKjEoMCYGA1UEAxMfTm8gQmFzaWMgQ29uc3RyYWludHMg
-// KE5ldHNjYXBlKTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCeMbmCaOtMzXBqi
-// PrCdNOH23CkaawUA+pAezitAN4RXS1O2CGK5sJjGPVVeogROU8G7/b+mU+ciZIzH
-// 1PP8FJKjMjAwMBsGA1UdIwQUMBKAEEA31wH7QC+4HH5UBCeMWQEwEQYJYIZIAYb4
-// QgEBBAQDAgIEMA0GCSqGSIb3DQEBCwUAA4GBAAgNWjh7cfBTClTAk+Ml//5xb9Ju
-// tkBhG6Rm+kkMD+qiSMO6t7xS7CsA0+jIBjkdEYaLZ3oxtQCBdZsVNxUvRxZ0AUfF
-// G3DtRFTsrI1f7IQhpMuqEMF4shPW+5x54hrq0Fo6xMs6XoinJZcTUaaB8EeXRF6M
-// P9p6HuyLrmn0c/F0
-// -----END CERTIFICATE-----
-// )";
-
-// static const char kNoBasicConstraintsNetscapeCALeaf[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBXDCCAQKgAwIBAgIBAzAKBggqhkjOPQQDAjAqMSgwJgYDVQQDEx9ObyBCYXNp
-// YyBDb25zdHJhaW50cyAoTmV0c2NhcGUpMCAXDTAwMDEwMTAwMDAwMFoYDzIwOTkw
-// MTAxMDAwMDAwWjAxMS8wLQYDVQQDEyZMZWFmIGZyb20gQ0Egd2l0aCBubyBCYXNp
-// YyBDb25zdHJhaW50czBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDlJKolDu3R2
-// tPqSDycr0QJcWhxdBv76V0EEVflcHRxED6vAioTEcnQszt1OfKtBZvjlo0yp6i6Q
-// DaYit0ZInmWjEDAOMAwGA1UdEwEB/wQCMAAwCgYIKoZIzj0EAwIDSAAwRQIhAJsh
-// aZL6BHeEfoUBj1oZ2Ln91qzj3UCVMJ+vrmwAFdYyAiA3wp2JphgchvmoUFuzPXwj
-// XyPwWPbymSTpzKhB4xB7qQ==
-// -----END CERTIFICATE-----
-// )";
+static const char kNoBasicConstraintsNetscapeCAIntermediate[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBuDCCASGgAwIBAgIBAjANBgkqhkiG9w0BAQsFADArMRcwFQYDVQQKEw5Cb3Jp
+bmdTU0wgVGVzdDEQMA4GA1UEAxMHUm9vdCBDQTAgFw0wMDAxMDEwMDAwMDBaGA8y
+MDk5MDEwMTAwMDAwMFowKjEoMCYGA1UEAxMfTm8gQmFzaWMgQ29uc3RyYWludHMg
+KE5ldHNjYXBlKTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCeMbmCaOtMzXBqi
+PrCdNOH23CkaawUA+pAezitAN4RXS1O2CGK5sJjGPVVeogROU8G7/b+mU+ciZIzH
+1PP8FJKjMjAwMBsGA1UdIwQUMBKAEEA31wH7QC+4HH5UBCeMWQEwEQYJYIZIAYb4
+QgEBBAQDAgIEMA0GCSqGSIb3DQEBCwUAA4GBAAgNWjh7cfBTClTAk+Ml//5xb9Ju
+tkBhG6Rm+kkMD+qiSMO6t7xS7CsA0+jIBjkdEYaLZ3oxtQCBdZsVNxUvRxZ0AUfF
+G3DtRFTsrI1f7IQhpMuqEMF4shPW+5x54hrq0Fo6xMs6XoinJZcTUaaB8EeXRF6M
+P9p6HuyLrmn0c/F0
+-----END CERTIFICATE-----
+)";
+
+static const char kNoBasicConstraintsNetscapeCALeaf[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBXDCCAQKgAwIBAgIBAzAKBggqhkjOPQQDAjAqMSgwJgYDVQQDEx9ObyBCYXNp
+YyBDb25zdHJhaW50cyAoTmV0c2NhcGUpMCAXDTAwMDEwMTAwMDAwMFoYDzIwOTkw
+MTAxMDAwMDAwWjAxMS8wLQYDVQQDEyZMZWFmIGZyb20gQ0Egd2l0aCBubyBCYXNp
+YyBDb25zdHJhaW50czBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDlJKolDu3R2
+tPqSDycr0QJcWhxdBv76V0EEVflcHRxED6vAioTEcnQszt1OfKtBZvjlo0yp6i6Q
+DaYit0ZInmWjEDAOMAwGA1UdEwEB/wQCMAAwCgYIKoZIzj0EAwIDSAAwRQIhAJsh
+aZL6BHeEfoUBj1oZ2Ln91qzj3UCVMJ+vrmwAFdYyAiA3wp2JphgchvmoUFuzPXwj
+XyPwWPbymSTpzKhB4xB7qQ==
+-----END CERTIFICATE-----
+)";
 
 // static const char kSelfSignedMismatchAlgorithms[] = R"(
 // -----BEGIN CERTIFICATE-----
@@ -1049,19 +1049,19 @@
 
 // CertFromPEM parses the given, NUL-terminated PEM block and returns an
 // |X509*|.
-// static bssl::UniquePtr<X509> CertFromPEM(const char *pem) {
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
-//   return bssl::UniquePtr<X509>(
-//       PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
-// }
+static bssl::UniquePtr<X509> CertFromPEM(const char *pem) {
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
+  return bssl::UniquePtr<X509>(
+      PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
+}
 
 // CRLFromPEM parses the given, NUL-terminated PEM block and returns an
 // |X509_CRL*|.
-// static bssl::UniquePtr<X509_CRL> CRLFromPEM(const char *pem) {
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
-//   return bssl::UniquePtr<X509_CRL>(
-//       PEM_read_bio_X509_CRL(bio.get(), nullptr, nullptr, nullptr));
-// }
+static bssl::UniquePtr<X509_CRL> CRLFromPEM(const char *pem) {
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
+  return bssl::UniquePtr<X509_CRL>(
+      PEM_read_bio_X509_CRL(bio.get(), nullptr, nullptr, nullptr));
+}
 
 // CSRFromPEM parses the given, NUL-terminated PEM block and returns an
 // |X509_REQ*|.
@@ -1073,199 +1073,199 @@
 
 // PrivateKeyFromPEM parses the given, NUL-terminated PEM block and returns an
 // |EVP_PKEY*|.
-// static bssl::UniquePtr<EVP_PKEY> PrivateKeyFromPEM(const char *pem) {
-//   bssl::UniquePtr<BIO> bio(
-//       BIO_new_mem_buf(const_cast<char *>(pem), strlen(pem)));
-//   return bssl::UniquePtr<EVP_PKEY>(
-//       PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
-// }
+static bssl::UniquePtr<EVP_PKEY> PrivateKeyFromPEM(const char *pem) {
+  bssl::UniquePtr<BIO> bio(
+      BIO_new_mem_buf(const_cast<char *>(pem), strlen(pem)));
+  return bssl::UniquePtr<EVP_PKEY>(
+      PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
+}
 
 // CertsToStack converts a vector of |X509*| to an OpenSSL STACK_OF(X509),
 // bumping the reference counts for each certificate in question.
-// static bssl::UniquePtr<STACK_OF(X509)> CertsToStack(
-//     const std::vector<X509 *> &certs) {
-//   bssl::UniquePtr<STACK_OF(X509)> stack(sk_X509_new_null());
-//   if (!stack) {
-//     return nullptr;
-//   }
-//   for (auto cert : certs) {
-//     if (!bssl::PushToStack(stack.get(), bssl::UpRef(cert))) {
-//       return nullptr;
-//     }
-//   }
+static bssl::UniquePtr<STACK_OF(X509)> CertsToStack(
+    const std::vector<X509 *> &certs) {
+  bssl::UniquePtr<STACK_OF(X509)> stack(sk_X509_new_null());
+  if (!stack) {
+    return nullptr;
+  }
+  for (auto cert : certs) {
+    if (!bssl::PushToStack(stack.get(), bssl::UpRef(cert))) {
+      return nullptr;
+    }
+  }
 
-//   return stack;
-// }
+  return stack;
+}
 
 // CRLsToStack converts a vector of |X509_CRL*| to an OpenSSL
 // STACK_OF(X509_CRL), bumping the reference counts for each CRL in question.
-// static bssl::UniquePtr<STACK_OF(X509_CRL)> CRLsToStack(
-//     const std::vector<X509_CRL *> &crls) {
-//   bssl::UniquePtr<STACK_OF(X509_CRL)> stack(sk_X509_CRL_new_null());
-//   if (!stack) {
-//     return nullptr;
-//   }
-//   for (auto crl : crls) {
-//     if (!bssl::PushToStack(stack.get(), bssl::UpRef(crl))) {
-//       return nullptr;
-//     }
-//   }
-
-//   return stack;
-// }
-
-// static const time_t kReferenceTime = 1474934400 /* Sep 27th, 2016 */;
-
-// static int Verify(
-//     X509 *leaf, const std::vector<X509 *> &roots,
-//     const std::vector<X509 *> &intermediates,
-//     const std::vector<X509_CRL *> &crls, unsigned long flags = 0,
-//     std::function<void(X509_VERIFY_PARAM *)> configure_callback = nullptr,
-//     int (*verify_callback)(int, X509_STORE_CTX *) = nullptr) {
-//   bssl::UniquePtr<STACK_OF(X509)> roots_stack(CertsToStack(roots));
-//   bssl::UniquePtr<STACK_OF(X509)> intermediates_stack(
-//       CertsToStack(intermediates));
-//   bssl::UniquePtr<STACK_OF(X509_CRL)> crls_stack(CRLsToStack(crls));
-
-//   if (!roots_stack ||
-//       !intermediates_stack ||
-//       !crls_stack) {
-//     return X509_V_ERR_UNSPECIFIED;
-//   }
-
-//   bssl::UniquePtr<X509_STORE_CTX> ctx(X509_STORE_CTX_new());
-//   bssl::UniquePtr<X509_STORE> store(X509_STORE_new());
-//   if (!ctx ||
-//       !store) {
-//     return X509_V_ERR_UNSPECIFIED;
-//   }
-
-//   if (!X509_STORE_CTX_init(ctx.get(), store.get(), leaf,
-//                            intermediates_stack.get())) {
-//     return X509_V_ERR_UNSPECIFIED;
-//   }
-
-//   X509_STORE_CTX_trusted_stack(ctx.get(), roots_stack.get());
-//   X509_STORE_CTX_set0_crls(ctx.get(), crls_stack.get());
-
-//   X509_VERIFY_PARAM *param = X509_STORE_CTX_get0_param(ctx.get());
-//   X509_VERIFY_PARAM_set_time(param, kReferenceTime);
-//   if (configure_callback) {
-//     configure_callback(param);
-//   }
-//   if (flags) {
-//     X509_VERIFY_PARAM_set_flags(param, flags);
-//   }
-
-//   ERR_clear_error();
-//   if (X509_verify_cert(ctx.get()) != 1) {
-//     return X509_STORE_CTX_get_error(ctx.get());
-//   }
-
-//   return X509_V_OK;
-// }
-
-// TEST(X509Test, TestVerify) {
-//   //  cross_signing_root
-//   //         |
-//   //   root_cross_signed    root
-//   //              \         /
-//   //             intermediate
-//   //                |     |
-//   //              leaf  leaf_no_key_usage
-//   //                      |
-//   //                    forgery
-//   bssl::UniquePtr<X509> cross_signing_root(CertFromPEM(kCrossSigningRootPEM));
-//   bssl::UniquePtr<X509> root(CertFromPEM(kRootCAPEM));
-//   bssl::UniquePtr<X509> root_cross_signed(CertFromPEM(kRootCrossSignedPEM));
-//   bssl::UniquePtr<X509> intermediate(CertFromPEM(kIntermediatePEM));
-//   bssl::UniquePtr<X509> intermediate_self_signed(
-//       CertFromPEM(kIntermediateSelfSignedPEM));
-//   bssl::UniquePtr<X509> leaf(CertFromPEM(kLeafPEM));
-//   bssl::UniquePtr<X509> leaf_no_key_usage(CertFromPEM(kLeafNoKeyUsagePEM));
-//   bssl::UniquePtr<X509> forgery(CertFromPEM(kForgeryPEM));
-
-//   ASSERT_TRUE(cross_signing_root);
-//   ASSERT_TRUE(root);
-//   ASSERT_TRUE(root_cross_signed);
-//   ASSERT_TRUE(intermediate);
-//   ASSERT_TRUE(intermediate_self_signed);
-//   ASSERT_TRUE(leaf);
-//   ASSERT_TRUE(forgery);
-//   ASSERT_TRUE(leaf_no_key_usage);
-
-//   // Most of these tests work with or without |X509_V_FLAG_TRUSTED_FIRST|,
-//   // though in different ways.
-//   for (bool trusted_first : {true, false}) {
-//     SCOPED_TRACE(trusted_first);
-//     std::function<void(X509_VERIFY_PARAM *)> configure_callback;
-//     if (!trusted_first) {
-//       // Note we need the callback to clear the flag. Setting |flags| to zero
-//       // only skips setting new flags.
-//       configure_callback = [&](X509_VERIFY_PARAM *param) {
-//         X509_VERIFY_PARAM_clear_flags(param, X509_V_FLAG_TRUSTED_FIRST);
-//       };
-//     }
-
-//     // No trust anchors configured.
-//     ASSERT_EQ(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
-//               Verify(leaf.get(), /*roots=*/{}, /*intermediates=*/{},
-//                      /*crls=*/{}, /*flags=*/0, configure_callback));
-//     ASSERT_EQ(
-//         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
-//         Verify(leaf.get(), /*roots=*/{}, {intermediate.get()}, /*crls=*/{},
-//                /*flags=*/0, configure_callback));
-
-//     // Each chain works individually.
-//     ASSERT_EQ(X509_V_OK, Verify(leaf.get(), {root.get()}, {intermediate.get()},
-//                                 /*crls=*/{}, /*flags=*/0, configure_callback));
-//     ASSERT_EQ(X509_V_OK, Verify(leaf.get(), {cross_signing_root.get()},
-//                                 {intermediate.get(), root_cross_signed.get()},
-//                                 /*crls=*/{}, /*flags=*/0, configure_callback));
-
-//     // When both roots are available, we pick one or the other.
-//     ASSERT_EQ(X509_V_OK,
-//               Verify(leaf.get(), {cross_signing_root.get(), root.get()},
-//                      {intermediate.get(), root_cross_signed.get()}, /*crls=*/{},
-//                      /*flags=*/0, configure_callback));
-
-//     // This is the “altchains” test – we remove the cross-signing CA but include
-//     // the cross-sign in the intermediates. With |trusted_first|, we
-//     // preferentially stop path-building at |intermediate|. Without
-//     // |trusted_first|, the "altchains" logic repairs it.
-//     ASSERT_EQ(X509_V_OK, Verify(leaf.get(), {root.get()},
-//                                 {intermediate.get(), root_cross_signed.get()},
-//                                 /*crls=*/{}, /*flags=*/0, configure_callback));
-
-//     // If |X509_V_FLAG_NO_ALT_CHAINS| is set and |trusted_first| is disabled, we
-//     // get stuck on |root_cross_signed|. If either feature is enabled, we can
-//     // build the path.
-//     //
-//     // This test exists to confirm our current behavior, but these modes are
-//     // just workarounds for not having an actual path-building verifier. If we
-//     // fix it, this test can be removed.
-//     ASSERT_EQ(trusted_first ? X509_V_OK
-//                             : X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
-//               Verify(leaf.get(), {root.get()},
-//                      {intermediate.get(), root_cross_signed.get()}, /*crls=*/{},
-//                      /*flags=*/X509_V_FLAG_NO_ALT_CHAINS, configure_callback));
-
-//     // |forgery| is signed by |leaf_no_key_usage|, but is rejected because the
-//     // leaf is not a CA.
-//     ASSERT_EQ(X509_V_ERR_INVALID_CA,
-//               Verify(forgery.get(), {intermediate_self_signed.get()},
-//                      {leaf_no_key_usage.get()}, /*crls=*/{}, /*flags=*/0,
-//                      configure_callback));
-
-//     // Test that one cannot skip Basic Constraints checking with a contorted set
-//     // of roots and intermediates. This is a regression test for CVE-2015-1793.
-//     ASSERT_EQ(X509_V_ERR_INVALID_CA,
-//               Verify(forgery.get(),
-//                      {intermediate_self_signed.get(), root_cross_signed.get()},
-//                      {leaf_no_key_usage.get(), intermediate.get()}, /*crls=*/{},
-//                      /*flags=*/0, configure_callback));
-//   }
-// }
+static bssl::UniquePtr<STACK_OF(X509_CRL)> CRLsToStack(
+    const std::vector<X509_CRL *> &crls) {
+  bssl::UniquePtr<STACK_OF(X509_CRL)> stack(sk_X509_CRL_new_null());
+  if (!stack) {
+    return nullptr;
+  }
+  for (auto crl : crls) {
+    if (!bssl::PushToStack(stack.get(), bssl::UpRef(crl))) {
+      return nullptr;
+    }
+  }
+
+  return stack;
+}
+
+static const time_t kReferenceTime = 1474934400 /* Sep 27th, 2016 */;
+
+static int Verify(
+    X509 *leaf, const std::vector<X509 *> &roots,
+    const std::vector<X509 *> &intermediates,
+    const std::vector<X509_CRL *> &crls, unsigned long flags = 0,
+    std::function<void(X509_VERIFY_PARAM *)> configure_callback = nullptr,
+    int (*verify_callback)(int, X509_STORE_CTX *) = nullptr) {
+  bssl::UniquePtr<STACK_OF(X509)> roots_stack(CertsToStack(roots));
+  bssl::UniquePtr<STACK_OF(X509)> intermediates_stack(
+      CertsToStack(intermediates));
+  bssl::UniquePtr<STACK_OF(X509_CRL)> crls_stack(CRLsToStack(crls));
+
+  if (!roots_stack ||
+      !intermediates_stack ||
+      !crls_stack) {
+    return X509_V_ERR_UNSPECIFIED;
+  }
+
+  bssl::UniquePtr<X509_STORE_CTX> ctx(X509_STORE_CTX_new());
+  bssl::UniquePtr<X509_STORE> store(X509_STORE_new());
+  if (!ctx ||
+      !store) {
+    return X509_V_ERR_UNSPECIFIED;
+  }
+
+  if (!X509_STORE_CTX_init(ctx.get(), store.get(), leaf,
+                           intermediates_stack.get())) {
+    return X509_V_ERR_UNSPECIFIED;
+  }
+
+  X509_STORE_CTX_trusted_stack(ctx.get(), roots_stack.get());
+  X509_STORE_CTX_set0_crls(ctx.get(), crls_stack.get());
+
+  X509_VERIFY_PARAM *param = X509_STORE_CTX_get0_param(ctx.get());
+  X509_VERIFY_PARAM_set_time(param, kReferenceTime);
+  if (configure_callback) {
+    configure_callback(param);
+  }
+  if (flags) {
+    X509_VERIFY_PARAM_set_flags(param, flags);
+  }
+
+  ERR_clear_error();
+  if (X509_verify_cert(ctx.get()) != 1) {
+    return X509_STORE_CTX_get_error(ctx.get());
+  }
+
+  return X509_V_OK;
+}
+
+TEST(X509Test, TestVerify) {
+  //  cross_signing_root
+  //         |
+  //   root_cross_signed    root
+  //              \         /
+  //             intermediate
+  //                |     |
+  //              leaf  leaf_no_key_usage
+  //                      |
+  //                    forgery
+  bssl::UniquePtr<X509> cross_signing_root(CertFromPEM(kCrossSigningRootPEM));
+  bssl::UniquePtr<X509> root(CertFromPEM(kRootCAPEM));
+  bssl::UniquePtr<X509> root_cross_signed(CertFromPEM(kRootCrossSignedPEM));
+  bssl::UniquePtr<X509> intermediate(CertFromPEM(kIntermediatePEM));
+  bssl::UniquePtr<X509> intermediate_self_signed(
+      CertFromPEM(kIntermediateSelfSignedPEM));
+  bssl::UniquePtr<X509> leaf(CertFromPEM(kLeafPEM));
+  bssl::UniquePtr<X509> leaf_no_key_usage(CertFromPEM(kLeafNoKeyUsagePEM));
+  bssl::UniquePtr<X509> forgery(CertFromPEM(kForgeryPEM));
+
+  ASSERT_TRUE(cross_signing_root);
+  ASSERT_TRUE(root);
+  ASSERT_TRUE(root_cross_signed);
+  ASSERT_TRUE(intermediate);
+  ASSERT_TRUE(intermediate_self_signed);
+  ASSERT_TRUE(leaf);
+  ASSERT_TRUE(forgery);
+  ASSERT_TRUE(leaf_no_key_usage);
+
+  // Most of these tests work with or without |X509_V_FLAG_TRUSTED_FIRST|,
+  // though in different ways.
+  for (bool trusted_first : {true, false}) {
+    SCOPED_TRACE(trusted_first);
+    std::function<void(X509_VERIFY_PARAM *)> configure_callback;
+    if (!trusted_first) {
+      // Note we need the callback to clear the flag. Setting |flags| to zero
+      // only skips setting new flags.
+      configure_callback = [&](X509_VERIFY_PARAM *param) {
+        X509_VERIFY_PARAM_clear_flags(param, X509_V_FLAG_TRUSTED_FIRST);
+      };
+    }
+
+    // No trust anchors configured.
+    ASSERT_EQ(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
+              Verify(leaf.get(), /*roots=*/{}, /*intermediates=*/{},
+                     /*crls=*/{}, /*flags=*/0, configure_callback));
+    ASSERT_EQ(
+        X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
+        Verify(leaf.get(), /*roots=*/{}, {intermediate.get()}, /*crls=*/{},
+               /*flags=*/0, configure_callback));
+
+    // Each chain works individually.
+    ASSERT_EQ(X509_V_OK, Verify(leaf.get(), {root.get()}, {intermediate.get()},
+                                /*crls=*/{}, /*flags=*/0, configure_callback));
+    ASSERT_EQ(X509_V_OK, Verify(leaf.get(), {cross_signing_root.get()},
+                                {intermediate.get(), root_cross_signed.get()},
+                                /*crls=*/{}, /*flags=*/0, configure_callback));
+
+    // When both roots are available, we pick one or the other.
+    ASSERT_EQ(X509_V_OK,
+              Verify(leaf.get(), {cross_signing_root.get(), root.get()},
+                     {intermediate.get(), root_cross_signed.get()}, /*crls=*/{},
+                     /*flags=*/0, configure_callback));
+
+    // This is the “altchains” test – we remove the cross-signing CA but include
+    // the cross-sign in the intermediates. With |trusted_first|, we
+    // preferentially stop path-building at |intermediate|. Without
+    // |trusted_first|, the "altchains" logic repairs it.
+    ASSERT_EQ(X509_V_OK, Verify(leaf.get(), {root.get()},
+                                {intermediate.get(), root_cross_signed.get()},
+                                /*crls=*/{}, /*flags=*/0, configure_callback));
+
+    // If |X509_V_FLAG_NO_ALT_CHAINS| is set and |trusted_first| is disabled, we
+    // get stuck on |root_cross_signed|. If either feature is enabled, we can
+    // build the path.
+    //
+    // This test exists to confirm our current behavior, but these modes are
+    // just workarounds for not having an actual path-building verifier. If we
+    // fix it, this test can be removed.
+    ASSERT_EQ(trusted_first ? X509_V_OK
+                            : X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
+              Verify(leaf.get(), {root.get()},
+                     {intermediate.get(), root_cross_signed.get()}, /*crls=*/{},
+                     /*flags=*/X509_V_FLAG_NO_ALT_CHAINS, configure_callback));
+
+    // |forgery| is signed by |leaf_no_key_usage|, but is rejected because the
+    // leaf is not a CA.
+    ASSERT_EQ(X509_V_ERR_INVALID_CA,
+              Verify(forgery.get(), {intermediate_self_signed.get()},
+                     {leaf_no_key_usage.get()}, /*crls=*/{}, /*flags=*/0,
+                     configure_callback));
+
+    // Test that one cannot skip Basic Constraints checking with a contorted set
+    // of roots and intermediates. This is a regression test for CVE-2015-1793.
+    ASSERT_EQ(X509_V_ERR_INVALID_CA,
+              Verify(forgery.get(),
+                     {intermediate_self_signed.get(), root_cross_signed.get()},
+                     {leaf_no_key_usage.get(), intermediate.get()}, /*crls=*/{},
+                     /*flags=*/0, configure_callback));
+  }
+}
 
 // static const char kHostname[] = "example.com";
 // static const char kWrongHostname[] = "example2.com";
@@ -1474,249 +1474,257 @@
 //   EXPECT_FALSE(CRLFromPEM(kBadExtensionCRL));
 // }
 
-// TEST(X509Test, ManyNamesAndConstraints) {
-//   bssl::UniquePtr<X509> many_constraints(CertFromPEM(
-//       GetTestData("crypto/x509/test/many_constraints.pem").c_str()));
-//   ASSERT_TRUE(many_constraints);
-//   bssl::UniquePtr<X509> many_names1(
-//       CertFromPEM(GetTestData("crypto/x509/test/many_names1.pem").c_str()));
-//   ASSERT_TRUE(many_names1);
-//   bssl::UniquePtr<X509> many_names2(
-//       CertFromPEM(GetTestData("crypto/x509/test/many_names2.pem").c_str()));
-//   ASSERT_TRUE(many_names2);
-//   bssl::UniquePtr<X509> many_names3(
-//       CertFromPEM(GetTestData("crypto/x509/test/many_names3.pem").c_str()));
-//   ASSERT_TRUE(many_names3);
-//   bssl::UniquePtr<X509> some_names1(
-//       CertFromPEM(GetTestData("crypto/x509/test/some_names1.pem").c_str()));
-//   ASSERT_TRUE(some_names1);
-//   bssl::UniquePtr<X509> some_names2(
-//       CertFromPEM(GetTestData("crypto/x509/test/some_names2.pem").c_str()));
-//   ASSERT_TRUE(some_names2);
-//   bssl::UniquePtr<X509> some_names3(
-//       CertFromPEM(GetTestData("crypto/x509/test/some_names3.pem").c_str()));
-//   ASSERT_TRUE(some_names3);
-
-//   EXPECT_EQ(X509_V_ERR_UNSPECIFIED,
-//             Verify(many_names1.get(), {many_constraints.get()},
-//                    {many_constraints.get()}, {}));
-//   EXPECT_EQ(X509_V_ERR_UNSPECIFIED,
-//             Verify(many_names2.get(), {many_constraints.get()},
-//                    {many_constraints.get()}, {}));
-//   EXPECT_EQ(X509_V_ERR_UNSPECIFIED,
-//             Verify(many_names3.get(), {many_constraints.get()},
-//                    {many_constraints.get()}, {}));
-
-//   EXPECT_EQ(X509_V_OK, Verify(some_names1.get(), {many_constraints.get()},
-//                               {many_constraints.get()}, {}));
-//   EXPECT_EQ(X509_V_OK, Verify(some_names2.get(), {many_constraints.get()},
-//                               {many_constraints.get()}, {}));
-//   EXPECT_EQ(X509_V_OK, Verify(some_names3.get(), {many_constraints.get()},
-//                               {many_constraints.get()}, {}));
-// }
-
-// static bssl::UniquePtr<GENERAL_NAME> MakeGeneralName(int type,
-//                                                      const std::string &value) {
-//   if (type != GEN_EMAIL && type != GEN_DNS && type != GEN_URI) {
-//     // This function only supports the IA5String types.
-//     return nullptr;
-//   }
-//   bssl::UniquePtr<ASN1_IA5STRING> str(ASN1_IA5STRING_new());
-//   bssl::UniquePtr<GENERAL_NAME> name(GENERAL_NAME_new());
-//   if (!str || !name ||
-//       !ASN1_STRING_set(str.get(), value.data(), value.size())) {
-//     return nullptr;
-//   }
-
-//   name->type = type;
-//   name->d.ia5 = str.release();
-//   return name;
-// }
-
-// static bssl::UniquePtr<X509> MakeTestCert(const char *issuer,
-//                                           const char *subject, EVP_PKEY *key,
-//                                           bool is_ca) {
-//   bssl::UniquePtr<X509> cert(X509_new());
-//   if (!cert ||  //
-//       !X509_set_version(cert.get(), X509_VERSION_3) ||
-//       !X509_NAME_add_entry_by_txt(
-//           X509_get_issuer_name(cert.get()), "CN", MBSTRING_UTF8,
-//           reinterpret_cast<const uint8_t *>(issuer), -1, -1, 0) ||
-//       !X509_NAME_add_entry_by_txt(
-//           X509_get_subject_name(cert.get()), "CN", MBSTRING_UTF8,
-//           reinterpret_cast<const uint8_t *>(subject), -1, -1, 0) ||
-//       !X509_set_pubkey(cert.get(), key) ||
-//       !ASN1_TIME_adj(X509_getm_notBefore(cert.get()), kReferenceTime, -1, 0) ||
-//       !ASN1_TIME_adj(X509_getm_notAfter(cert.get()), kReferenceTime, 1, 0)) {
-//     return nullptr;
-//   }
-//   bssl::UniquePtr<BASIC_CONSTRAINTS> bc(BASIC_CONSTRAINTS_new());
-//   if (!bc) {
-//     return nullptr;
-//   }
-//   bc->ca = is_ca ? 0xff : 0x00;
-//   if (!X509_add1_ext_i2d(cert.get(), NID_basic_constraints, bc.get(),
-//                          /*crit=*/1, /*flags=*/0)) {
-//     return nullptr;
-//   }
-//   return cert;
-// }
-
-// TEST(X509Test, NameConstraints) {
-//   bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
-//   ASSERT_TRUE(key);
-
-//   const struct {
-//     int type;
-//     std::string name;
-//     std::string constraint;
-//     int result;
-//   } kTests[] = {
-//       // Empty string matches everything.
-//       {GEN_DNS, "foo.example.com", "", X509_V_OK},
-//       // Name constraints match the entire subtree.
-//       {GEN_DNS, "foo.example.com", "example.com", X509_V_OK},
-//       {GEN_DNS, "foo.example.com", "EXAMPLE.COM", X509_V_OK},
-//       {GEN_DNS, "foo.example.com", "xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_DNS, "foo.example.com", "unrelated.much.longer.name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       // A leading dot means at least one component must be added.
-//       {GEN_DNS, "foo.example.com", ".example.com", X509_V_OK},
-//       {GEN_DNS, "foo.example.com", "foo.example.com", X509_V_OK},
-//       {GEN_DNS, "foo.example.com", ".foo.example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_DNS, "foo.example.com", ".xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_DNS, "foo.example.com", ".unrelated.much.longer.name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       // NUL bytes, if not rejected, should not confuse the matching logic.
-//       {GEN_DNS, std::string({'a', '\0', 'a'}), std::string({'a', '\0', 'b'}),
-//        X509_V_ERR_PERMITTED_VIOLATION},
-
-//       // Names must be emails.
-//       {GEN_EMAIL, "not-an-email.example", "not-an-email.example",
-//        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       // A leading dot matches all local names and all subdomains
-//       {GEN_EMAIL, "foo@bar.example.com", ".example.com", X509_V_OK},
-//       {GEN_EMAIL, "foo@bar.example.com", ".EXAMPLE.COM", X509_V_OK},
-//       {GEN_EMAIL, "foo@bar.example.com", ".bar.example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       // Without a leading dot, the host must match exactly.
-//       {GEN_EMAIL, "foo@example.com", "example.com", X509_V_OK},
-//       {GEN_EMAIL, "foo@example.com", "EXAMPLE.COM", X509_V_OK},
-//       {GEN_EMAIL, "foo@bar.example.com", "example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       // If the constraint specifies a mailbox, it specifies the whole thing.
-//       // The halves are compared insensitively.
-//       {GEN_EMAIL, "foo@example.com", "foo@example.com", X509_V_OK},
-//       {GEN_EMAIL, "foo@example.com", "foo@EXAMPLE.COM", X509_V_OK},
-//       {GEN_EMAIL, "foo@example.com", "FOO@example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_EMAIL, "foo@example.com", "bar@example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       // OpenSSL ignores a stray leading @.
-//       {GEN_EMAIL, "foo@example.com", "@example.com", X509_V_OK},
-//       {GEN_EMAIL, "foo@example.com", "@EXAMPLE.COM", X509_V_OK},
-//       {GEN_EMAIL, "foo@bar.example.com", "@example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-
-//       // Basic syntax check.
-//       {GEN_URI, "not-a-url", "not-a-url", X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       {GEN_URI, "foo:not-a-url", "not-a-url",
-//        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       {GEN_URI, "foo:/not-a-url", "not-a-url",
-//        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       {GEN_URI, "foo:///not-a-url", "not-a-url",
-//        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       {GEN_URI, "foo://:not-a-url", "not-a-url",
-//        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       {GEN_URI, "foo://", "not-a-url", X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
-//       // Hosts are an exact match.
-//       {GEN_URI, "foo://example.com", "example.com", X509_V_OK},
-//       {GEN_URI, "foo://example.com:443", "example.com", X509_V_OK},
-//       {GEN_URI, "foo://example.com/whatever", "example.com", X509_V_OK},
-//       {GEN_URI, "foo://bar.example.com", "example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://bar.example.com:443", "example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://bar.example.com/whatever", "example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://bar.example.com", "xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://bar.example.com:443", "xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://bar.example.com/whatever", "xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com", "some-other-name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com:443", "some-other-name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com/whatever", "some-other-name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       // A leading dot allows components to be added.
-//       {GEN_URI, "foo://example.com", ".example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com:443", ".example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com/whatever", ".example.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://bar.example.com", ".example.com", X509_V_OK},
-//       {GEN_URI, "foo://bar.example.com:443", ".example.com", X509_V_OK},
-//       {GEN_URI, "foo://bar.example.com/whatever", ".example.com", X509_V_OK},
-//       {GEN_URI, "foo://example.com", ".some-other-name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com:443", ".some-other-name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com/whatever", ".some-other-name.example",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com", ".xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com:443", ".xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//       {GEN_URI, "foo://example.com/whatever", ".xample.com",
-//        X509_V_ERR_PERMITTED_VIOLATION},
-//   };
-//   for (const auto &t : kTests) {
-//     SCOPED_TRACE(t.type);
-//     SCOPED_TRACE(t.name);
-//     SCOPED_TRACE(t.constraint);
-
-//     bssl::UniquePtr<GENERAL_NAME> name = MakeGeneralName(t.type, t.name);
-//     ASSERT_TRUE(name);
-//     bssl::UniquePtr<GENERAL_NAMES> names(GENERAL_NAMES_new());
-//     ASSERT_TRUE(names);
-//     ASSERT_TRUE(bssl::PushToStack(names.get(), std::move(name)));
-
-//     bssl::UniquePtr<NAME_CONSTRAINTS> nc(NAME_CONSTRAINTS_new());
-//     ASSERT_TRUE(nc);
-//     nc->permittedSubtrees = sk_GENERAL_SUBTREE_new_null();
-//     ASSERT_TRUE(nc->permittedSubtrees);
-//     bssl::UniquePtr<GENERAL_SUBTREE> subtree(GENERAL_SUBTREE_new());
-//     ASSERT_TRUE(subtree);
-//     GENERAL_NAME_free(subtree->base);
-//     subtree->base = MakeGeneralName(t.type, t.constraint).release();
-//     ASSERT_TRUE(subtree->base);
-//     ASSERT_TRUE(bssl::PushToStack(nc->permittedSubtrees, std::move(subtree)));
-
-//     bssl::UniquePtr<X509> root =
-//         MakeTestCert("Root", "Root", key.get(), /*is_ca=*/true);
-//     ASSERT_TRUE(root);
-//     ASSERT_TRUE(X509_add1_ext_i2d(root.get(), NID_name_constraints, nc.get(),
-//                                   /*crit=*/1, /*flags=*/0));
-//     ASSERT_TRUE(X509_sign(root.get(), key.get(), EVP_sha256()));
-
-//     bssl::UniquePtr<X509> leaf =
-//         MakeTestCert("Root", "Leaf", key.get(), /*is_ca=*/false);
-//     ASSERT_TRUE(leaf);
-//     ASSERT_TRUE(X509_add1_ext_i2d(leaf.get(), NID_subject_alt_name, names.get(),
-//                                   /*crit=*/0, /*flags=*/0));
-//     ASSERT_TRUE(X509_sign(leaf.get(), key.get(), EVP_sha256()));
-
-//     int ret = Verify(leaf.get(), {root.get()}, {}, {}, 0);
-//     EXPECT_EQ(t.result, ret) << X509_verify_cert_error_string(ret);
-//   }
-// }
+TEST(X509Test, ManyNamesAndConstraints) {
+  bssl::UniquePtr<X509> many_constraints(CertFromPEM(
+      GetTestData("crypto/x509/test/many_constraints.pem").c_str()));
+  ASSERT_TRUE(many_constraints);
+  bssl::UniquePtr<X509> many_names1(
+      CertFromPEM(GetTestData("crypto/x509/test/many_names1.pem").c_str()));
+  ASSERT_TRUE(many_names1);
+  bssl::UniquePtr<X509> many_names2(
+      CertFromPEM(GetTestData("crypto/x509/test/many_names2.pem").c_str()));
+  ASSERT_TRUE(many_names2);
+  bssl::UniquePtr<X509> many_names3(
+      CertFromPEM(GetTestData("crypto/x509/test/many_names3.pem").c_str()));
+  ASSERT_TRUE(many_names3);
+  bssl::UniquePtr<X509> some_names1(
+      CertFromPEM(GetTestData("crypto/x509/test/some_names1.pem").c_str()));
+  ASSERT_TRUE(some_names1);
+  bssl::UniquePtr<X509> some_names2(
+      CertFromPEM(GetTestData("crypto/x509/test/some_names2.pem").c_str()));
+  ASSERT_TRUE(some_names2);
+  bssl::UniquePtr<X509> some_names3(
+      CertFromPEM(GetTestData("crypto/x509/test/some_names3.pem").c_str()));
+  ASSERT_TRUE(some_names3);
+
+  EXPECT_EQ(X509_V_ERR_UNSPECIFIED,
+            Verify(many_names1.get(), {many_constraints.get()},
+                   {many_constraints.get()}, {}));
+  EXPECT_EQ(X509_V_ERR_UNSPECIFIED,
+            Verify(many_names2.get(), {many_constraints.get()},
+                   {many_constraints.get()}, {}));
+  EXPECT_EQ(X509_V_ERR_UNSPECIFIED,
+            Verify(many_names3.get(), {many_constraints.get()},
+                   {many_constraints.get()}, {}));
+
+  EXPECT_EQ(X509_V_OK, Verify(some_names1.get(), {many_constraints.get()},
+                              {many_constraints.get()}, {}));
+  EXPECT_EQ(X509_V_OK, Verify(some_names2.get(), {many_constraints.get()},
+                              {many_constraints.get()}, {}));
+  EXPECT_EQ(X509_V_OK, Verify(some_names3.get(), {many_constraints.get()},
+                              {many_constraints.get()}, {}));
+}
+
+bssl::UniquePtr<GENERAL_NAME> MakeGeneralName(int type,
+                                                     const std::string &value) {
+  if (type != GEN_EMAIL && type != GEN_DNS && type != GEN_URI) {
+    // This function only supports the IA5String types.
+    return nullptr;
+  }
+  bssl::UniquePtr<ASN1_IA5STRING> str(ASN1_IA5STRING_new());
+  bssl::UniquePtr<GENERAL_NAME> name(GENERAL_NAME_new());
+  if (!str || !name ||
+      !ASN1_STRING_set(str.get(), value.data(), value.size())) {
+    return nullptr;
+  }
+
+  name->type = type;
+  name->d.ia5 = str.release();
+  return name;
+}
+
+static bssl::UniquePtr<X509> MakeTestCert(const char *issuer,
+                                          const char *subject, EVP_PKEY *key,
+                                          bool is_ca) {
+  bssl::UniquePtr<X509> cert(X509_new());
+  if (!cert ||  //
+      !X509_set_version(cert.get(), X509_VERSION_3) ||
+      !X509_NAME_add_entry_by_txt(
+          X509_get_issuer_name(cert.get()), "CN", MBSTRING_UTF8,
+          reinterpret_cast<const uint8_t *>(issuer), -1, -1, 0) ||
+      !X509_NAME_add_entry_by_txt(
+          X509_get_subject_name(cert.get()), "CN", MBSTRING_UTF8,
+          reinterpret_cast<const uint8_t *>(subject), -1, -1, 0) ||
+      !X509_set_pubkey(cert.get(), key) ||
+      !ASN1_TIME_adj(X509_getm_notBefore(cert.get()), kReferenceTime, -1, 0) ||
+      !ASN1_TIME_adj(X509_getm_notAfter(cert.get()), kReferenceTime, 1, 0)) {
+    return nullptr;
+  }
+  bssl::UniquePtr<BASIC_CONSTRAINTS> bc(BASIC_CONSTRAINTS_new());
+  if (!bc) {
+    return nullptr;
+  }
+  bc->ca = is_ca ? 0xff : 0x00;
+  if (!X509_add1_ext_i2d(cert.get(), NID_basic_constraints, bc.get(),
+                         /*crit=*/1, /*flags=*/0)) {
+    return nullptr;
+  }
+  return cert;
+}
+
+TEST(X509Test, NameConstraints) {
+  bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
+  ASSERT_TRUE(key);
+
+  const struct {
+    int type;
+    std::string name;
+    std::string constraint;
+    int result;
+  } kTests[] = {
+      // Empty string matches everything.
+      {GEN_DNS, "foo.example.com", "", X509_V_OK},
+      // Name constraints match the entire subtree.
+      {GEN_DNS, "foo.example.com", "example.com", X509_V_OK},
+      {GEN_DNS, "foo.example.com", "EXAMPLE.COM", X509_V_OK},
+      {GEN_DNS, "foo.example.com", "xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_DNS, "foo.example.com", "unrelated.much.longer.name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      // A leading dot means at least one component must be added.
+      {GEN_DNS, "foo.example.com", ".example.com", X509_V_OK},
+      {GEN_DNS, "foo.example.com", "foo.example.com", X509_V_OK},
+      {GEN_DNS, "foo.example.com", ".foo.example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_DNS, "foo.example.com", ".xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_DNS, "foo.example.com", ".unrelated.much.longer.name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      // NUL bytes, if not rejected, should not confuse the matching logic.
+      {GEN_DNS, std::string({'a', '\0', 'a'}), std::string({'a', '\0', 'b'}),
+       X509_V_ERR_PERMITTED_VIOLATION},
+
+      // Names must be emails.
+      {GEN_EMAIL, "not-an-email.example", "not-an-email.example",
+       X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      // A leading dot matches all local names and all subdomains
+      {GEN_EMAIL, "foo@bar.example.com", ".example.com", X509_V_OK},
+      {GEN_EMAIL, "foo@bar.example.com", ".EXAMPLE.COM", X509_V_OK},
+      {GEN_EMAIL, "foo@bar.example.com", ".bar.example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      // Without a leading dot, the host must match exactly.
+      {GEN_EMAIL, "foo@example.com", "example.com", X509_V_OK},
+      {GEN_EMAIL, "foo@example.com", "EXAMPLE.COM", X509_V_OK},
+      {GEN_EMAIL, "foo@bar.example.com", "example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      // If the constraint specifies a mailbox, it specifies the whole thing.
+      // The halves are compared insensitively.
+      {GEN_EMAIL, "foo@example.com", "foo@example.com", X509_V_OK},
+      {GEN_EMAIL, "foo@example.com", "foo@EXAMPLE.COM", X509_V_OK},
+      {GEN_EMAIL, "foo@example.com", "FOO@example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_EMAIL, "foo@example.com", "bar@example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      // OpenSSL ignores a stray leading @.
+      {GEN_EMAIL, "foo@example.com", "@example.com", X509_V_OK},
+      {GEN_EMAIL, "foo@example.com", "@EXAMPLE.COM", X509_V_OK},
+      {GEN_EMAIL, "foo@bar.example.com", "@example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+
+      // Basic syntax check.
+      {GEN_URI, "not-a-url", "not-a-url", X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      {GEN_URI, "foo:not-a-url", "not-a-url",
+       X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      {GEN_URI, "foo:/not-a-url", "not-a-url",
+       X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      {GEN_URI, "foo:///not-a-url", "not-a-url",
+       X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      {GEN_URI, "foo://:not-a-url", "not-a-url",
+       X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      {GEN_URI, "foo://", "not-a-url", X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+      // Hosts are an exact match.
+      {GEN_URI, "foo://example.com", "example.com", X509_V_OK},
+      {GEN_URI, "foo://example.com:443", "example.com", X509_V_OK},
+      {GEN_URI, "foo://example.com/whatever", "example.com", X509_V_OK},
+      {GEN_URI, "foo://bar.example.com", "example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://bar.example.com:443", "example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://bar.example.com/whatever", "example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://bar.example.com", "xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://bar.example.com:443", "xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://bar.example.com/whatever", "xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com", "some-other-name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com:443", "some-other-name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com/whatever", "some-other-name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      // A leading dot allows components to be added.
+      {GEN_URI, "foo://example.com", ".example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com:443", ".example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com/whatever", ".example.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://bar.example.com", ".example.com", X509_V_OK},
+      {GEN_URI, "foo://bar.example.com:443", ".example.com", X509_V_OK},
+      {GEN_URI, "foo://bar.example.com/whatever", ".example.com", X509_V_OK},
+      {GEN_URI, "foo://example.com", ".some-other-name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com:443", ".some-other-name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com/whatever", ".some-other-name.example",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com", ".xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com:443", ".xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+      {GEN_URI, "foo://example.com/whatever", ".xample.com",
+       X509_V_ERR_PERMITTED_VIOLATION},
+  };
+  for (const auto &t : kTests) {
+    SCOPED_TRACE(t.type);
+    SCOPED_TRACE(t.name);
+    SCOPED_TRACE(t.constraint);
+
+    bssl::UniquePtr<GENERAL_NAME> name = MakeGeneralName(t.type, t.name);
+    ASSERT_TRUE(name);
+    bssl::UniquePtr<GENERAL_NAMES> names(GENERAL_NAMES_new());
+    ASSERT_TRUE(names);
+    ASSERT_TRUE(bssl::PushToStack(names.get(), std::move(name)));
+
+    bssl::UniquePtr<NAME_CONSTRAINTS> nc(NAME_CONSTRAINTS_new());
+    ASSERT_TRUE(nc);
+#ifdef BSSL_COMPAT // FIXME: See StackTest.test4
+    nc->permittedSubtrees = reinterpret_cast<ossl_STACK_OF(ossl_GENERAL_SUBTREE)*>(sk_GENERAL_SUBTREE_new_null());
+#else
+    nc->permittedSubtrees = sk_GENERAL_SUBTREE_new_null();
+#endif
+    ASSERT_TRUE(nc->permittedSubtrees);
+    bssl::UniquePtr<GENERAL_SUBTREE> subtree(GENERAL_SUBTREE_new());
+    ASSERT_TRUE(subtree);
+    GENERAL_NAME_free(subtree->base);
+    subtree->base = MakeGeneralName(t.type, t.constraint).release();
+    ASSERT_TRUE(subtree->base);
+#ifdef BSSL_COMPAT // FIXME: 
+    ASSERT_TRUE(bssl::PushToStack(reinterpret_cast<STACK_OF(GENERAL_SUBTREE)*>(nc->permittedSubtrees), std::move(subtree)));
+#else
+    ASSERT_TRUE(bssl::PushToStack(nc->permittedSubtrees, std::move(subtree)));
+#endif
+
+    bssl::UniquePtr<X509> root =
+        MakeTestCert("Root", "Root", key.get(), /*is_ca=*/true);
+    ASSERT_TRUE(root);
+    ASSERT_TRUE(X509_add1_ext_i2d(root.get(), NID_name_constraints, nc.get(),
+                                  /*crit=*/1, /*flags=*/0));
+    ASSERT_TRUE(X509_sign(root.get(), key.get(), EVP_sha256()));
+
+    bssl::UniquePtr<X509> leaf =
+        MakeTestCert("Root", "Leaf", key.get(), /*is_ca=*/false);
+    ASSERT_TRUE(leaf);
+    ASSERT_TRUE(X509_add1_ext_i2d(leaf.get(), NID_subject_alt_name, names.get(),
+                                  /*crit=*/0, /*flags=*/0));
+    ASSERT_TRUE(X509_sign(leaf.get(), key.get(), EVP_sha256()));
+
+    int ret = Verify(leaf.get(), {root.get()}, {}, {}, 0);
+    EXPECT_EQ(t.result, ret) << X509_verify_cert_error_string(ret);
+  }
+}
 
 // TEST(X509Test, PrintGeneralName) {
 //   // TODO(https://crbug.com/boringssl/430): Add more tests. Also fix the
@@ -1732,36 +1740,36 @@
 //   EXPECT_STREQ(value->value, "example.com");
 // }
 
-// TEST(X509Test, TestPSS) {
-//   bssl::UniquePtr<X509> cert(CertFromPEM(kExamplePSSCert));
-//   ASSERT_TRUE(cert);
+TEST(X509Test, TestPSS) {
+  bssl::UniquePtr<X509> cert(CertFromPEM(kExamplePSSCert));
+  ASSERT_TRUE(cert);
 
-//   bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
-//   ASSERT_TRUE(pkey);
+  bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
+  ASSERT_TRUE(pkey);
 
-//   ASSERT_TRUE(X509_verify(cert.get(), pkey.get()));
-// }
+  ASSERT_TRUE(X509_verify(cert.get(), pkey.get()));
+}
 
-// TEST(X509Test, TestPSSBadParameters) {
-//   bssl::UniquePtr<X509> cert(CertFromPEM(kBadPSSCertPEM));
-//   ASSERT_TRUE(cert);
+TEST(X509Test, TestPSSBadParameters) {
+  bssl::UniquePtr<X509> cert(CertFromPEM(kBadPSSCertPEM));
+  ASSERT_TRUE(cert);
 
-//   bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
-//   ASSERT_TRUE(pkey);
+  bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
+  ASSERT_TRUE(pkey);
 
-//   ASSERT_FALSE(X509_verify(cert.get(), pkey.get()));
-//   ERR_clear_error();
-// }
+  ASSERT_FALSE(X509_verify(cert.get(), pkey.get()));
+  ERR_clear_error();
+}
 
-// TEST(X509Test, TestEd25519) {
-//   bssl::UniquePtr<X509> cert(CertFromPEM(kEd25519Cert));
-//   ASSERT_TRUE(cert);
+TEST(X509Test, TestEd25519) {
+  bssl::UniquePtr<X509> cert(CertFromPEM(kEd25519Cert));
+  ASSERT_TRUE(cert);
 
-//   bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
-//   ASSERT_TRUE(pkey);
+  bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
+  ASSERT_TRUE(pkey);
 
-//   ASSERT_TRUE(X509_verify(cert.get(), pkey.get()));
-// }
+  ASSERT_TRUE(X509_verify(cert.get(), pkey.get()));
+}
 
 // TEST(X509Test, TestEd25519BadParameters) {
 //   bssl::UniquePtr<X509> cert(CertFromPEM(kEd25519CertNull));
@@ -2204,61 +2212,61 @@
 //   }
 // }
 
-// TEST(X509Test, X509NameSet) {
-//   bssl::UniquePtr<X509_NAME> name(X509_NAME_new());
-//   EXPECT_TRUE(X509_NAME_add_entry_by_txt(
-//       name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("US"),
-//       -1, -1, 0));
-//   EXPECT_EQ(X509_NAME_entry_count(name.get()), 1);
-//   EXPECT_TRUE(X509_NAME_add_entry_by_txt(
-//       name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("CA"),
-//       -1, -1, 0));
-//   EXPECT_EQ(X509_NAME_entry_count(name.get()), 2);
-//   EXPECT_TRUE(X509_NAME_add_entry_by_txt(
-//       name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("UK"),
-//       -1, -1, 0));
-//   EXPECT_EQ(X509_NAME_entry_count(name.get()), 3);
-//   EXPECT_TRUE(X509_NAME_add_entry_by_txt(
-//       name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("JP"),
-//       -1, 1, 0));
-//   EXPECT_EQ(X509_NAME_entry_count(name.get()), 4);
-
-//   // Check that the correct entries get incremented when inserting new entry.
-//   EXPECT_EQ(X509_NAME_ENTRY_set(X509_NAME_get_entry(name.get(), 1)), 1);
-//   EXPECT_EQ(X509_NAME_ENTRY_set(X509_NAME_get_entry(name.get(), 2)), 2);
-// }
-
-// TEST(X509Test, NoBasicConstraintsCertSign) {
-//   bssl::UniquePtr<X509> root(CertFromPEM(kSANTypesRoot));
-//   bssl::UniquePtr<X509> intermediate(
-//       CertFromPEM(kNoBasicConstraintsCertSignIntermediate));
-//   bssl::UniquePtr<X509> leaf(CertFromPEM(kNoBasicConstraintsCertSignLeaf));
-
-//   ASSERT_TRUE(root);
-//   ASSERT_TRUE(intermediate);
-//   ASSERT_TRUE(leaf);
-
-//   // The intermediate has keyUsage certSign, but is not marked as a CA in the
-//   // basicConstraints.
-//   EXPECT_EQ(X509_V_ERR_INVALID_CA,
-//             Verify(leaf.get(), {root.get()}, {intermediate.get()}, {}, 0));
-// }
-
-// TEST(X509Test, NoBasicConstraintsNetscapeCA) {
-//   bssl::UniquePtr<X509> root(CertFromPEM(kSANTypesRoot));
-//   bssl::UniquePtr<X509> intermediate(
-//       CertFromPEM(kNoBasicConstraintsNetscapeCAIntermediate));
-//   bssl::UniquePtr<X509> leaf(CertFromPEM(kNoBasicConstraintsNetscapeCALeaf));
-
-//   ASSERT_TRUE(root);
-//   ASSERT_TRUE(intermediate);
-//   ASSERT_TRUE(leaf);
-
-//   // The intermediate has a Netscape certificate type of "SSL CA", but is not
-//   // marked as a CA in the basicConstraints.
-//   EXPECT_EQ(X509_V_ERR_INVALID_CA,
-//             Verify(leaf.get(), {root.get()}, {intermediate.get()}, {}, 0));
-// }
+TEST(X509Test, X509NameSet) {
+  bssl::UniquePtr<X509_NAME> name(X509_NAME_new());
+  EXPECT_TRUE(X509_NAME_add_entry_by_txt(
+      name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("US"),
+      -1, -1, 0));
+  EXPECT_EQ(X509_NAME_entry_count(name.get()), 1);
+  EXPECT_TRUE(X509_NAME_add_entry_by_txt(
+      name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("CA"),
+      -1, -1, 0));
+  EXPECT_EQ(X509_NAME_entry_count(name.get()), 2);
+  EXPECT_TRUE(X509_NAME_add_entry_by_txt(
+      name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("UK"),
+      -1, -1, 0));
+  EXPECT_EQ(X509_NAME_entry_count(name.get()), 3);
+  EXPECT_TRUE(X509_NAME_add_entry_by_txt(
+      name.get(), "C", MBSTRING_ASC, reinterpret_cast<const uint8_t *>("JP"),
+      -1, 1, 0));
+  EXPECT_EQ(X509_NAME_entry_count(name.get()), 4);
+
+  // Check that the correct entries get incremented when inserting new entry.
+  EXPECT_EQ(X509_NAME_ENTRY_set(X509_NAME_get_entry(name.get(), 1)), 1);
+  EXPECT_EQ(X509_NAME_ENTRY_set(X509_NAME_get_entry(name.get(), 2)), 2);
+}
+
+TEST(X509Test, NoBasicConstraintsCertSign) {
+  bssl::UniquePtr<X509> root(CertFromPEM(kSANTypesRoot));
+  bssl::UniquePtr<X509> intermediate(
+      CertFromPEM(kNoBasicConstraintsCertSignIntermediate));
+  bssl::UniquePtr<X509> leaf(CertFromPEM(kNoBasicConstraintsCertSignLeaf));
+
+  ASSERT_TRUE(root);
+  ASSERT_TRUE(intermediate);
+  ASSERT_TRUE(leaf);
+
+  // The intermediate has keyUsage certSign, but is not marked as a CA in the
+  // basicConstraints.
+  EXPECT_EQ(X509_V_ERR_INVALID_CA,
+            Verify(leaf.get(), {root.get()}, {intermediate.get()}, {}, 0));
+}
+
+TEST(X509Test, NoBasicConstraintsNetscapeCA) {
+  bssl::UniquePtr<X509> root(CertFromPEM(kSANTypesRoot));
+  bssl::UniquePtr<X509> intermediate(
+      CertFromPEM(kNoBasicConstraintsNetscapeCAIntermediate));
+  bssl::UniquePtr<X509> leaf(CertFromPEM(kNoBasicConstraintsNetscapeCALeaf));
+
+  ASSERT_TRUE(root);
+  ASSERT_TRUE(intermediate);
+  ASSERT_TRUE(leaf);
+
+  // The intermediate has a Netscape certificate type of "SSL CA", but is not
+  // marked as a CA in the basicConstraints.
+  EXPECT_EQ(X509_V_ERR_INVALID_CA,
+            Verify(leaf.get(), {root.get()}, {intermediate.get()}, {}, 0));
+}
 
 // TEST(X509Test, MismatchAlgorithms) {
 //   bssl::UniquePtr<X509> cert(CertFromPEM(kSelfSignedMismatchAlgorithms));
@@ -2273,127 +2281,127 @@
 //   EXPECT_EQ(X509_R_SIGNATURE_ALGORITHM_MISMATCH, ERR_GET_REASON(err));
 // }
 
-// TEST(X509Test, PEMX509Info) {
-//   std::string cert = kRootCAPEM;
-//   auto cert_obj = CertFromPEM(kRootCAPEM);
-//   ASSERT_TRUE(cert_obj);
-
-//   std::string rsa = kRSAKey;
-//   auto rsa_obj = PrivateKeyFromPEM(kRSAKey);
-//   ASSERT_TRUE(rsa_obj);
-
-//   std::string crl = kBasicCRL;
-//   auto crl_obj = CRLFromPEM(kBasicCRL);
-//   ASSERT_TRUE(crl_obj);
-
-//   std::string unknown =
-//       "-----BEGIN UNKNOWN-----\n"
-//       "AAAA\n"
-//       "-----END UNKNOWN-----\n";
-
-//   std::string invalid =
-//       "-----BEGIN CERTIFICATE-----\n"
-//       "AAAA\n"
-//       "-----END CERTIFICATE-----\n";
-
-//   // Each X509_INFO contains at most one certificate, CRL, etc. The format
-//   // creates a new X509_INFO when a repeated type is seen.
-//   std::string pem =
-//       // The first few entries have one of everything in different orders.
-//       cert + rsa + crl +
-//       rsa + crl + cert +
-//       // Unknown types are ignored.
-//       crl + unknown + cert + rsa +
-//       // Seeing a new certificate starts a new entry, so now we have a bunch of
-//       // certificate-only entries.
-//       cert + cert + cert +
-//       // The key folds into the certificate's entry.
-//       cert + rsa +
-//       // Doubled keys also start new entries.
-//       rsa + rsa + rsa + rsa + crl +
-//       // As do CRLs.
-//       crl + crl;
-
-//   const struct ExpectedInfo {
-//     const X509 *cert;
-//     const EVP_PKEY *key;
-//     const X509_CRL *crl;
-//   } kExpected[] = {
-//     {cert_obj.get(), rsa_obj.get(), crl_obj.get()},
-//     {cert_obj.get(), rsa_obj.get(), crl_obj.get()},
-//     {cert_obj.get(), rsa_obj.get(), crl_obj.get()},
-//     {cert_obj.get(), nullptr, nullptr},
-//     {cert_obj.get(), nullptr, nullptr},
-//     {cert_obj.get(), nullptr, nullptr},
-//     {cert_obj.get(), rsa_obj.get(), nullptr},
-//     {nullptr, rsa_obj.get(), nullptr},
-//     {nullptr, rsa_obj.get(), nullptr},
-//     {nullptr, rsa_obj.get(), nullptr},
-//     {nullptr, rsa_obj.get(), crl_obj.get()},
-//     {nullptr, nullptr, crl_obj.get()},
-//     {nullptr, nullptr, crl_obj.get()},
-//   };
-
-//   auto check_info = [](const ExpectedInfo *expected, const X509_INFO *info) {
-//     if (expected->cert != nullptr) {
-//       EXPECT_EQ(0, X509_cmp(expected->cert, info->x509));
-//     } else {
-//       EXPECT_EQ(nullptr, info->x509);
-//     }
-//     if (expected->crl != nullptr) {
-//       EXPECT_EQ(0, X509_CRL_cmp(expected->crl, info->crl));
-//     } else {
-//       EXPECT_EQ(nullptr, info->crl);
-//     }
-//     if (expected->key != nullptr) {
-//       ASSERT_NE(nullptr, info->x_pkey);
-//       // EVP_PKEY_cmp returns one if the keys are equal.
-//       EXPECT_EQ(1, EVP_PKEY_cmp(expected->key, info->x_pkey->dec_pkey));
-//     } else {
-//       EXPECT_EQ(nullptr, info->x_pkey);
-//     }
-//   };
-
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem.data(), pem.size()));
-//   ASSERT_TRUE(bio);
-//   bssl::UniquePtr<STACK_OF(X509_INFO)> infos(
-//       PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));
-//   ASSERT_TRUE(infos);
-//   ASSERT_EQ(OPENSSL_ARRAY_SIZE(kExpected), sk_X509_INFO_num(infos.get()));
-//   for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kExpected); i++) {
-//     SCOPED_TRACE(i);
-//     check_info(&kExpected[i], sk_X509_INFO_value(infos.get(), i));
-//   }
-
-//   // Passing an existing stack appends to it.
-//   bio.reset(BIO_new_mem_buf(pem.data(), pem.size()));
-//   ASSERT_TRUE(bio);
-//   ASSERT_EQ(infos.get(),
-//             PEM_X509_INFO_read_bio(bio.get(), infos.get(), nullptr, nullptr));
-//   ASSERT_EQ(2 * OPENSSL_ARRAY_SIZE(kExpected), sk_X509_INFO_num(infos.get()));
-//   for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kExpected); i++) {
-//     SCOPED_TRACE(i);
-//     check_info(&kExpected[i], sk_X509_INFO_value(infos.get(), i));
-//     check_info(
-//         &kExpected[i],
-//         sk_X509_INFO_value(infos.get(), i + OPENSSL_ARRAY_SIZE(kExpected)));
-//   }
-
-//   // Gracefully handle errors in both the append and fresh cases.
-//   std::string bad_pem = cert + cert + invalid;
-
-//   bio.reset(BIO_new_mem_buf(bad_pem.data(), bad_pem.size()));
-//   ASSERT_TRUE(bio);
-//   bssl::UniquePtr<STACK_OF(X509_INFO)> infos2(
-//       PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));
-//   EXPECT_FALSE(infos2);
-
-//   bio.reset(BIO_new_mem_buf(bad_pem.data(), bad_pem.size()));
-//   ASSERT_TRUE(bio);
-//   EXPECT_FALSE(
-//       PEM_X509_INFO_read_bio(bio.get(), infos.get(), nullptr, nullptr));
-//   EXPECT_EQ(2 * OPENSSL_ARRAY_SIZE(kExpected), sk_X509_INFO_num(infos.get()));
-// }
+TEST(X509Test, PEMX509Info) {
+  std::string cert = kRootCAPEM;
+  auto cert_obj = CertFromPEM(kRootCAPEM);
+  ASSERT_TRUE(cert_obj);
+
+  std::string rsa = kRSAKey;
+  auto rsa_obj = PrivateKeyFromPEM(kRSAKey);
+  ASSERT_TRUE(rsa_obj);
+
+  std::string crl = kBasicCRL;
+  auto crl_obj = CRLFromPEM(kBasicCRL);
+  ASSERT_TRUE(crl_obj);
+
+  std::string unknown =
+      "-----BEGIN UNKNOWN-----\n"
+      "AAAA\n"
+      "-----END UNKNOWN-----\n";
+
+  std::string invalid =
+      "-----BEGIN CERTIFICATE-----\n"
+      "AAAA\n"
+      "-----END CERTIFICATE-----\n";
+
+  // Each X509_INFO contains at most one certificate, CRL, etc. The format
+  // creates a new X509_INFO when a repeated type is seen.
+  std::string pem =
+      // The first few entries have one of everything in different orders.
+      cert + rsa + crl +
+      rsa + crl + cert +
+      // Unknown types are ignored.
+      crl + unknown + cert + rsa +
+      // Seeing a new certificate starts a new entry, so now we have a bunch of
+      // certificate-only entries.
+      cert + cert + cert +
+      // The key folds into the certificate's entry.
+      cert + rsa +
+      // Doubled keys also start new entries.
+      rsa + rsa + rsa + rsa + crl +
+      // As do CRLs.
+      crl + crl;
+
+  const struct ExpectedInfo {
+    const X509 *cert;
+    const EVP_PKEY *key;
+    const X509_CRL *crl;
+  } kExpected[] = {
+    {cert_obj.get(), rsa_obj.get(), crl_obj.get()},
+    {cert_obj.get(), rsa_obj.get(), crl_obj.get()},
+    {cert_obj.get(), rsa_obj.get(), crl_obj.get()},
+    {cert_obj.get(), nullptr, nullptr},
+    {cert_obj.get(), nullptr, nullptr},
+    {cert_obj.get(), nullptr, nullptr},
+    {cert_obj.get(), rsa_obj.get(), nullptr},
+    {nullptr, rsa_obj.get(), nullptr},
+    {nullptr, rsa_obj.get(), nullptr},
+    {nullptr, rsa_obj.get(), nullptr},
+    {nullptr, rsa_obj.get(), crl_obj.get()},
+    {nullptr, nullptr, crl_obj.get()},
+    {nullptr, nullptr, crl_obj.get()},
+  };
+
+  auto check_info = [](const ExpectedInfo *expected, const X509_INFO *info) {
+    if (expected->cert != nullptr) {
+      EXPECT_EQ(0, X509_cmp(expected->cert, info->x509));
+    } else {
+      EXPECT_EQ(nullptr, info->x509);
+    }
+    if (expected->crl != nullptr) {
+      EXPECT_EQ(0, X509_CRL_cmp(expected->crl, info->crl));
+    } else {
+      EXPECT_EQ(nullptr, info->crl);
+    }
+    if (expected->key != nullptr) {
+      ASSERT_NE(nullptr, info->x_pkey);
+      // EVP_PKEY_cmp returns one if the keys are equal.
+      EXPECT_EQ(1, EVP_PKEY_cmp(expected->key, info->x_pkey->dec_pkey));
+    } else {
+      EXPECT_EQ(nullptr, info->x_pkey);
+    }
+  };
+
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem.data(), pem.size()));
+  ASSERT_TRUE(bio);
+  bssl::UniquePtr<STACK_OF(X509_INFO)> infos(
+      PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));
+  ASSERT_TRUE(infos);
+  ASSERT_EQ(OPENSSL_ARRAY_SIZE(kExpected), sk_X509_INFO_num(infos.get()));
+  for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kExpected); i++) {
+    SCOPED_TRACE(i);
+    check_info(&kExpected[i], sk_X509_INFO_value(infos.get(), i));
+  }
+
+  // Passing an existing stack appends to it.
+  bio.reset(BIO_new_mem_buf(pem.data(), pem.size()));
+  ASSERT_TRUE(bio);
+  ASSERT_EQ(infos.get(),
+            PEM_X509_INFO_read_bio(bio.get(), infos.get(), nullptr, nullptr));
+  ASSERT_EQ(2 * OPENSSL_ARRAY_SIZE(kExpected), sk_X509_INFO_num(infos.get()));
+  for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kExpected); i++) {
+    SCOPED_TRACE(i);
+    check_info(&kExpected[i], sk_X509_INFO_value(infos.get(), i));
+    check_info(
+        &kExpected[i],
+        sk_X509_INFO_value(infos.get(), i + OPENSSL_ARRAY_SIZE(kExpected)));
+  }
+
+  // Gracefully handle errors in both the append and fresh cases.
+  std::string bad_pem = cert + cert + invalid;
+
+  bio.reset(BIO_new_mem_buf(bad_pem.data(), bad_pem.size()));
+  ASSERT_TRUE(bio);
+  bssl::UniquePtr<STACK_OF(X509_INFO)> infos2(
+      PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));
+  EXPECT_FALSE(infos2);
+
+  bio.reset(BIO_new_mem_buf(bad_pem.data(), bad_pem.size()));
+  ASSERT_TRUE(bio);
+  EXPECT_FALSE(
+      PEM_X509_INFO_read_bio(bio.get(), infos.get(), nullptr, nullptr));
+  EXPECT_EQ(2 * OPENSSL_ARRAY_SIZE(kExpected), sk_X509_INFO_num(infos.get()));
+}
 
 // TEST(X509Test, ReadBIOEmpty) {
 //   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(nullptr, 0));
@@ -2411,7 +2419,7 @@
 // TEST(X509Test, ReadBIOOneByte) {
 //   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf("\x30", 1));
 //   ASSERT_TRUE(bio);
-
+// 
 //   // CPython expects |ASN1_R_HEADER_TOO_LONG| on EOF, to terminate a series of
 //   // certificates. This EOF appeared after some data, however, so we do not wish
 //   // to signal EOF.
@@ -2678,81 +2686,84 @@
 
 // Test that invalid extensions are rejected by, if not the parser, at least the
 // verifier.
-// TEST(X509Test, InvalidExtensions) {
-//   bssl::UniquePtr<X509> root = CertFromPEM(
-//       GetTestData("crypto/x509/test/invalid_extension_root.pem").c_str());
-//   ASSERT_TRUE(root);
-//   bssl::UniquePtr<X509> intermediate = CertFromPEM(
-//       GetTestData("crypto/x509/test/invalid_extension_intermediate.pem")
-//           .c_str());
-//   ASSERT_TRUE(intermediate);
-//   bssl::UniquePtr<X509> leaf = CertFromPEM(
-//       GetTestData("crypto/x509/test/invalid_extension_leaf.pem").c_str());
-//   ASSERT_TRUE(leaf);
-
-//   // Sanity-check that the baseline chain is accepted.
-//   EXPECT_EQ(X509_V_OK,
-//             Verify(leaf.get(), {root.get()}, {intermediate.get()}, {}));
-
-//   static const char *kExtensions[] = {
-//       "authority_key_identifier",
-//       "basic_constraints",
-//       "ext_key_usage",
-//       "key_usage",
-//       "name_constraints",
-//       "subject_alt_name",
-//       "subject_key_identifier",
-//   };
-//   for (const char *ext : kExtensions) {
-//     SCOPED_TRACE(ext);
-//     bssl::UniquePtr<X509> invalid_root = CertFromPEM(
-//         GetTestData((std::string("crypto/x509/test/invalid_extension_root_") +
-//                      ext + ".pem")
-//                         .c_str())
-//             .c_str());
-//     ASSERT_TRUE(invalid_root);
-
-//     bssl::UniquePtr<X509> invalid_intermediate = CertFromPEM(
-//         GetTestData(
-//             (std::string("crypto/x509/test/invalid_extension_intermediate_") +
-//              ext + ".pem")
-//                 .c_str())
-//             .c_str());
-//     ASSERT_TRUE(invalid_intermediate);
-
-//     bssl::UniquePtr<X509> invalid_leaf = CertFromPEM(
-//         GetTestData((std::string("crypto/x509/test/invalid_extension_leaf_") +
-//                      ext + ".pem")
-//                         .c_str())
-//             .c_str());
-//     ASSERT_TRUE(invalid_leaf);
-
-//     bssl::UniquePtr<X509> trailing_leaf = CertFromPEM(
-//         GetTestData((std::string("crypto/x509/test/trailing_data_leaf_") +
-//                      ext + ".pem")
-//                         .c_str())
-//             .c_str());
-//     ASSERT_TRUE(trailing_leaf);
-
-//     EXPECT_EQ(
-//         X509_V_ERR_INVALID_EXTENSION,
-//         Verify(invalid_leaf.get(), {root.get()}, {intermediate.get()}, {}));
-
-//     EXPECT_EQ(
-//         X509_V_ERR_INVALID_EXTENSION,
-//         Verify(trailing_leaf.get(), {root.get()}, {intermediate.get()}, {}));
-
-//     // If the invalid extension is on an intermediate or root,
-//     // |X509_verify_cert| notices by way of being unable to build a path to
-//     // a valid issuer.
-//     EXPECT_EQ(
-//         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
-//         Verify(leaf.get(), {root.get()}, {invalid_intermediate.get()}, {}));
-//     EXPECT_EQ(
-//         X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
-//         Verify(leaf.get(), {invalid_root.get()}, {intermediate.get()}, {}));
-//   }
-// }
+TEST(X509Test, InvalidExtensions) {
+#ifdef BSSL_COMPAT
+  GTEST_SKIP() << "TODO: Investigate failures on BSSL_COMPAT";
+#endif
+  bssl::UniquePtr<X509> root = CertFromPEM(
+      GetTestData("crypto/x509/test/invalid_extension_root.pem").c_str());
+  ASSERT_TRUE(root);
+  bssl::UniquePtr<X509> intermediate = CertFromPEM(
+      GetTestData("crypto/x509/test/invalid_extension_intermediate.pem")
+          .c_str());
+  ASSERT_TRUE(intermediate);
+  bssl::UniquePtr<X509> leaf = CertFromPEM(
+      GetTestData("crypto/x509/test/invalid_extension_leaf.pem").c_str());
+  ASSERT_TRUE(leaf);
+
+  // Sanity-check that the baseline chain is accepted.
+  EXPECT_EQ(X509_V_OK,
+            Verify(leaf.get(), {root.get()}, {intermediate.get()}, {}));
+
+  static const char *kExtensions[] = {
+      "authority_key_identifier",
+      "basic_constraints",
+      "ext_key_usage",
+      "key_usage",
+      "name_constraints",
+      "subject_alt_name",
+      "subject_key_identifier",
+  };
+  for (const char *ext : kExtensions) {
+    SCOPED_TRACE(ext);
+    bssl::UniquePtr<X509> invalid_root = CertFromPEM(
+        GetTestData((std::string("crypto/x509/test/invalid_extension_root_") +
+                     ext + ".pem")
+                        .c_str())
+            .c_str());
+    ASSERT_TRUE(invalid_root);
+
+    bssl::UniquePtr<X509> invalid_intermediate = CertFromPEM(
+        GetTestData(
+            (std::string("crypto/x509/test/invalid_extension_intermediate_") +
+             ext + ".pem")
+                .c_str())
+            .c_str());
+    ASSERT_TRUE(invalid_intermediate);
+
+    bssl::UniquePtr<X509> invalid_leaf = CertFromPEM(
+        GetTestData((std::string("crypto/x509/test/invalid_extension_leaf_") +
+                     ext + ".pem")
+                        .c_str())
+            .c_str());
+    ASSERT_TRUE(invalid_leaf);
+
+    bssl::UniquePtr<X509> trailing_leaf = CertFromPEM(
+        GetTestData((std::string("crypto/x509/test/trailing_data_leaf_") +
+                     ext + ".pem")
+                        .c_str())
+            .c_str());
+    ASSERT_TRUE(trailing_leaf);
+
+    EXPECT_EQ(
+        X509_V_ERR_INVALID_EXTENSION,
+        Verify(invalid_leaf.get(), {root.get()}, {intermediate.get()}, {}));
+
+    EXPECT_EQ(
+        X509_V_ERR_INVALID_EXTENSION,
+        Verify(trailing_leaf.get(), {root.get()}, {intermediate.get()}, {}));
+
+    // If the invalid extension is on an intermediate or root,
+    // |X509_verify_cert| notices by way of being unable to build a path to
+    // a valid issuer.
+    EXPECT_EQ(
+        X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
+        Verify(leaf.get(), {root.get()}, {invalid_intermediate.get()}, {}));
+    EXPECT_EQ(
+        X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY,
+        Verify(leaf.get(), {invalid_root.get()}, {intermediate.get()}, {}));
+  }
+}
 
 // kExplicitDefaultVersionPEM is an X.509v1 certificate with the version number
 // encoded explicitly, rather than omitted as required by DER.
@@ -2991,336 +3002,344 @@
 
 // Unlike upstream OpenSSL, we require a non-null store in
 // |X509_STORE_CTX_init|.
-// TEST(X509Test, NullStore) {
-//   bssl::UniquePtr<X509> leaf(CertFromPEM(kLeafPEM));
-//   ASSERT_TRUE(leaf);
-//   bssl::UniquePtr<X509_STORE_CTX> ctx(X509_STORE_CTX_new());
-//   ASSERT_TRUE(ctx);
-//   EXPECT_FALSE(X509_STORE_CTX_init(ctx.get(), nullptr, leaf.get(), nullptr));
-// }
-
-// TEST(X509Test, BasicConstraints) {
-//   const uint32_t kFlagMask = EXFLAG_CA | EXFLAG_BCONS | EXFLAG_INVALID;
-
-//   static const struct {
-//     const char *file;
-//     uint32_t flags;
-//     int path_len;
-//   } kTests[] = {
-//       {"basic_constraints_none.pem", 0, -1},
-//       {"basic_constraints_ca.pem", EXFLAG_CA | EXFLAG_BCONS, -1},
-//       {"basic_constraints_ca_pathlen_0.pem", EXFLAG_CA | EXFLAG_BCONS, 0},
-//       {"basic_constraints_ca_pathlen_1.pem", EXFLAG_CA | EXFLAG_BCONS, 1},
-//       {"basic_constraints_ca_pathlen_10.pem", EXFLAG_CA | EXFLAG_BCONS, 10},
-//       {"basic_constraints_leaf.pem", EXFLAG_BCONS, -1},
-//       {"invalid_extension_leaf_basic_constraints.pem", EXFLAG_INVALID, -1},
-//   };
-
-//   for (const auto &test : kTests) {
-//     SCOPED_TRACE(test.file);
-
-//     std::string path = "crypto/x509/test/";
-//     path += test.file;
-
-//     bssl::UniquePtr<X509> cert = CertFromPEM(GetTestData(path.c_str()).c_str());
-//     ASSERT_TRUE(cert);
-//     EXPECT_EQ(test.flags, X509_get_extension_flags(cert.get()) & kFlagMask);
-//     EXPECT_EQ(test.path_len, X509_get_pathlen(cert.get()));
-//   }
-// }
+TEST(X509Test, NullStore) {
+  bssl::UniquePtr<X509> leaf(CertFromPEM(kLeafPEM));
+  ASSERT_TRUE(leaf);
+  bssl::UniquePtr<X509_STORE_CTX> ctx(X509_STORE_CTX_new());
+  ASSERT_TRUE(ctx);
+  EXPECT_FALSE(X509_STORE_CTX_init(ctx.get(), nullptr, leaf.get(), nullptr));
+}
+
+TEST(X509Test, BasicConstraints) {
+  const uint32_t kFlagMask = EXFLAG_CA | EXFLAG_BCONS | EXFLAG_INVALID;
+
+  static const struct {
+    const char *file;
+    uint32_t flags;
+    int path_len;
+  } kTests[] = {
+      {"basic_constraints_none.pem", 0, -1},
+      {"basic_constraints_ca.pem", EXFLAG_CA | EXFLAG_BCONS, -1},
+      {"basic_constraints_ca_pathlen_0.pem", EXFLAG_CA | EXFLAG_BCONS, 0},
+      {"basic_constraints_ca_pathlen_1.pem", EXFLAG_CA | EXFLAG_BCONS, 1},
+      {"basic_constraints_ca_pathlen_10.pem", EXFLAG_CA | EXFLAG_BCONS, 10},
+      {"basic_constraints_leaf.pem", EXFLAG_BCONS, -1},
+      {"invalid_extension_leaf_basic_constraints.pem", EXFLAG_INVALID, -1},
+  };
+
+  for (const auto &test : kTests) {
+    SCOPED_TRACE(test.file);
+
+    std::string path = "crypto/x509/test/";
+    path += test.file;
+
+    bssl::UniquePtr<X509> cert = CertFromPEM(GetTestData(path.c_str()).c_str());
+    ASSERT_TRUE(cert);
+    EXPECT_EQ(test.flags, X509_get_extension_flags(cert.get()) & kFlagMask);
+    EXPECT_EQ(test.path_len, X509_get_pathlen(cert.get()));
+  }
+}
 
 // The following strings are test certificates signed by kP256Key and kRSAKey,
 // with missing, NULL, or invalid algorithm parameters.
-// static const char kP256NoParam[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBIDCBxqADAgECAgIE0jAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDEwRUZXN0MCAX
-// DTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRUZXN0
-// MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdrt6ke
-// DUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMQMA4w
-// DAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEAqdIiF+bN9Cl44oUeICpy
-// aXd7HqhpVUaglYKw9ChmNUACIQCpMdL0fNkFNDbRww9dSl/y7kBdk/tp16HiqeSy
-// gGzFYg==
-// -----END CERTIFICATE-----
-// )";
-// static const char kP256NullParam[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBJDCByKADAgECAgIE0jAMBggqhkjOPQQDAgUAMA8xDTALBgNVBAMTBFRlc3Qw
-// IBcNMDAwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMA8xDTALBgNVBAMTBFRl
-// c3QwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATmK2niv2Wfl74vHg2UikzVl2u3
-// qR4NRvvdqakendy6WgHn1peoChj5w8SjHlbifINI2xYaHPUdfvGULUvPciLBoxAw
-// DjAMBgNVHRMEBTADAQH/MAwGCCqGSM49BAMCBQADSQAwRgIhAKILHmyo+F3Cn/VX
-// UUeSXOQQKX5aLzsQitwwmNF3ZgH3AiEAsYHcrVj/ftmoQIORARkQ/+PrqntXev8r
-// t6uPxHrmpUY=
-// -----END CERTIFICATE-----
-// )";
-// static const char kP256InvalidParam[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBMTCBz6ADAgECAgIE0jATBggqhkjOPQQDAgQHZ2FyYmFnZTAPMQ0wCwYDVQQD
-// EwRUZXN0MCAXDTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYD
-// VQQDEwRUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4N
-// lIpM1Zdrt6keDUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1L
-// z3IiwaMQMA4wDAYDVR0TBAUwAwEB/zATBggqhkjOPQQDAgQHZ2FyYmFnZQNIADBF
-// AiAglpDf/YhN89LeJ2WAs/F0SJIrsuhS4uoInIz6WXUiuQIhAIu5Pwhp5E3Pbo8y
-// fLULTZnynuQUULQkRcF7S7T2WpIL
-// -----END CERTIFICATE-----
-// )";
-// static const char kRSANoParam[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBWzCBx6ADAgECAgIE0jALBgkqhkiG9w0BAQswDzENMAsGA1UEAxMEVGVzdDAg
-// Fw0wMDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsGA1UEAxMEVGVz
-// dDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8eDZSKTNWXa7ep
-// Hg1G+92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQtS89yIsGjEDAO
-// MAwGA1UdEwQFMAMBAf8wCwYJKoZIhvcNAQELA4GBAC1f8W3W0Ao7CPfIBQYDSbPh
-// brZpbxdBU5x27JOS7iSa+Lc9pEH5VCX9vIypHVHXLPEfZ38yIt11eiyrmZB6w62N
-// l9kIeZ6FVPmC30d3sXx70Jjs+ZX9yt7kD1gLyNAQQfeYfa4rORAZT1n2YitD74NY
-// TWUH2ieFP3l+ecj1SeQR
-// -----END CERTIFICATE-----
-// )";
-// static const char kRSANullParam[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBXzCByaADAgECAgIE0jANBgkqhkiG9w0BAQsFADAPMQ0wCwYDVQQDEwRUZXN0
-// MCAXDTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRU
-// ZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdr
-// t6keDUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMQ
-// MA4wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQAzVcfIv+Rq1KrMXqIL
-// fPq/cWZjgqFZA1RGaGElNaqp+rkJfamq5tDGzckWpebrK+jjRN7yIlcWDtPpy3Gy
-// seZfvtBDR0TwJm0S/pQl8prKB4wgALcwe3bmi56Rq85nzY5ZLNcP16LQxL+jAAua
-// SwmQUz4bRpckRBj+sIyp1We+pg==
-// -----END CERTIFICATE-----
-// )";
-// static const char kRSAInvalidParam[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBbTCB0KADAgECAgIE0jAUBgkqhkiG9w0BAQsEB2dhcmJhZ2UwDzENMAsGA1UE
-// AxMEVGVzdDAgFw0wMDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsG
-// A1UEAxMEVGVzdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8e
-// DZSKTNWXa7epHg1G+92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQt
-// S89yIsGjEDAOMAwGA1UdEwQFMAMBAf8wFAYJKoZIhvcNAQELBAdnYXJiYWdlA4GB
-// AHTJ6cWWjCNrZhqiWWVI3jdK+h5xpRG8jGMXxR4JnjtoYRRusJLOXhmapwCB6fA0
-// 4vc+66O27v36yDmQX+tIc/hDrTpKNJptU8q3n2VagREvoHhkOTYkcCeS8vmnMtn8
-// 5OMNZ/ajVwOssw61GcAlScRqEHkZFBoGp7e+QpgB2tf9
-// -----END CERTIFICATE-----
-// )";
-
-// TEST(X509Test, AlgorithmParameters) {
-//   // P-256 parameters should be omitted, but we accept NULL ones.
-//   bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
-//   ASSERT_TRUE(key);
-
-//   bssl::UniquePtr<X509> cert = CertFromPEM(kP256NoParam);
-//   ASSERT_TRUE(cert);
-//   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
-
-//   cert = CertFromPEM(kP256NullParam);
-//   ASSERT_TRUE(cert);
-//   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
-
-//   cert = CertFromPEM(kP256InvalidParam);
-//   ASSERT_TRUE(cert);
-//   EXPECT_FALSE(X509_verify(cert.get(), key.get()));
-//   uint32_t err = ERR_get_error();
-//   EXPECT_EQ(ERR_LIB_X509, ERR_GET_LIB(err));
-//   EXPECT_EQ(X509_R_INVALID_PARAMETER, ERR_GET_REASON(err));
-
-//   // RSA parameters should be NULL, but we accept omitted ones.
-//   key = PrivateKeyFromPEM(kRSAKey);
-//   ASSERT_TRUE(key);
-
-//   cert = CertFromPEM(kRSANoParam);
-//   ASSERT_TRUE(cert);
-//   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
-
-//   cert = CertFromPEM(kRSANullParam);
-//   ASSERT_TRUE(cert);
-//   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
-
-//   cert = CertFromPEM(kRSAInvalidParam);
-//   ASSERT_TRUE(cert);
-//   EXPECT_FALSE(X509_verify(cert.get(), key.get()));
-//   err = ERR_get_error();
-//   EXPECT_EQ(ERR_LIB_X509, ERR_GET_LIB(err));
-//   EXPECT_EQ(X509_R_INVALID_PARAMETER, ERR_GET_REASON(err));
-// }
-
-// TEST(X509Test, GeneralName)  {
-//   const std::vector<uint8_t> kNames[] = {
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
-//       //   [0] {
-//       //     SEQUENCE {}
-//       //   }
-//       // }
-//       {0xa0, 0x13, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x02, 0x30, 0x00},
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
-//       //   [0] {
-//       //     [APPLICATION 0] {}
-//       //   }
-//       // }
-//       {0xa0, 0x13, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x02, 0x60, 0x00},
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
-//       //   [0] {
-//       //     UTF8String { "a" }
-//       //   }
-//       // }
-//       {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x0c, 0x01, 0x61},
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.2 }
-//       //   [0] {
-//       //     UTF8String { "a" }
-//       //   }
-//       // }
-//       {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x02, 0xa0, 0x03, 0x0c, 0x01, 0x61},
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
-//       //   [0] {
-//       //     UTF8String { "b" }
-//       //   }
-//       // }
-//       {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x0c, 0x01, 0x62},
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
-//       //   [0] {
-//       //     BOOLEAN { TRUE }
-//       //   }
-//       // }
-//       {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x01, 0x01, 0xff},
-//       // [0] {
-//       //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
-//       //   [0] {
-//       //     BOOLEAN { FALSE }
-//       //   }
-//       // }
-//       {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
-//        0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x01, 0x01, 0x00},
-//       // [1 PRIMITIVE] { "a" }
-//       {0x81, 0x01, 0x61},
-//       // [1 PRIMITIVE] { "b" }
-//       {0x81, 0x01, 0x62},
-//       // [2 PRIMITIVE] { "a" }
-//       {0x82, 0x01, 0x61},
-//       // [2 PRIMITIVE] { "b" }
-//       {0x82, 0x01, 0x62},
-//       // [4] {
-//       //   SEQUENCE {
-//       //     SET {
-//       //       SEQUENCE {
-//       //         # commonName
-//       //         OBJECT_IDENTIFIER { 2.5.4.3 }
-//       //         UTF8String { "a" }
-//       //       }
-//       //     }
-//       //   }
-//       // }
-//       {0xa4, 0x0e, 0x30, 0x0c, 0x31, 0x0a, 0x30, 0x08, 0x06, 0x03, 0x55, 0x04,
-//        0x03, 0x0c, 0x01, 0x61},
-//       // [4] {
-//       //   SEQUENCE {
-//       //     SET {
-//       //       SEQUENCE {
-//       //         # commonName
-//       //         OBJECT_IDENTIFIER { 2.5.4.3 }
-//       //         UTF8String { "b" }
-//       //       }
-//       //     }
-//       //   }
-//       // }
-//       {0xa4, 0x0e, 0x30, 0x0c, 0x31, 0x0a, 0x30, 0x08, 0x06, 0x03, 0x55, 0x04,
-//        0x03, 0x0c, 0x01, 0x62},
-//       // [5] {
-//       //   [1] {
-//       //     UTF8String { "a" }
-//       //   }
-//       // }
-//       {0xa5, 0x05, 0xa1, 0x03, 0x0c, 0x01, 0x61},
-//       // [5] {
-//       //   [1] {
-//       //     UTF8String { "b" }
-//       //   }
-//       // }
-//       {0xa5, 0x05, 0xa1, 0x03, 0x0c, 0x01, 0x62},
-//       // [5] {
-//       //   [0] {
-//       //     UTF8String {}
-//       //   }
-//       //   [1] {
-//       //     UTF8String { "a" }
-//       //   }
-//       // }
-//       {0xa5, 0x09, 0xa0, 0x02, 0x0c, 0x00, 0xa1, 0x03, 0x0c, 0x01, 0x61},
-//       // [5] {
-//       //   [0] {
-//       //     UTF8String { "a" }
-//       //   }
-//       //   [1] {
-//       //     UTF8String { "a" }
-//       //   }
-//       // }
-//       {0xa5, 0x0a, 0xa0, 0x03, 0x0c, 0x01, 0x61, 0xa1, 0x03, 0x0c, 0x01, 0x61},
-//       // [5] {
-//       //   [0] {
-//       //     UTF8String { "b" }
-//       //   }
-//       //   [1] {
-//       //     UTF8String { "a" }
-//       //   }
-//       // }
-//       {0xa5, 0x0a, 0xa0, 0x03, 0x0c, 0x01, 0x62, 0xa1, 0x03, 0x0c, 0x01, 0x61},
-//       // [6 PRIMITIVE] { "a" }
-//       {0x86, 0x01, 0x61},
-//       // [6 PRIMITIVE] { "b" }
-//       {0x86, 0x01, 0x62},
-//       // [7 PRIMITIVE] { `11111111` }
-//       {0x87, 0x04, 0x11, 0x11, 0x11, 0x11},
-//       // [7 PRIMITIVE] { `22222222`}
-//       {0x87, 0x04, 0x22, 0x22, 0x22, 0x22},
-//       // [7 PRIMITIVE] { `11111111111111111111111111111111` }
-//       {0x87, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-//        0x11, 0x11, 0x11, 0x11, 0x11, 0x11},
-//       // [7 PRIMITIVE] { `22222222222222222222222222222222` }
-//       {0x87, 0x10, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-//        0x22, 0x22, 0x22, 0x22, 0x22, 0x22},
-//       // [8 PRIMITIVE] { 1.2.840.113554.4.1.72585.2.1 }
-//       {0x88, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04, 0x01, 0x84, 0xb7,
-//        0x09, 0x02, 0x01},
-//       // [8 PRIMITIVE] { 1.2.840.113554.4.1.72585.2.2 }
-//       {0x88, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04, 0x01, 0x84, 0xb7,
-//        0x09, 0x02, 0x02},
-//   };
-
-//   // Every name should be equal to itself and not equal to any others.
-//   for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kNames); i++) {
-//     SCOPED_TRACE(Bytes(kNames[i]));
-
-//     const uint8_t *ptr = kNames[i].data();
-//     bssl::UniquePtr<GENERAL_NAME> a(
-//         d2i_GENERAL_NAME(nullptr, &ptr, kNames[i].size()));
-//     ASSERT_TRUE(a);
-//     ASSERT_EQ(ptr, kNames[i].data() + kNames[i].size());
-
-//     for (size_t j = 0; j < OPENSSL_ARRAY_SIZE(kNames); j++) {
-//       SCOPED_TRACE(Bytes(kNames[j]));
-
-//       ptr = kNames[j].data();
-//       bssl::UniquePtr<GENERAL_NAME> b(
-//           d2i_GENERAL_NAME(nullptr, &ptr, kNames[j].size()));
-//       ASSERT_TRUE(b);
-//       ASSERT_EQ(ptr, kNames[j].data() + kNames[j].size());
-
-//       if (i == j) {
-//         EXPECT_EQ(GENERAL_NAME_cmp(a.get(), b.get()), 0);
-//       } else {
-//         EXPECT_NE(GENERAL_NAME_cmp(a.get(), b.get()), 0);
-//       }
-//     }
-//   }
-// }
+static const char kP256NoParam[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBIDCBxqADAgECAgIE0jAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDEwRUZXN0MCAX
+DTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRUZXN0
+MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdrt6ke
+DUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMQMA4w
+DAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEAqdIiF+bN9Cl44oUeICpy
+aXd7HqhpVUaglYKw9ChmNUACIQCpMdL0fNkFNDbRww9dSl/y7kBdk/tp16HiqeSy
+gGzFYg==
+-----END CERTIFICATE-----
+)";
+static const char kP256NullParam[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBJDCByKADAgECAgIE0jAMBggqhkjOPQQDAgUAMA8xDTALBgNVBAMTBFRlc3Qw
+IBcNMDAwMTAxMDAwMDAwWhgPMjEwMDAxMDEwMDAwMDBaMA8xDTALBgNVBAMTBFRl
+c3QwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATmK2niv2Wfl74vHg2UikzVl2u3
+qR4NRvvdqakendy6WgHn1peoChj5w8SjHlbifINI2xYaHPUdfvGULUvPciLBoxAw
+DjAMBgNVHRMEBTADAQH/MAwGCCqGSM49BAMCBQADSQAwRgIhAKILHmyo+F3Cn/VX
+UUeSXOQQKX5aLzsQitwwmNF3ZgH3AiEAsYHcrVj/ftmoQIORARkQ/+PrqntXev8r
+t6uPxHrmpUY=
+-----END CERTIFICATE-----
+)";
+#ifndef BSSL_COMPAT
+static const char kP256InvalidParam[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBMTCBz6ADAgECAgIE0jATBggqhkjOPQQDAgQHZ2FyYmFnZTAPMQ0wCwYDVQQD
+EwRUZXN0MCAXDTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYD
+VQQDEwRUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4N
+lIpM1Zdrt6keDUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1L
+z3IiwaMQMA4wDAYDVR0TBAUwAwEB/zATBggqhkjOPQQDAgQHZ2FyYmFnZQNIADBF
+AiAglpDf/YhN89LeJ2WAs/F0SJIrsuhS4uoInIz6WXUiuQIhAIu5Pwhp5E3Pbo8y
+fLULTZnynuQUULQkRcF7S7T2WpIL
+-----END CERTIFICATE-----
+)";
+#endif
+static const char kRSANoParam[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBWzCBx6ADAgECAgIE0jALBgkqhkiG9w0BAQswDzENMAsGA1UEAxMEVGVzdDAg
+Fw0wMDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsGA1UEAxMEVGVz
+dDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8eDZSKTNWXa7ep
+Hg1G+92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQtS89yIsGjEDAO
+MAwGA1UdEwQFMAMBAf8wCwYJKoZIhvcNAQELA4GBAC1f8W3W0Ao7CPfIBQYDSbPh
+brZpbxdBU5x27JOS7iSa+Lc9pEH5VCX9vIypHVHXLPEfZ38yIt11eiyrmZB6w62N
+l9kIeZ6FVPmC30d3sXx70Jjs+ZX9yt7kD1gLyNAQQfeYfa4rORAZT1n2YitD74NY
+TWUH2ieFP3l+ecj1SeQR
+-----END CERTIFICATE-----
+)";
+static const char kRSANullParam[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBXzCByaADAgECAgIE0jANBgkqhkiG9w0BAQsFADAPMQ0wCwYDVQQDEwRUZXN0
+MCAXDTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRU
+ZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdr
+t6keDUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMQ
+MA4wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOBgQAzVcfIv+Rq1KrMXqIL
+fPq/cWZjgqFZA1RGaGElNaqp+rkJfamq5tDGzckWpebrK+jjRN7yIlcWDtPpy3Gy
+seZfvtBDR0TwJm0S/pQl8prKB4wgALcwe3bmi56Rq85nzY5ZLNcP16LQxL+jAAua
+SwmQUz4bRpckRBj+sIyp1We+pg==
+-----END CERTIFICATE-----
+)";
+#ifndef BSSL_COMPAT
+static const char kRSAInvalidParam[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBbTCB0KADAgECAgIE0jAUBgkqhkiG9w0BAQsEB2dhcmJhZ2UwDzENMAsGA1UE
+AxMEVGVzdDAgFw0wMDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsG
+A1UEAxMEVGVzdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8e
+DZSKTNWXa7epHg1G+92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQt
+S89yIsGjEDAOMAwGA1UdEwQFMAMBAf8wFAYJKoZIhvcNAQELBAdnYXJiYWdlA4GB
+AHTJ6cWWjCNrZhqiWWVI3jdK+h5xpRG8jGMXxR4JnjtoYRRusJLOXhmapwCB6fA0
+4vc+66O27v36yDmQX+tIc/hDrTpKNJptU8q3n2VagREvoHhkOTYkcCeS8vmnMtn8
+5OMNZ/ajVwOssw61GcAlScRqEHkZFBoGp7e+QpgB2tf9
+-----END CERTIFICATE-----
+)";
+#endif
+
+TEST(X509Test, AlgorithmParameters) {
+  // P-256 parameters should be omitted, but we accept NULL ones.
+  bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
+  ASSERT_TRUE(key);
+
+  bssl::UniquePtr<X509> cert = CertFromPEM(kP256NoParam);
+  ASSERT_TRUE(cert);
+  EXPECT_TRUE(X509_verify(cert.get(), key.get()));
+
+  cert = CertFromPEM(kP256NullParam);
+  ASSERT_TRUE(cert);
+  EXPECT_TRUE(X509_verify(cert.get(), key.get()));
+
+#ifndef BSSL_COMPAT
+  cert = CertFromPEM(kP256InvalidParam);
+  ASSERT_TRUE(cert);
+  EXPECT_FALSE(X509_verify(cert.get(), key.get()));
+  uint32_t err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_X509, ERR_GET_LIB(err));
+  EXPECT_EQ(X509_R_INVALID_PARAMETER, ERR_GET_REASON(err));
+#endif
+
+  // RSA parameters should be NULL, but we accept omitted ones.
+  key = PrivateKeyFromPEM(kRSAKey);
+  ASSERT_TRUE(key);
+
+  cert = CertFromPEM(kRSANoParam);
+  ASSERT_TRUE(cert);
+  EXPECT_TRUE(X509_verify(cert.get(), key.get()));
+
+  cert = CertFromPEM(kRSANullParam);
+  ASSERT_TRUE(cert);
+  EXPECT_TRUE(X509_verify(cert.get(), key.get()));
+
+#ifndef BSSL_COMPAT
+  cert = CertFromPEM(kRSAInvalidParam);
+  ASSERT_TRUE(cert);
+  EXPECT_FALSE(X509_verify(cert.get(), key.get()));
+  err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_X509, ERR_GET_LIB(err));
+  EXPECT_EQ(X509_R_INVALID_PARAMETER, ERR_GET_REASON(err));
+#endif
+}
+
+TEST(X509Test, GeneralName)  {
+  const std::vector<uint8_t> kNames[] = {
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
+      //   [0] {
+      //     SEQUENCE {}
+      //   }
+      // }
+      {0xa0, 0x13, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x02, 0x30, 0x00},
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
+      //   [0] {
+      //     [APPLICATION 0] {}
+      //   }
+      // }
+      {0xa0, 0x13, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x02, 0x60, 0x00},
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
+      //   [0] {
+      //     UTF8String { "a" }
+      //   }
+      // }
+      {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x0c, 0x01, 0x61},
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.2 }
+      //   [0] {
+      //     UTF8String { "a" }
+      //   }
+      // }
+      {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x02, 0xa0, 0x03, 0x0c, 0x01, 0x61},
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
+      //   [0] {
+      //     UTF8String { "b" }
+      //   }
+      // }
+      {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x0c, 0x01, 0x62},
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
+      //   [0] {
+      //     BOOLEAN { TRUE }
+      //   }
+      // }
+      {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x01, 0x01, 0xff},
+      // [0] {
+      //   OBJECT_IDENTIFIER { 1.2.840.113554.4.1.72585.2.1 }
+      //   [0] {
+      //     BOOLEAN { FALSE }
+      //   }
+      // }
+      {0xa0, 0x14, 0x06, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04,
+       0x01, 0x84, 0xb7, 0x09, 0x02, 0x01, 0xa0, 0x03, 0x01, 0x01, 0x00},
+      // [1 PRIMITIVE] { "a" }
+      {0x81, 0x01, 0x61},
+      // [1 PRIMITIVE] { "b" }
+      {0x81, 0x01, 0x62},
+      // [2 PRIMITIVE] { "a" }
+      {0x82, 0x01, 0x61},
+      // [2 PRIMITIVE] { "b" }
+      {0x82, 0x01, 0x62},
+      // [4] {
+      //   SEQUENCE {
+      //     SET {
+      //       SEQUENCE {
+      //         # commonName
+      //         OBJECT_IDENTIFIER { 2.5.4.3 }
+      //         UTF8String { "a" }
+      //       }
+      //     }
+      //   }
+      // }
+      {0xa4, 0x0e, 0x30, 0x0c, 0x31, 0x0a, 0x30, 0x08, 0x06, 0x03, 0x55, 0x04,
+       0x03, 0x0c, 0x01, 0x61},
+      // [4] {
+      //   SEQUENCE {
+      //     SET {
+      //       SEQUENCE {
+      //         # commonName
+      //         OBJECT_IDENTIFIER { 2.5.4.3 }
+      //         UTF8String { "b" }
+      //       }
+      //     }
+      //   }
+      // }
+      {0xa4, 0x0e, 0x30, 0x0c, 0x31, 0x0a, 0x30, 0x08, 0x06, 0x03, 0x55, 0x04,
+       0x03, 0x0c, 0x01, 0x62},
+      // [5] {
+      //   [1] {
+      //     UTF8String { "a" }
+      //   }
+      // }
+      {0xa5, 0x05, 0xa1, 0x03, 0x0c, 0x01, 0x61},
+      // [5] {
+      //   [1] {
+      //     UTF8String { "b" }
+      //   }
+      // }
+      {0xa5, 0x05, 0xa1, 0x03, 0x0c, 0x01, 0x62},
+      // [5] {
+      //   [0] {
+      //     UTF8String {}
+      //   }
+      //   [1] {
+      //     UTF8String { "a" }
+      //   }
+      // }
+      {0xa5, 0x09, 0xa0, 0x02, 0x0c, 0x00, 0xa1, 0x03, 0x0c, 0x01, 0x61},
+      // [5] {
+      //   [0] {
+      //     UTF8String { "a" }
+      //   }
+      //   [1] {
+      //     UTF8String { "a" }
+      //   }
+      // }
+      {0xa5, 0x0a, 0xa0, 0x03, 0x0c, 0x01, 0x61, 0xa1, 0x03, 0x0c, 0x01, 0x61},
+      // [5] {
+      //   [0] {
+      //     UTF8String { "b" }
+      //   }
+      //   [1] {
+      //     UTF8String { "a" }
+      //   }
+      // }
+      {0xa5, 0x0a, 0xa0, 0x03, 0x0c, 0x01, 0x62, 0xa1, 0x03, 0x0c, 0x01, 0x61},
+      // [6 PRIMITIVE] { "a" }
+      {0x86, 0x01, 0x61},
+      // [6 PRIMITIVE] { "b" }
+      {0x86, 0x01, 0x62},
+      // [7 PRIMITIVE] { `11111111` }
+      {0x87, 0x04, 0x11, 0x11, 0x11, 0x11},
+      // [7 PRIMITIVE] { `22222222`}
+      {0x87, 0x04, 0x22, 0x22, 0x22, 0x22},
+      // [7 PRIMITIVE] { `11111111111111111111111111111111` }
+      {0x87, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+       0x11, 0x11, 0x11, 0x11, 0x11, 0x11},
+      // [7 PRIMITIVE] { `22222222222222222222222222222222` }
+      {0x87, 0x10, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
+       0x22, 0x22, 0x22, 0x22, 0x22, 0x22},
+      // [8 PRIMITIVE] { 1.2.840.113554.4.1.72585.2.1 }
+      {0x88, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04, 0x01, 0x84, 0xb7,
+       0x09, 0x02, 0x01},
+      // [8 PRIMITIVE] { 1.2.840.113554.4.1.72585.2.2 }
+      {0x88, 0x0d, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x04, 0x01, 0x84, 0xb7,
+       0x09, 0x02, 0x02},
+  };
+
+  // Every name should be equal to itself and not equal to any others.
+  for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kNames); i++) {
+    SCOPED_TRACE(Bytes(kNames[i]));
+
+    const uint8_t *ptr = kNames[i].data();
+    bssl::UniquePtr<GENERAL_NAME> a(
+        d2i_GENERAL_NAME(nullptr, &ptr, kNames[i].size()));
+    ASSERT_TRUE(a);
+    ASSERT_EQ(ptr, kNames[i].data() + kNames[i].size());
+
+    for (size_t j = 0; j < OPENSSL_ARRAY_SIZE(kNames); j++) {
+      SCOPED_TRACE(Bytes(kNames[j]));
+
+      ptr = kNames[j].data();
+      bssl::UniquePtr<GENERAL_NAME> b(
+          d2i_GENERAL_NAME(nullptr, &ptr, kNames[j].size()));
+      ASSERT_TRUE(b);
+      ASSERT_EQ(ptr, kNames[j].data() + kNames[j].size());
+
+      if (i == j) {
+        EXPECT_EQ(GENERAL_NAME_cmp(a.get(), b.get()), 0);
+      } else {
+        EXPECT_NE(GENERAL_NAME_cmp(a.get(), b.get()), 0);
+      }
+    }
+  }
+}
 
 // Test that extracting fields of an |X509_ALGOR| works correctly.
 // TEST(X509Test, X509AlgorExtract) {
@@ -3487,171 +3506,174 @@
 // Test that, by default, |X509_V_FLAG_TRUSTED_FIRST| is set, which means we'll
 // skip over server-sent expired intermediates when there is a local trust
 // anchor that works better.
-// TEST(X509Test, TrustedFirst) {
-//   // Generate the following certificates:
-//   //
-//   //                     Root 2 (in store, expired)
-//   //                       |
-//   // Root 1 (in store)   Root 1 (cross-sign)
-//   //          \           /
-//   //          Intermediate
-//   //                |
-//   //               Leaf
-//   bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
-//   ASSERT_TRUE(key);
-
-//   bssl::UniquePtr<X509> root2 =
-//       MakeTestCert("Root 2", "Root 2", key.get(), /*is_ca=*/true);
-//   ASSERT_TRUE(root2);
-//   ASSERT_TRUE(ASN1_TIME_adj(X509_getm_notAfter(root2.get()), kReferenceTime,
-//                             /*offset_day=*/0,
-//                             /*offset_sec=*/-1));
-//   ASSERT_TRUE(X509_sign(root2.get(), key.get(), EVP_sha256()));
-
-//   bssl::UniquePtr<X509> root1 =
-//       MakeTestCert("Root 1", "Root 1", key.get(), /*is_ca=*/true);
-//   ASSERT_TRUE(root1);
-//   ASSERT_TRUE(X509_sign(root1.get(), key.get(), EVP_sha256()));
-
-//   bssl::UniquePtr<X509> root1_cross =
-//       MakeTestCert("Root 2", "Root 1", key.get(), /*is_ca=*/true);
-//   ASSERT_TRUE(root1_cross);
-//   ASSERT_TRUE(X509_sign(root1_cross.get(), key.get(), EVP_sha256()));
-
-//   bssl::UniquePtr<X509> intermediate =
-//       MakeTestCert("Root 1", "Intermediate", key.get(), /*is_ca=*/true);
-//   ASSERT_TRUE(intermediate);
-//   ASSERT_TRUE(X509_sign(intermediate.get(), key.get(), EVP_sha256()));
-
-//   bssl::UniquePtr<X509> leaf =
-//       MakeTestCert("Intermediate", "Leaf", key.get(), /*is_ca=*/false);
-//   ASSERT_TRUE(leaf);
-//   ASSERT_TRUE(X509_sign(leaf.get(), key.get(), EVP_sha256()));
-
-//   // As a control, confirm that |leaf| -> |intermediate| -> |root1| is valid,
-//   // but the path through |root1_cross| is expired.
-//   EXPECT_EQ(X509_V_OK,
-//             Verify(leaf.get(), {root1.get()}, {intermediate.get()}, {}));
-//   EXPECT_EQ(X509_V_ERR_CERT_HAS_EXPIRED,
-//             Verify(leaf.get(), {root2.get()},
-//                    {intermediate.get(), root1_cross.get()}, {}));
-
-//   // By default, we should find the |leaf| -> |intermediate| -> |root2| chain,
-//   // skipping |root1_cross|.
-//   EXPECT_EQ(X509_V_OK, Verify(leaf.get(), {root1.get(), root2.get()},
-//                               {intermediate.get(), root1_cross.get()}, {}));
-
-//   // When |X509_V_FLAG_TRUSTED_FIRST| is disabled, we get stuck on the expired
-//   // intermediate. Note we need the callback to clear the flag. Setting |flags|
-//   // to zero only skips setting new flags.
-//   //
-//   // This test exists to confirm our current behavior, but these modes are just
-//   // workarounds for not having an actual path-building verifier. If we fix it,
-//   // this test can be removed.
-//   EXPECT_EQ(X509_V_ERR_CERT_HAS_EXPIRED,
-//             Verify(leaf.get(), {root1.get(), root2.get()},
-//                    {intermediate.get(), root1_cross.get()}, {}, /*flags=*/0,
-//                    [&](X509_VERIFY_PARAM *param) {
-//                      X509_VERIFY_PARAM_clear_flags(param,
-//                                                    X509_V_FLAG_TRUSTED_FIRST);
-//                    }));
-
-//   // Even when |X509_V_FLAG_TRUSTED_FIRST| is disabled, if |root2| is not
-//   // trusted, the alt chains logic recovers the path.
-//   EXPECT_EQ(
-//       X509_V_OK,
-//       Verify(leaf.get(), {root1.get()}, {intermediate.get(), root1_cross.get()},
-//              {}, /*flags=*/0, [&](X509_VERIFY_PARAM *param) {
-//                X509_VERIFY_PARAM_clear_flags(param, X509_V_FLAG_TRUSTED_FIRST);
-//              }));
-// }
+TEST(X509Test, TrustedFirst) {
+  // Generate the following certificates:
+  //
+  //                     Root 2 (in store, expired)
+  //                       |
+  // Root 1 (in store)   Root 1 (cross-sign)
+  //          \           /
+  //          Intermediate
+  //                |
+  //               Leaf
+  bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
+  ASSERT_TRUE(key);
+
+  bssl::UniquePtr<X509> root2 =
+      MakeTestCert("Root 2", "Root 2", key.get(), /*is_ca=*/true);
+  ASSERT_TRUE(root2);
+  ASSERT_TRUE(ASN1_TIME_adj(X509_getm_notAfter(root2.get()), kReferenceTime,
+                            /*offset_day=*/0,
+                            /*offset_sec=*/-1));
+  ASSERT_TRUE(X509_sign(root2.get(), key.get(), EVP_sha256()));
+
+  bssl::UniquePtr<X509> root1 =
+      MakeTestCert("Root 1", "Root 1", key.get(), /*is_ca=*/true);
+  ASSERT_TRUE(root1);
+  ASSERT_TRUE(X509_sign(root1.get(), key.get(), EVP_sha256()));
+
+  bssl::UniquePtr<X509> root1_cross =
+      MakeTestCert("Root 2", "Root 1", key.get(), /*is_ca=*/true);
+  ASSERT_TRUE(root1_cross);
+  ASSERT_TRUE(X509_sign(root1_cross.get(), key.get(), EVP_sha256()));
+
+  bssl::UniquePtr<X509> intermediate =
+      MakeTestCert("Root 1", "Intermediate", key.get(), /*is_ca=*/true);
+  ASSERT_TRUE(intermediate);
+  ASSERT_TRUE(X509_sign(intermediate.get(), key.get(), EVP_sha256()));
+
+  bssl::UniquePtr<X509> leaf =
+      MakeTestCert("Intermediate", "Leaf", key.get(), /*is_ca=*/false);
+  ASSERT_TRUE(leaf);
+  ASSERT_TRUE(X509_sign(leaf.get(), key.get(), EVP_sha256()));
+
+  // As a control, confirm that |leaf| -> |intermediate| -> |root1| is valid,
+  // but the path through |root1_cross| is expired.
+  EXPECT_EQ(X509_V_OK,
+            Verify(leaf.get(), {root1.get()}, {intermediate.get()}, {}));
+  EXPECT_EQ(X509_V_ERR_CERT_HAS_EXPIRED,
+            Verify(leaf.get(), {root2.get()},
+                   {intermediate.get(), root1_cross.get()}, {}));
+
+  // By default, we should find the |leaf| -> |intermediate| -> |root2| chain,
+  // skipping |root1_cross|.
+  EXPECT_EQ(X509_V_OK, Verify(leaf.get(), {root1.get(), root2.get()},
+                              {intermediate.get(), root1_cross.get()}, {}));
+
+  // When |X509_V_FLAG_TRUSTED_FIRST| is disabled, we get stuck on the expired
+  // intermediate. Note we need the callback to clear the flag. Setting |flags|
+  // to zero only skips setting new flags.
+  //
+  // This test exists to confirm our current behavior, but these modes are just
+  // workarounds for not having an actual path-building verifier. If we fix it,
+  // this test can be removed.
+  EXPECT_EQ(X509_V_ERR_CERT_HAS_EXPIRED,
+            Verify(leaf.get(), {root1.get(), root2.get()},
+                   {intermediate.get(), root1_cross.get()}, {}, /*flags=*/0,
+                   [&](X509_VERIFY_PARAM *param) {
+                     X509_VERIFY_PARAM_clear_flags(param,
+                                                   X509_V_FLAG_TRUSTED_FIRST);
+                   }));
+
+  // Even when |X509_V_FLAG_TRUSTED_FIRST| is disabled, if |root2| is not
+  // trusted, the alt chains logic recovers the path.
+  EXPECT_EQ(
+      X509_V_OK,
+      Verify(leaf.get(), {root1.get()}, {intermediate.get(), root1_cross.get()},
+             {}, /*flags=*/0, [&](X509_VERIFY_PARAM *param) {
+               X509_VERIFY_PARAM_clear_flags(param, X509_V_FLAG_TRUSTED_FIRST);
+             }));
+}
 
 // kConstructedBitString is an X.509 certificate where the signature is encoded
 // as a BER constructed BIT STRING. Note that, while OpenSSL's parser accepts
 // this input, it interprets the value incorrectly.
-// static const char kConstructedBitString[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBJTCBxqADAgECAgIE0jAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDEwRUZXN0MCAX
-// DTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRUZXN0
-// MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdrt6ke
-// DUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMQMA4w
-// DAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAiNOAyQAMEYCIQCp0iIX5s30KXjihR4g
-// KnJpd3seqGlVRqCVgrD0KGYDJgA1QAIhAKkx0vR82QU0NtHDD11KX/LuQF2T+2nX
-// oeKp5LKAbMVi
-// -----END CERTIFICATE-----
-// )";
+static const char kConstructedBitString[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBJTCBxqADAgECAgIE0jAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDEwRUZXN0MCAX
+DTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRUZXN0
+MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdrt6ke
+DUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMQMA4w
+DAYDVR0TBAUwAwEB/zAKBggqhkjOPQQDAiNOAyQAMEYCIQCp0iIX5s30KXjihR4g
+KnJpd3seqGlVRqCVgrD0KGYDJgA1QAIhAKkx0vR82QU0NtHDD11KX/LuQF2T+2nX
+oeKp5LKAbMVi
+-----END CERTIFICATE-----
+)";
 
 // kConstructedOctetString is an X.509 certificate where an extension is encoded
 // as a BER constructed OCTET STRING.
-// static const char kConstructedOctetString[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIBJDCByqADAgECAgIE0jAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDEwRUZXN0MCAX
-// DTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRUZXN0
-// MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdrt6ke
-// DUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMUMBIw
-// EAYDVR0TJAkEAzADAQQCAf8wCgYIKoZIzj0EAwIDSQAwRgIhAKnSIhfmzfQpeOKF
-// HiAqcml3ex6oaVVGoJWCsPQoZjVAAiEAqTHS9HzZBTQ20cMPXUpf8u5AXZP7adeh
-// 4qnksoBsxWI=
-// -----END CERTIFICATE-----
-// )";
+static const char kConstructedOctetString[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIBJDCByqADAgECAgIE0jAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDEwRUZXN0MCAX
+DTAwMDEwMTAwMDAwMFoYDzIxMDAwMTAxMDAwMDAwWjAPMQ0wCwYDVQQDEwRUZXN0
+MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5itp4r9ln5e+Lx4NlIpM1Zdrt6ke
+DUb73ampHp3culoB59aXqAoY+cPEox5W4nyDSNsWGhz1HX7xlC1Lz3IiwaMUMBIw
+EAYDVR0TJAkEAzADAQQCAf8wCgYIKoZIzj0EAwIDSQAwRgIhAKnSIhfmzfQpeOKF
+HiAqcml3ex6oaVVGoJWCsPQoZjVAAiEAqTHS9HzZBTQ20cMPXUpf8u5AXZP7adeh
+4qnksoBsxWI=
+-----END CERTIFICATE-----
+)";
 
 // kIndefiniteLength is an X.509 certificate where the outermost SEQUENCE uses
 // BER indefinite-length encoding.
-// static const char kIndefiniteLength[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIAwgcagAwIBAgICBNIwCgYIKoZIzj0EAwIwDzENMAsGA1UEAxMEVGVzdDAgFw0w
-// MDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsGA1UEAxMEVGVzdDBZ
-// MBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8eDZSKTNWXa7epHg1G
-// +92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQtS89yIsGjEDAOMAwG
-// A1UdEwQFMAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhAKnSIhfmzfQpeOKFHiAqcml3
-// ex6oaVVGoJWCsPQoZjVAAiEAqTHS9HzZBTQ20cMPXUpf8u5AXZP7adeh4qnksoBs
-// xWIAAA==
-// -----END CERTIFICATE-----
-// )";
+static const char kIndefiniteLength[] = R"(
+-----BEGIN CERTIFICATE-----
+MIAwgcagAwIBAgICBNIwCgYIKoZIzj0EAwIwDzENMAsGA1UEAxMEVGVzdDAgFw0w
+MDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsGA1UEAxMEVGVzdDBZ
+MBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8eDZSKTNWXa7epHg1G
++92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQtS89yIsGjEDAOMAwG
+A1UdEwQFMAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhAKnSIhfmzfQpeOKFHiAqcml3
+ex6oaVVGoJWCsPQoZjVAAiEAqTHS9HzZBTQ20cMPXUpf8u5AXZP7adeh4qnksoBs
+xWIAAA==
+-----END CERTIFICATE-----
+)";
 
 // kNonZeroPadding is an X.09 certificate where the BIT STRING signature field
 // has non-zero padding values.
-// static const char kNonZeroPadding[] = R"(
-// -----BEGIN CERTIFICATE-----
-// MIIB0DCCAXagAwIBAgIJANlMBNpJfb/rMAkGByqGSM49BAEwRTELMAkGA1UEBhMC
-// QVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVybmV0IFdpZGdp
-// dHMgUHR5IEx0ZDAeFw0xNDA0MjMyMzIxNTdaFw0xNDA1MjMyMzIxNTdaMEUxCzAJ
-// BgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5l
-// dCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATmK2ni
-// v2Wfl74vHg2UikzVl2u3qR4NRvvdqakendy6WgHn1peoChj5w8SjHlbifINI2xYa
-// HPUdfvGULUvPciLBo1AwTjAdBgNVHQ4EFgQUq4TSrKuV8IJOFngHVVdf5CaNgtEw
-// HwYDVR0jBBgwFoAUq4TSrKuV8IJOFngHVVdf5CaNgtEwDAYDVR0TBAUwAwEB/zAJ
-// BgcqhkjOPQQBA0kBMEUCIQDyoDVeUTo2w4J5m+4nUIWOcAZ0lVfSKXQA9L4Vh13E
-// BwIgfB55FGohg/B6dGh5XxSZmmi08cueFV7mHzJSYV51yRQB
-// -----END CERTIFICATE-----
-// )";
+static const char kNonZeroPadding[] = R"(
+-----BEGIN CERTIFICATE-----
+MIIB0DCCAXagAwIBAgIJANlMBNpJfb/rMAkGByqGSM49BAEwRTELMAkGA1UEBhMC
+QVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVybmV0IFdpZGdp
+dHMgUHR5IEx0ZDAeFw0xNDA0MjMyMzIxNTdaFw0xNDA1MjMyMzIxNTdaMEUxCzAJ
+BgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5l
+dCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATmK2ni
+v2Wfl74vHg2UikzVl2u3qR4NRvvdqakendy6WgHn1peoChj5w8SjHlbifINI2xYa
+HPUdfvGULUvPciLBo1AwTjAdBgNVHQ4EFgQUq4TSrKuV8IJOFngHVVdf5CaNgtEw
+HwYDVR0jBBgwFoAUq4TSrKuV8IJOFngHVVdf5CaNgtEwDAYDVR0TBAUwAwEB/zAJ
+BgcqhkjOPQQBA0kBMEUCIQDyoDVeUTo2w4J5m+4nUIWOcAZ0lVfSKXQA9L4Vh13E
+BwIgfB55FGohg/B6dGh5XxSZmmi08cueFV7mHzJSYV51yRQB
+-----END CERTIFICATE-----
+)";
 
 // kHighTagNumber is an X.509 certificate where the outermost SEQUENCE tag uses
 // high tag number form.
-// static const char kHighTagNumber[] = R"(
-// -----BEGIN CERTIFICATE-----
-// PxCCASAwgcagAwIBAgICBNIwCgYIKoZIzj0EAwIwDzENMAsGA1UEAxMEVGVzdDAg
-// Fw0wMDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsGA1UEAxMEVGVz
-// dDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8eDZSKTNWXa7ep
-// Hg1G+92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQtS89yIsGjEDAO
-// MAwGA1UdEwQFMAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhAKnSIhfmzfQpeOKFHiAq
-// cml3ex6oaVVGoJWCsPQoZjVAAiEAqTHS9HzZBTQ20cMPXUpf8u5AXZP7adeh4qnk
-// soBsxWI=
-// -----END CERTIFICATE-----
-// )";
-
-// TEST(X509Test, BER) {
-//   // Constructed strings are forbidden in DER.
-//   EXPECT_FALSE(CertFromPEM(kConstructedBitString));
-//   EXPECT_FALSE(CertFromPEM(kConstructedOctetString));
-//   // Indefinite lengths are forbidden in DER.
-//   EXPECT_FALSE(CertFromPEM(kIndefiniteLength));
-//   // Padding bits in BIT STRINGs must be zero in BER.
-//   EXPECT_FALSE(CertFromPEM(kNonZeroPadding));
-//   // Tags must be minimal in both BER and DER, though many BER decoders
-//   // incorrectly support non-minimal tags.
-//   EXPECT_FALSE(CertFromPEM(kHighTagNumber));
-// }
+static const char kHighTagNumber[] = R"(
+-----BEGIN CERTIFICATE-----
+PxCCASAwgcagAwIBAgICBNIwCgYIKoZIzj0EAwIwDzENMAsGA1UEAxMEVGVzdDAg
+Fw0wMDAxMDEwMDAwMDBaGA8yMTAwMDEwMTAwMDAwMFowDzENMAsGA1UEAxMEVGVz
+dDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOYraeK/ZZ+Xvi8eDZSKTNWXa7ep
+Hg1G+92pqR6d3LpaAefWl6gKGPnDxKMeVuJ8g0jbFhoc9R1+8ZQtS89yIsGjEDAO
+MAwGA1UdEwQFMAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhAKnSIhfmzfQpeOKFHiAq
+cml3ex6oaVVGoJWCsPQoZjVAAiEAqTHS9HzZBTQ20cMPXUpf8u5AXZP7adeh4qnk
+soBsxWI=
+-----END CERTIFICATE-----
+)";
+
+TEST(X509Test, BER) {
+#ifdef BSSL_COMPAT
+  GTEST_SKIP() << "TODO: Investigate failures on BSSL_COMPAT";
+#endif
+  // Constructed strings are forbidden in DER.
+  EXPECT_FALSE(CertFromPEM(kConstructedBitString));
+  EXPECT_FALSE(CertFromPEM(kConstructedOctetString));
+  // Indefinite lengths are forbidden in DER.
+  EXPECT_FALSE(CertFromPEM(kIndefiniteLength));
+  // Padding bits in BIT STRINGs must be zero in BER.
+  EXPECT_FALSE(CertFromPEM(kNonZeroPadding));
+  // Tags must be minimal in both BER and DER, though many BER decoders
+  // incorrectly support non-minimal tags.
+  EXPECT_FALSE(CertFromPEM(kHighTagNumber));
+}
 
 // TEST(X509Test, Names) {
 //   bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
