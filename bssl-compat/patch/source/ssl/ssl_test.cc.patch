--- a/source/ssl/ssl_test.cc
+++ b/source/ssl/ssl_test.cc
@@ -23,7 +23,6 @@
 #include <utility>
 #include <vector>
 
-#include <gmock/gmock.h>
 #include <gtest/gtest.h>
 
 #include <openssl/aead.h>
@@ -84,13 +83,19 @@
 static const size_t kTicketKeyLen = 48;
 
 static const VersionParam kAllVersions[] = {
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports TLS 1.0 or TLS1.1
     {TLS1_VERSION, VersionParam::is_tls, "TLS1"},
     {TLS1_1_VERSION, VersionParam::is_tls, "TLS1_1"},
+#endif    
     {TLS1_2_VERSION, VersionParam::is_tls, "TLS1_2"},
     {TLS1_3_VERSION, VersionParam::is_tls, "TLS1_3"},
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports DTLS 1.0
     {DTLS1_VERSION, VersionParam::is_dtls, "DTLS1"},
+#endif
     {DTLS1_2_VERSION, VersionParam::is_dtls, "DTLS1_2"},
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION    
     {DTLS1_3_VERSION, VersionParam::is_dtls, "DTLS1_3"},
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
 };
 
 struct ExpectedCipher {
@@ -984,6 +989,7 @@
     int auth_nid;
     int prf_nid;
   } kTests[] = {
+#ifdef SSL3_CK_RSA_DES_192_CBC3_SHA
       {
           SSL3_CK_RSA_DES_192_CBC3_SHA,
           "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
@@ -993,6 +999,7 @@
           NID_auth_rsa,
           NID_md5_sha1,
       },
+#endif
       {
           TLS1_CK_RSA_WITH_AES_128_SHA,
           "TLS_RSA_WITH_AES_128_CBC_SHA",
@@ -1540,7 +1547,11 @@
     if (client_err != SSL_ERROR_NONE &&        //
         client_err != SSL_ERROR_WANT_READ &&   //
         client_err != SSL_ERROR_WANT_WRITE &&  //
+#ifdef SSL_ERROR_PENDING_TICKET   
         client_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif      
       fprintf(stderr, "Client error: %s\n", SSL_error_description(client_err));
       return false;
     }
@@ -1550,7 +1561,11 @@
     if (server_err != SSL_ERROR_NONE &&        //
         server_err != SSL_ERROR_WANT_READ &&   //
         server_err != SSL_ERROR_WANT_WRITE &&  //
+#ifdef SSL_ERROR_PENDING_TICKET         
         server_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif
       fprintf(stderr, "Server error: %s\n", SSL_error_description(server_err));
       return false;
     }
@@ -1639,7 +1654,12 @@
     return false;
   }
   if (config.early_data) {
+#ifndef BSSL_COMPAT
     SSL_set_early_data_enabled(client.get(), 1);
+#else
+    std::cout << "WARNING: Skipped SSL_set_early_data_enabled()" << std::endl;
+    return false;
+#endif
   }
   if (config.session) {
     SSL_set_session(client.get(), config.session);
@@ -1649,18 +1669,29 @@
     return false;
   }
   if (!config.verify_hostname.empty()) {
+#ifndef BSSL_COMPAT
     if (!SSL_set1_host(client.get(), config.verify_hostname.c_str())) {
       return false;
     }
     SSL_set_hostflags(client.get(), config.hostflags);
+#else
+    std::cout << "WARNING: Skipped SSL_set1_host() & SSL_set_hostflags()" << std::endl;
+    return false;
+#endif
   }
 
   if (config.ca_names) {
     SSL_set0_CA_names(client.get(), config.ca_names);
   }
 
+#ifndef BSSL_COMPAT
   SSL_set_shed_handshake_config(client.get(), shed_handshake_config);
   SSL_set_shed_handshake_config(server.get(), shed_handshake_config);
+#else
+  if(shed_handshake_config) {
+    std::cout << "WARNING: Skipped SSL_set_shed_handshake_config()" << std::endl;
+  }
+#endif
 
   if (!CompleteHandshakes(client.get(), server.get())) {
     return false;
@@ -3518,12 +3549,15 @@
   // However, for historical reasons, the X509 chain includes the leaf on the
   // client, but does not on the server.
   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(client_.get())), 1u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(client_.get())),
             1u);
-
+#endif
   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(server_.get())), 0u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this  
   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(server_.get())),
             1u);
+#endif
 }
 
 TEST_P(SSLVersionTest, NoPeerCertificate) {
@@ -3536,7 +3570,9 @@
   // Server should not see a peer certificate.
   bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
   ASSERT_FALSE(peer);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   ASSERT_FALSE(SSL_get0_peer_certificates(server_.get()));
+#endif
 }
 
 TEST_P(SSLVersionTest, RetainOnlySHA256OfCerts) {
@@ -4228,7 +4264,11 @@
   ASSERT_TRUE(CreateClientAndServer(&client_, &server_, client_ctx_.get(),
                                     server_ctx_.get()));
   // Before the handshake, |SSL_version| reports some placeholder value.
-  const uint16_t placeholder = is_dtls() ? DTLS1_2_VERSION : TLS1_2_VERSION;
+#ifdef BSSL_COMPAT // Default versions are different when running on OpenSSL
+  const uint16_t placeholder = is_dtls() ? DTLS1_2_VERSION : TLS1_3_VERSION;
+#else
+  const uint16_t placeholder = is_dtls() ? DTLS1_3_VERSION : TLS1_3_VERSION;
+#endif
   EXPECT_EQ(SSL_version(client_.get()), placeholder);
   EXPECT_EQ(SSL_version(server_.get()), placeholder);
 
