--- a/source/ssl/ssl_test.cc
+++ b/source/ssl/ssl_test.cc
@@ -12,56 +12,60 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
-// #include <stdio.h>
-// #include <string.h>
-// #include <time.h>
-
-// #include <algorithm>
-// #include <limits>
-// #include <string>
-// #include <utility>
-// #include <vector>
-
-// #include <gtest/gtest.h>
-
-// #include <openssl/aead.h>
-// #include <openssl/base64.h>
-// #include <openssl/bytestring.h>
-// #include <openssl/bio.h>
-// #include <openssl/cipher.h>
-// #include <openssl/crypto.h>
-// #include <openssl/curve25519.h>
-// #include <openssl/err.h>
-// #include <openssl/hmac.h>
-// #include <openssl/hpke.h>
-// #include <openssl/pem.h>
-// #include <openssl/sha.h>
-// #include <openssl/ssl.h>
-// #include <openssl/rand.h>
-// #include <openssl/x509.h>
-// #include <openssl/x509v3.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+
+#include <algorithm>
+#include <limits>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <gtest/gtest.h>
+
+#include <openssl/aead.h>
+#include <openssl/base64.h>
+#include <openssl/bytestring.h>
+#include <openssl/bio.h>
+#include <openssl/cipher.h>
+#include <openssl/crypto.h>
+#include <openssl/curve25519.h>
+#include <openssl/err.h>
+#include <openssl/hmac.h>
+#include <openssl/hpke.h>
+#include <openssl/pem.h>
+#include <openssl/sha.h>
+#include <openssl/ssl.h>
+#include <openssl/rand.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
 
 // #include "internal.h"
 // #include "../crypto/internal.h"
-// #include "../crypto/test/test_util.h"
+#include "../crypto/test/test_util.h"
 
-// #if defined(OPENSSL_WINDOWS)
+#ifdef BSSL_COMPAT
+#include <ossl/openssl/ssl.h>
+#endif
+
+#if defined(OPENSSL_WINDOWS)
 // Windows defines struct timeval in winsock2.h.
-// OPENSSL_MSVC_PRAGMA(warning(push, 3))
-// #include <winsock2.h>
-// OPENSSL_MSVC_PRAGMA(warning(pop))
-// #else
-// #include <sys/time.h>
-// #endif
+OPENSSL_MSVC_PRAGMA(warning(push, 3))
+#include <winsock2.h>
+OPENSSL_MSVC_PRAGMA(warning(pop))
+#else
+#include <sys/time.h>
+#endif
 
-// #if defined(OPENSSL_THREADS)
-// #include <thread>
-// #endif
+#if defined(OPENSSL_THREADS)
+#include <thread>
+#endif
 
 
-// BSSL_NAMESPACE_BEGIN
+BSSL_NAMESPACE_BEGIN
 
-// namespace {
+namespace {
 
 // #define TRACED_CALL(code)                     \
 //   do {                                        \
@@ -1196,14 +1200,14 @@
 //   }
 // }
 
-// static bssl::UniquePtr<X509> CertFromPEM(const char *pem) {
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
-//   if (!bio) {
-//     return nullptr;
-//   }
-//   return bssl::UniquePtr<X509>(
-//       PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
-// }
+static bssl::UniquePtr<X509> CertFromPEM(const char *pem) {
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
+  if (!bio) {
+    return nullptr;
+  }
+  return bssl::UniquePtr<X509>(
+      PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
+}
 
 // static bssl::UniquePtr<EVP_PKEY> KeyFromPEM(const char *pem) {
 //   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
@@ -1214,25 +1218,25 @@
 //       PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
 // }
 
-// static bssl::UniquePtr<X509> GetTestCertificate() {
-//   static const char kCertPEM[] =
-//       "-----BEGIN CERTIFICATE-----\n"
-//       "MIICWDCCAcGgAwIBAgIJAPuwTC6rEJsMMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n"
-//       "BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n"
-//       "aWRnaXRzIFB0eSBMdGQwHhcNMTQwNDIzMjA1MDQwWhcNMTcwNDIyMjA1MDQwWjBF\n"
-//       "MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n"
-//       "ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n"
-//       "gQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92kWdGMdAQhLci\n"
-//       "HnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiFKKAnHmUcrgfV\n"
-//       "W28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQABo1AwTjAdBgNV\n"
-//       "HQ4EFgQUi3XVrMsIvg4fZbf6Vr5sp3Xaha8wHwYDVR0jBBgwFoAUi3XVrMsIvg4f\n"
-//       "Zbf6Vr5sp3Xaha8wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQA76Hht\n"
-//       "ldY9avcTGSwbwoiuIqv0jTL1fHFnzy3RHMLDh+Lpvolc5DSrSJHCP5WuK0eeJXhr\n"
-//       "T5oQpHL9z/cCDLAKCKRa4uV0fhEdOWBqyR9p8y5jJtye72t6CuFUV5iqcpF4BH4f\n"
-//       "j2VNHwsSrJwkD4QUGlUtH7vwnQmyCFxZMmWAJg==\n"
-//       "-----END CERTIFICATE-----\n";
-//   return CertFromPEM(kCertPEM);
-// }
+static bssl::UniquePtr<X509> GetTestCertificate() {
+  static const char kCertPEM[] =
+      "-----BEGIN CERTIFICATE-----\n"
+      "MIICWDCCAcGgAwIBAgIJAPuwTC6rEJsMMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n"
+      "BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n"
+      "aWRnaXRzIFB0eSBMdGQwHhcNMTQwNDIzMjA1MDQwWhcNMTcwNDIyMjA1MDQwWjBF\n"
+      "MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n"
+      "ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n"
+      "gQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92kWdGMdAQhLci\n"
+      "HnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiFKKAnHmUcrgfV\n"
+      "W28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQABo1AwTjAdBgNV\n"
+      "HQ4EFgQUi3XVrMsIvg4fZbf6Vr5sp3Xaha8wHwYDVR0jBBgwFoAUi3XVrMsIvg4f\n"
+      "Zbf6Vr5sp3Xaha8wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQA76Hht\n"
+      "ldY9avcTGSwbwoiuIqv0jTL1fHFnzy3RHMLDh+Lpvolc5DSrSJHCP5WuK0eeJXhr\n"
+      "T5oQpHL9z/cCDLAKCKRa4uV0fhEdOWBqyR9p8y5jJtye72t6CuFUV5iqcpF4BH4f\n"
+      "j2VNHwsSrJwkD4QUGlUtH7vwnQmyCFxZMmWAJg==\n"
+      "-----END CERTIFICATE-----\n";
+  return CertFromPEM(kCertPEM);
+}
 
 // static bssl::UniquePtr<EVP_PKEY> GetTestKey() {
 //   static const char kKeyPEM[] =
@@ -4214,43 +4218,46 @@
 //   X509_cmp(cert, cert);
 // }
 
-// TEST(SSLTest, GetCertificate) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-//   bssl::UniquePtr<X509> cert = GetTestCertificate();
-//   ASSERT_TRUE(cert);
-//   ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
-//   bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
-//   ASSERT_TRUE(ssl);
-
-//   X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
-//   ASSERT_TRUE(cert2);
-//   X509 *cert3 = SSL_get_certificate(ssl.get());
-//   ASSERT_TRUE(cert3);
-
-//   // The old and new certificates must be identical.
-//   EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
-//   EXPECT_EQ(0, X509_cmp(cert.get(), cert3));
-
-//   uint8_t *der = nullptr;
-//   long der_len = i2d_X509(cert.get(), &der);
-//   ASSERT_LT(0, der_len);
-//   bssl::UniquePtr<uint8_t> free_der(der);
-
-//   uint8_t *der2 = nullptr;
-//   long der2_len = i2d_X509(cert2, &der2);
-//   ASSERT_LT(0, der2_len);
-//   bssl::UniquePtr<uint8_t> free_der2(der2);
-
-//   uint8_t *der3 = nullptr;
-//   long der3_len = i2d_X509(cert3, &der3);
-//   ASSERT_LT(0, der3_len);
-//   bssl::UniquePtr<uint8_t> free_der3(der3);
-
-//   // They must also encode identically.
-//   EXPECT_EQ(Bytes(der, der_len), Bytes(der2, der2_len));
-//   EXPECT_EQ(Bytes(der, der_len), Bytes(der3, der3_len));
-// }
+TEST(SSLTest, GetCertificate) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+  bssl::UniquePtr<X509> cert = GetTestCertificate();
+  ASSERT_TRUE(cert);
+#ifdef BSSL_COMPAT
+  ossl_SSL_CTX_set_security_level(ctx.get(), 1);
+#endif
+  ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
+  bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
+  ASSERT_TRUE(ssl);
+
+  X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
+  ASSERT_TRUE(cert2);
+  X509 *cert3 = SSL_get_certificate(ssl.get());
+  ASSERT_TRUE(cert3);
+
+  // The old and new certificates must be identical.
+  EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
+  EXPECT_EQ(0, X509_cmp(cert.get(), cert3));
+
+  uint8_t *der = nullptr;
+  long der_len = i2d_X509(cert.get(), &der);
+  ASSERT_LT(0, der_len);
+  bssl::UniquePtr<uint8_t> free_der(der);
+
+  uint8_t *der2 = nullptr;
+  long der2_len = i2d_X509(cert2, &der2);
+  ASSERT_LT(0, der2_len);
+  bssl::UniquePtr<uint8_t> free_der2(der2);
+
+  uint8_t *der3 = nullptr;
+  long der3_len = i2d_X509(cert3, &der3);
+  ASSERT_LT(0, der3_len);
+  bssl::UniquePtr<uint8_t> free_der3(der3);
+
+  // They must also encode identically.
+  EXPECT_EQ(Bytes(der, der_len), Bytes(der2, der2_len));
+  EXPECT_EQ(Bytes(der, der_len), Bytes(der3, der3_len));
+}
 
 // TEST(SSLTest, SetChainAndKeyMismatch) {
 //   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_with_buffers_method()));
@@ -4920,33 +4927,37 @@
 // }
 
 // The client should gracefully handle no suitable ciphers being enabled.
-// TEST(SSLTest, NoCiphersAvailable) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-
-//   // Configure |client_ctx| with a cipher list that does not intersect with its
-//   // version configuration.
-//   ASSERT_TRUE(SSL_CTX_set_strict_cipher_list(
-//       ctx.get(), "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"));
-//   ASSERT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), TLS1_1_VERSION));
-
-//   bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
-//   ASSERT_TRUE(ssl);
-//   SSL_set_connect_state(ssl.get());
-
-//   UniquePtr<BIO> rbio(BIO_new(BIO_s_mem())), wbio(BIO_new(BIO_s_mem()));
-//   ASSERT_TRUE(rbio);
-//   ASSERT_TRUE(wbio);
-//   SSL_set0_rbio(ssl.get(), rbio.release());
-//   SSL_set0_wbio(ssl.get(), wbio.release());
-
-//   int ret = SSL_do_handshake(ssl.get());
-//   EXPECT_EQ(-1, ret);
-//   EXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(ssl.get(), ret));
-//   uint32_t err = ERR_get_error();
-//   EXPECT_EQ(ERR_LIB_SSL, ERR_GET_LIB(err));
-//   EXPECT_EQ(SSL_R_NO_CIPHERS_AVAILABLE, ERR_GET_REASON(err));
-// }
+TEST(SSLTest, NoCiphersAvailable) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+
+  // Configure |client_ctx| with a cipher list that does not intersect with its
+  // version configuration.
+  ASSERT_TRUE(SSL_CTX_set_strict_cipher_list(
+      ctx.get(), "ECDHE-RSA-AES128-GCM-SHA256"));
+  ASSERT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), TLS1_1_VERSION));
+
+  bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
+  ASSERT_TRUE(ssl);
+  SSL_set_connect_state(ssl.get());
+
+  UniquePtr<BIO> rbio(BIO_new(BIO_s_mem())), wbio(BIO_new(BIO_s_mem()));
+  ASSERT_TRUE(rbio);
+  ASSERT_TRUE(wbio);
+  SSL_set0_rbio(ssl.get(), rbio.release());
+  SSL_set0_wbio(ssl.get(), wbio.release());
+
+  int ret = SSL_do_handshake(ssl.get());
+  EXPECT_EQ(-1, ret);
+  EXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(ssl.get(), ret));
+  uint32_t err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_SSL, ERR_GET_LIB(err));
+#ifdef BSSL_COMPAT
+  EXPECT_EQ(ossl_SSL_R_NO_PROTOCOLS_AVAILABLE, ERR_GET_REASON(err));
+#else
+  EXPECT_EQ(SSL_R_NO_CIPHERS_AVAILABLE, ERR_GET_REASON(err));
+#endif
+}
 
 // TEST_P(SSLVersionTest, SessionVersion) {
 //   SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
@@ -5721,25 +5732,28 @@
 // }
 
 // SSL_CTX_get0_certificate needs to lock internally. Test this works.
-// TEST(SSLTest, GetCertificateThreads) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-//   bssl::UniquePtr<X509> cert = GetTestCertificate();
-//   ASSERT_TRUE(cert);
-//   ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
-
-//   // Existing code expects |SSL_CTX_get0_certificate| to be callable from two
-//   // threads concurrently. It originally was an immutable operation. Now we
-//   // implement it with a thread-safe cache, so it is worth testing.
-//   X509 *cert2_thread;
-//   std::thread thread(
-//       [&] { cert2_thread = SSL_CTX_get0_certificate(ctx.get()); });
-//   X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
-//   thread.join();
-
-//   EXPECT_EQ(cert2, cert2_thread);
-//   EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
-// }
+TEST(SSLTest, GetCertificateThreads) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+#ifdef BSSL_COMPAT
+  ossl_SSL_CTX_set_security_level(ctx.get(), 1);
+#endif
+  bssl::UniquePtr<X509> cert = GetTestCertificate();
+  ASSERT_TRUE(cert);
+  ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
+
+  // Existing code expects |SSL_CTX_get0_certificate| to be callable from two
+  // threads concurrently. It originally was an immutable operation. Now we
+  // implement it with a thread-safe cache, so it is worth testing.
+  X509 *cert2_thread;
+  std::thread thread(
+      [&] { cert2_thread = SSL_CTX_get0_certificate(ctx.get()); });
+  X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
+  thread.join();
+
+  EXPECT_EQ(cert2, cert2_thread);
+  EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
+}
 
 // Functions which access properties on the negotiated session are thread-safe
 // where needed. Prior to TLS 1.3, clients resuming sessions and servers
@@ -8260,5 +8274,5 @@
 //   }
 // }
 
-// }  // namespace
-// BSSL_NAMESPACE_END
+}  // namespace
+BSSL_NAMESPACE_END
