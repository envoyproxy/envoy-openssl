--- a/source/ssl/ssl_test.cc
+++ b/source/ssl/ssl_test.cc
@@ -12,82 +12,91 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
 
-// #include <stdio.h>
-// #include <string.h>
-// #include <time.h>
-
-// #include <algorithm>
-// #include <limits>
-// #include <string>
-// #include <utility>
-// #include <vector>
-
-// #include <gtest/gtest.h>
-
-// #include <openssl/aead.h>
-// #include <openssl/base64.h>
-// #include <openssl/bytestring.h>
-// #include <openssl/bio.h>
-// #include <openssl/cipher.h>
-// #include <openssl/crypto.h>
-// #include <openssl/curve25519.h>
-// #include <openssl/err.h>
-// #include <openssl/hmac.h>
-// #include <openssl/hpke.h>
-// #include <openssl/pem.h>
-// #include <openssl/sha.h>
-// #include <openssl/ssl.h>
-// #include <openssl/rand.h>
-// #include <openssl/x509.h>
-// #include <openssl/x509v3.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+
+#include <algorithm>
+#include <limits>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <gtest/gtest.h>
+
+#include <openssl/aead.h>
+#include <openssl/base64.h>
+#include <openssl/bytestring.h>
+#include <openssl/bio.h>
+#include <openssl/cipher.h>
+#include <openssl/crypto.h>
+#include <openssl/curve25519.h>
+#include <openssl/err.h>
+#include <openssl/hmac.h>
+#include <openssl/hpke.h>
+#include <openssl/pem.h>
+#include <openssl/sha.h>
+#include <openssl/ssl.h>
+#include <openssl/rand.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
 
 // #include "internal.h"
 // #include "../crypto/internal.h"
-// #include "../crypto/test/test_util.h"
+#include "../crypto/test/test_util.h"
 
-// #if defined(OPENSSL_WINDOWS)
-// Windows defines struct timeval in winsock2.h.
-// OPENSSL_MSVC_PRAGMA(warning(push, 3))
-// #include <winsock2.h>
-// OPENSSL_MSVC_PRAGMA(warning(pop))
-// #else
-// #include <sys/time.h>
-// #endif
-
-// #if defined(OPENSSL_THREADS)
-// #include <thread>
-// #endif
+#ifdef BSSL_COMPAT
+#include <ossl/openssl/ssl.h>
+#include <ossl/openssl/provider.h>
+#endif
 
-
-// BSSL_NAMESPACE_BEGIN
-
-// namespace {
-
-// #define TRACED_CALL(code)                     \
-//   do {                                        \
-//     SCOPED_TRACE("<- called from here");      \
-//     code;                                     \
-//     if (::testing::Test::HasFatalFailure()) { \
-//       return;                                 \
-//     }                                         \
-//   } while (false)
-
-// struct VersionParam {
-//   uint16_t version;
-//   enum { is_tls, is_dtls } ssl_method;
-//   const char name[8];
-// };
+#if defined(OPENSSL_WINDOWS)
+// Windows defines struct timeval in winsock2.h.
+OPENSSL_MSVC_PRAGMA(warning(push, 3))
+#include <winsock2.h>
+OPENSSL_MSVC_PRAGMA(warning(pop))
+#else
+#include <sys/time.h>
+#endif
+
+#if defined(OPENSSL_THREADS)
+#include <thread>
+#endif
+
+
+BSSL_NAMESPACE_BEGIN
+
+namespace {
+
+#define TRACED_CALL(code)                     \
+  do {                                        \
+    SCOPED_TRACE("<- called from here");      \
+    code;                                     \
+    if (::testing::Test::HasFatalFailure()) { \
+      return;                                 \
+    }                                         \
+  } while (false)
+
+struct VersionParam {
+  uint16_t version;
+  enum { is_tls, is_dtls } ssl_method;
+  const char name[8];
+};
 
 // static const size_t kTicketKeyLen = 48;
 
-// static const VersionParam kAllVersions[] = {
-//     {TLS1_VERSION, VersionParam::is_tls, "TLS1"},
-//     {TLS1_1_VERSION, VersionParam::is_tls, "TLS1_1"},
-//     {TLS1_2_VERSION, VersionParam::is_tls, "TLS1_2"},
-//     {TLS1_3_VERSION, VersionParam::is_tls, "TLS1_3"},
-//     {DTLS1_VERSION, VersionParam::is_dtls, "DTLS1"},
-//     {DTLS1_2_VERSION, VersionParam::is_dtls, "DTLS1_2"},
-// };
+static const VersionParam kAllVersions[] = {
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports TLS 1.0 or TLS1.1
+    {TLS1_VERSION, VersionParam::is_tls, "TLS1"},
+    {TLS1_1_VERSION, VersionParam::is_tls, "TLS1_1"},
+#endif
+    {TLS1_2_VERSION, VersionParam::is_tls, "TLS1_2"},
+    {TLS1_3_VERSION, VersionParam::is_tls, "TLS1_3"},
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports DTLS 1.0
+    {DTLS1_VERSION, VersionParam::is_dtls, "DTLS1"},
+#endif
+    {DTLS1_2_VERSION, VersionParam::is_dtls, "DTLS1_2"},
+};
 
 // struct ExpectedCipher {
 //   unsigned long id;
@@ -110,25 +119,25 @@
 //   std::vector<uint16_t> expected;
 // };
 
-// template <typename T>
-// class UnownedSSLExData {
-//  public:
-//   UnownedSSLExData() {
-//     index_ = SSL_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
-//   }
-
-//   T *Get(const SSL *ssl) {
-//     return index_ < 0 ? nullptr
-//                       : static_cast<T *>(SSL_get_ex_data(ssl, index_));
-//   }
-
-//   bool Set(SSL *ssl, T *t) {
-//     return index_ >= 0 && SSL_set_ex_data(ssl, index_, t);
-//   }
-
-//  private:
-//   int index_;
-// };
+template <typename T>
+class UnownedSSLExData {
+ public:
+  UnownedSSLExData() {
+    index_ = SSL_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);
+  }
+
+  T *Get(const SSL *ssl) {
+    return index_ < 0 ? nullptr
+                      : static_cast<T *>(SSL_get_ex_data(ssl, index_));
+  }
+
+  bool Set(SSL *ssl, T *t) {
+    return index_ >= 0 && SSL_set_ex_data(ssl, index_, t);
+  }
+
+ private:
+  int index_;
+};
 
 // static const CipherTest kCipherTests[] = {
 //     // Selecting individual ciphers should work.
@@ -1196,63 +1205,63 @@
 //   }
 // }
 
-// static bssl::UniquePtr<X509> CertFromPEM(const char *pem) {
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
-//   if (!bio) {
-//     return nullptr;
-//   }
-//   return bssl::UniquePtr<X509>(
-//       PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
-// }
-
-// static bssl::UniquePtr<EVP_PKEY> KeyFromPEM(const char *pem) {
-//   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
-//   if (!bio) {
-//     return nullptr;
-//   }
-//   return bssl::UniquePtr<EVP_PKEY>(
-//       PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
-// }
-
-// static bssl::UniquePtr<X509> GetTestCertificate() {
-//   static const char kCertPEM[] =
-//       "-----BEGIN CERTIFICATE-----\n"
-//       "MIICWDCCAcGgAwIBAgIJAPuwTC6rEJsMMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n"
-//       "BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n"
-//       "aWRnaXRzIFB0eSBMdGQwHhcNMTQwNDIzMjA1MDQwWhcNMTcwNDIyMjA1MDQwWjBF\n"
-//       "MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n"
-//       "ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n"
-//       "gQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92kWdGMdAQhLci\n"
-//       "HnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiFKKAnHmUcrgfV\n"
-//       "W28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQABo1AwTjAdBgNV\n"
-//       "HQ4EFgQUi3XVrMsIvg4fZbf6Vr5sp3Xaha8wHwYDVR0jBBgwFoAUi3XVrMsIvg4f\n"
-//       "Zbf6Vr5sp3Xaha8wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQA76Hht\n"
-//       "ldY9avcTGSwbwoiuIqv0jTL1fHFnzy3RHMLDh+Lpvolc5DSrSJHCP5WuK0eeJXhr\n"
-//       "T5oQpHL9z/cCDLAKCKRa4uV0fhEdOWBqyR9p8y5jJtye72t6CuFUV5iqcpF4BH4f\n"
-//       "j2VNHwsSrJwkD4QUGlUtH7vwnQmyCFxZMmWAJg==\n"
-//       "-----END CERTIFICATE-----\n";
-//   return CertFromPEM(kCertPEM);
-// }
-
-// static bssl::UniquePtr<EVP_PKEY> GetTestKey() {
-//   static const char kKeyPEM[] =
-//       "-----BEGIN RSA PRIVATE KEY-----\n"
-//       "MIICXgIBAAKBgQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92\n"
-//       "kWdGMdAQhLciHnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiF\n"
-//       "KKAnHmUcrgfVW28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQAB\n"
-//       "AoGBAIBy09Fd4DOq/Ijp8HeKuCMKTHqTW1xGHshLQ6jwVV2vWZIn9aIgmDsvkjCe\n"
-//       "i6ssZvnbjVcwzSoByhjN8ZCf/i15HECWDFFh6gt0P5z0MnChwzZmvatV/FXCT0j+\n"
-//       "WmGNB/gkehKjGXLLcjTb6dRYVJSCZhVuOLLcbWIV10gggJQBAkEA8S8sGe4ezyyZ\n"
-//       "m4e9r95g6s43kPqtj5rewTsUxt+2n4eVodD+ZUlCULWVNAFLkYRTBCASlSrm9Xhj\n"
-//       "QpmWAHJUkQJBAOVzQdFUaewLtdOJoPCtpYoY1zd22eae8TQEmpGOR11L6kbxLQsk\n"
-//       "aMly/DOnOaa82tqAGTdqDEZgSNmCeKKknmECQAvpnY8GUOVAubGR6c+W90iBuQLj\n"
-//       "LtFp/9ihd2w/PoDwrHZaoUYVcT4VSfJQog/k7kjE4MYXYWL8eEKg3WTWQNECQQDk\n"
-//       "104Wi91Umd1PzF0ijd2jXOERJU1wEKe6XLkYYNHWQAe5l4J4MWj9OdxFXAxIuuR/\n"
-//       "tfDwbqkta4xcux67//khAkEAvvRXLHTaa6VFzTaiiO8SaFsHV3lQyXOtMrBpB5jd\n"
-//       "moZWgjHvB2W9Ckn7sDqsPB+U2tyX0joDdQEyuiMECDY8oQ==\n"
-//       "-----END RSA PRIVATE KEY-----\n";
-//   return KeyFromPEM(kKeyPEM);
-// }
+static bssl::UniquePtr<X509> CertFromPEM(const char *pem) {
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
+  if (!bio) {
+    return nullptr;
+  }
+  return bssl::UniquePtr<X509>(
+      PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
+}
+
+static bssl::UniquePtr<EVP_PKEY> KeyFromPEM(const char *pem) {
+  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
+  if (!bio) {
+    return nullptr;
+  }
+  return bssl::UniquePtr<EVP_PKEY>(
+      PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr, nullptr));
+}
+
+static bssl::UniquePtr<X509> GetTestCertificate() {
+  static const char kCertPEM[] =
+      "-----BEGIN CERTIFICATE-----\n"
+      "MIICWDCCAcGgAwIBAgIJAPuwTC6rEJsMMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV\n"
+      "BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n"
+      "aWRnaXRzIFB0eSBMdGQwHhcNMTQwNDIzMjA1MDQwWhcNMTcwNDIyMjA1MDQwWjBF\n"
+      "MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n"
+      "ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n"
+      "gQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92kWdGMdAQhLci\n"
+      "HnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiFKKAnHmUcrgfV\n"
+      "W28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQABo1AwTjAdBgNV\n"
+      "HQ4EFgQUi3XVrMsIvg4fZbf6Vr5sp3Xaha8wHwYDVR0jBBgwFoAUi3XVrMsIvg4f\n"
+      "Zbf6Vr5sp3Xaha8wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQA76Hht\n"
+      "ldY9avcTGSwbwoiuIqv0jTL1fHFnzy3RHMLDh+Lpvolc5DSrSJHCP5WuK0eeJXhr\n"
+      "T5oQpHL9z/cCDLAKCKRa4uV0fhEdOWBqyR9p8y5jJtye72t6CuFUV5iqcpF4BH4f\n"
+      "j2VNHwsSrJwkD4QUGlUtH7vwnQmyCFxZMmWAJg==\n"
+      "-----END CERTIFICATE-----\n";
+  return CertFromPEM(kCertPEM);
+}
+
+static bssl::UniquePtr<EVP_PKEY> GetTestKey() {
+  static const char kKeyPEM[] =
+      "-----BEGIN RSA PRIVATE KEY-----\n"
+      "MIICXgIBAAKBgQDYK8imMuRi/03z0K1Zi0WnvfFHvwlYeyK9Na6XJYaUoIDAtB92\n"
+      "kWdGMdAQhLciHnAjkXLI6W15OoV3gA/ElRZ1xUpxTMhjP6PyY5wqT5r6y8FxbiiF\n"
+      "KKAnHmUcrgfVW28tQ+0rkLGMryRtrukXOgXBv7gcrmU7G1jC2a7WqmeI8QIDAQAB\n"
+      "AoGBAIBy09Fd4DOq/Ijp8HeKuCMKTHqTW1xGHshLQ6jwVV2vWZIn9aIgmDsvkjCe\n"
+      "i6ssZvnbjVcwzSoByhjN8ZCf/i15HECWDFFh6gt0P5z0MnChwzZmvatV/FXCT0j+\n"
+      "WmGNB/gkehKjGXLLcjTb6dRYVJSCZhVuOLLcbWIV10gggJQBAkEA8S8sGe4ezyyZ\n"
+      "m4e9r95g6s43kPqtj5rewTsUxt+2n4eVodD+ZUlCULWVNAFLkYRTBCASlSrm9Xhj\n"
+      "QpmWAHJUkQJBAOVzQdFUaewLtdOJoPCtpYoY1zd22eae8TQEmpGOR11L6kbxLQsk\n"
+      "aMly/DOnOaa82tqAGTdqDEZgSNmCeKKknmECQAvpnY8GUOVAubGR6c+W90iBuQLj\n"
+      "LtFp/9ihd2w/PoDwrHZaoUYVcT4VSfJQog/k7kjE4MYXYWL8eEKg3WTWQNECQQDk\n"
+      "104Wi91Umd1PzF0ijd2jXOERJU1wEKe6XLkYYNHWQAe5l4J4MWj9OdxFXAxIuuR/\n"
+      "tfDwbqkta4xcux67//khAkEAvvRXLHTaa6VFzTaiiO8SaFsHV3lQyXOtMrBpB5jd\n"
+      "moZWgjHvB2W9Ckn7sDqsPB+U2tyX0joDdQEyuiMECDY8oQ==\n"
+      "-----END RSA PRIVATE KEY-----\n";
+  return KeyFromPEM(kKeyPEM);
+}
 
 // static bssl::UniquePtr<SSL_CTX> CreateContextWithTestCertificate(
 //     const SSL_METHOD *method) {
@@ -1408,198 +1417,222 @@
 //   return KeyFromPEM(kKeyPEM);
 // }
 
-// static bool CompleteHandshakes(SSL *client, SSL *server) {
-//   // Drive both their handshakes to completion.
-//   for (;;) {
-//     int client_ret = SSL_do_handshake(client);
-//     int client_err = SSL_get_error(client, client_ret);
-//     if (client_err != SSL_ERROR_NONE &&
-//         client_err != SSL_ERROR_WANT_READ &&
-//         client_err != SSL_ERROR_WANT_WRITE &&
-//         client_err != SSL_ERROR_PENDING_TICKET) {
-//       fprintf(stderr, "Client error: %s\n", SSL_error_description(client_err));
-//       return false;
-//     }
-
-//     int server_ret = SSL_do_handshake(server);
-//     int server_err = SSL_get_error(server, server_ret);
-//     if (server_err != SSL_ERROR_NONE &&
-//         server_err != SSL_ERROR_WANT_READ &&
-//         server_err != SSL_ERROR_WANT_WRITE &&
-//         server_err != SSL_ERROR_PENDING_TICKET) {
-//       fprintf(stderr, "Server error: %s\n", SSL_error_description(server_err));
-//       return false;
-//     }
-
-//     if (client_ret == 1 && server_ret == 1) {
-//       break;
-//     }
-//   }
-
-//   return true;
-// }
-
-// static bool FlushNewSessionTickets(SSL *client, SSL *server) {
-//   // NewSessionTickets are deferred on the server to |SSL_write|, and clients do
-//   // not pick them up until |SSL_read|.
-//   for (;;) {
-//     int server_ret = SSL_write(server, nullptr, 0);
-//     int server_err = SSL_get_error(server, server_ret);
-//     // The server may either succeed (|server_ret| is zero) or block on write
-//     // (|server_ret| is -1 and |server_err| is |SSL_ERROR_WANT_WRITE|).
-//     if (server_ret > 0 ||
-//         (server_ret < 0 && server_err != SSL_ERROR_WANT_WRITE)) {
-//       fprintf(stderr, "Unexpected server result: %d %d\n", server_ret,
-//               server_err);
-//       return false;
-//     }
-
-//     int client_ret = SSL_read(client, nullptr, 0);
-//     int client_err = SSL_get_error(client, client_ret);
-//     // The client must always block on read.
-//     if (client_ret != -1 || client_err != SSL_ERROR_WANT_READ) {
-//       fprintf(stderr, "Unexpected client result: %d %d\n", client_ret,
-//               client_err);
-//       return false;
-//     }
-
-//     // The server flushed everything it had to write.
-//     if (server_ret == 0) {
-//       return true;
-//     }
-//   }
-// }
+static bool CompleteHandshakes(SSL *client, SSL *server) {
+  // Drive both their handshakes to completion.
+  for (;;) {
+    int client_ret = SSL_do_handshake(client);
+    int client_err = SSL_get_error(client, client_ret);
+    if (client_err != SSL_ERROR_NONE &&
+        client_err != SSL_ERROR_WANT_READ &&
+        client_err != SSL_ERROR_WANT_WRITE &&
+#ifdef SSL_ERROR_PENDING_TICKET
+        client_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif
+      fprintf(stderr, "Client error: %s\n", SSL_error_description(client_err));
+      return false;
+    }
+
+    int server_ret = SSL_do_handshake(server);
+    int server_err = SSL_get_error(server, server_ret);
+    if (server_err != SSL_ERROR_NONE &&
+        server_err != SSL_ERROR_WANT_READ &&
+        server_err != SSL_ERROR_WANT_WRITE &&
+#ifdef SSL_ERROR_PENDING_TICKET
+        server_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif
+      fprintf(stderr, "Server error: %s\n", SSL_error_description(server_err));
+      return false;
+    }
+
+    if (client_ret == 1 && server_ret == 1) {
+      break;
+    }
+  }
+
+  return true;
+}
+
+static bool FlushNewSessionTickets(SSL *client, SSL *server) {
+  // NewSessionTickets are deferred on the server to |SSL_write|, and clients do
+  // not pick them up until |SSL_read|.
+  for (;;) {
+    int server_ret = SSL_write(server, nullptr, 0);
+    int server_err = SSL_get_error(server, server_ret);
+    // The server may either succeed (|server_ret| is zero) or block on write
+    // (|server_ret| is -1 and |server_err| is |SSL_ERROR_WANT_WRITE|).
+    if (server_ret > 0 ||
+        (server_ret < 0 && server_err != SSL_ERROR_WANT_WRITE)) {
+      fprintf(stderr, "Unexpected server result: %d %d\n", server_ret,
+              server_err);
+      return false;
+    }
+
+    int client_ret = SSL_read(client, nullptr, 0);
+    int client_err = SSL_get_error(client, client_ret);
+    // The client must always block on read.
+    if (client_ret != -1 || client_err != SSL_ERROR_WANT_READ) {
+      fprintf(stderr, "Unexpected client result: %d %d\n", client_ret,
+              client_err);
+      return false;
+    }
+
+    // The server flushed everything it had to write.
+    if (server_ret == 0) {
+      return true;
+    }
+  }
+}
 
 // CreateClientAndServer creates a client and server |SSL| objects whose |BIO|s
 // are paired with each other. It does not run the handshake. The caller is
 // expected to configure the objects and drive the handshake as needed.
-// static bool CreateClientAndServer(bssl::UniquePtr<SSL> *out_client,
-//                                   bssl::UniquePtr<SSL> *out_server,
-//                                   SSL_CTX *client_ctx, SSL_CTX *server_ctx) {
-//   bssl::UniquePtr<SSL> client(SSL_new(client_ctx)), server(SSL_new(server_ctx));
-//   if (!client || !server) {
-//     return false;
-//   }
-//   SSL_set_connect_state(client.get());
-//   SSL_set_accept_state(server.get());
-
-//   BIO *bio1, *bio2;
-//   if (!BIO_new_bio_pair(&bio1, 0, &bio2, 0)) {
-//     return false;
-//   }
-//   // SSL_set_bio takes ownership.
-//   SSL_set_bio(client.get(), bio1, bio1);
-//   SSL_set_bio(server.get(), bio2, bio2);
-
-//   *out_client = std::move(client);
-//   *out_server = std::move(server);
-//   return true;
-// }
-
-// struct ClientConfig {
-//   SSL_SESSION *session = nullptr;
-//   std::string servername;
-//   std::string verify_hostname;
-//   unsigned hostflags = 0;
-//   bool early_data = false;
-// };
-
-// static bool ConnectClientAndServer(bssl::UniquePtr<SSL> *out_client,
-//                                    bssl::UniquePtr<SSL> *out_server,
-//                                    SSL_CTX *client_ctx, SSL_CTX *server_ctx,
-//                                    const ClientConfig &config = ClientConfig(),
-//                                    bool shed_handshake_config = true) {
-//   bssl::UniquePtr<SSL> client, server;
-//   if (!CreateClientAndServer(&client, &server, client_ctx, server_ctx)) {
-//     return false;
-//   }
-//   if (config.early_data) {
-//     SSL_set_early_data_enabled(client.get(), 1);
-//   }
-//   if (config.session) {
-//     SSL_set_session(client.get(), config.session);
-//   }
-//   if (!config.servername.empty() &&
-//       !SSL_set_tlsext_host_name(client.get(), config.servername.c_str())) {
-//     return false;
-//   }
-//   if (!config.verify_hostname.empty()) {
-//     if (!SSL_set1_host(client.get(), config.verify_hostname.c_str())) {
-//       return false;
-//     }
-//     SSL_set_hostflags(client.get(), config.hostflags);
-//   }
-
-//   SSL_set_shed_handshake_config(client.get(), shed_handshake_config);
-//   SSL_set_shed_handshake_config(server.get(), shed_handshake_config);
-
-//   if (!CompleteHandshakes(client.get(), server.get())) {
-//     return false;
-//   }
-
-//   *out_client = std::move(client);
-//   *out_server = std::move(server);
-//   return true;
-// }
-
-// static bssl::UniquePtr<SSL_SESSION> g_last_session;
-
-// static int SaveLastSession(SSL *ssl, SSL_SESSION *session) {
-//   // Save the most recent session.
-//   g_last_session.reset(session);
-//   return 1;
-// }
-
-// static bssl::UniquePtr<SSL_SESSION> CreateClientSession(
-//     SSL_CTX *client_ctx, SSL_CTX *server_ctx,
-//     const ClientConfig &config = ClientConfig()) {
-//   g_last_session = nullptr;
-//   SSL_CTX_sess_set_new_cb(client_ctx, SaveLastSession);
-
-//   // Connect client and server to get a session.
-//   bssl::UniquePtr<SSL> client, server;
-//   if (!ConnectClientAndServer(&client, &server, client_ctx, server_ctx,
-//                               config) ||
-//       !FlushNewSessionTickets(client.get(), server.get())) {
-//     fprintf(stderr, "Failed to connect client and server.\n");
-//     return nullptr;
-//   }
-
-//   SSL_CTX_sess_set_new_cb(client_ctx, nullptr);
-
-//   if (!g_last_session) {
-//     fprintf(stderr, "Client did not receive a session.\n");
-//     return nullptr;
-//   }
-//   return std::move(g_last_session);
-// }
+static bool CreateClientAndServer(bssl::UniquePtr<SSL> *out_client,
+                                  bssl::UniquePtr<SSL> *out_server,
+                                  SSL_CTX *client_ctx, SSL_CTX *server_ctx) {
+  bssl::UniquePtr<SSL> client(SSL_new(client_ctx)), server(SSL_new(server_ctx));
+  if (!client || !server) {
+    return false;
+  }
+  SSL_set_connect_state(client.get());
+  SSL_set_accept_state(server.get());
+
+  BIO *bio1, *bio2;
+  if (!BIO_new_bio_pair(&bio1, 0, &bio2, 0)) {
+    return false;
+  }
+  // SSL_set_bio takes ownership.
+  SSL_set_bio(client.get(), bio1, bio1);
+  SSL_set_bio(server.get(), bio2, bio2);
+
+  *out_client = std::move(client);
+  *out_server = std::move(server);
+  return true;
+}
+
+struct ClientConfig {
+  SSL_SESSION *session = nullptr;
+  std::string servername;
+  std::string verify_hostname;
+  unsigned hostflags = 0;
+  bool early_data = false;
+};
+
+static bool ConnectClientAndServer(bssl::UniquePtr<SSL> *out_client,
+                                   bssl::UniquePtr<SSL> *out_server,
+                                   SSL_CTX *client_ctx, SSL_CTX *server_ctx,
+                                   const ClientConfig &config = ClientConfig(),
+                                   bool shed_handshake_config = true) {
+  bssl::UniquePtr<SSL> client, server;
+  if (!CreateClientAndServer(&client, &server, client_ctx, server_ctx)) {
+    return false;
+  }
+  if (config.early_data) {
+#ifndef BSSL_COMPAT
+    SSL_set_early_data_enabled(client.get(), 1);
+#else
+    std::cout << "WARNING: Skipped SSL_set_early_data_enabled()" << std::endl;
+    return false;
+#endif
+  }
+  if (config.session) {
+    SSL_set_session(client.get(), config.session);
+  }
+  if (!config.servername.empty() &&
+      !SSL_set_tlsext_host_name(client.get(), config.servername.c_str())) {
+    return false;
+  }
+  if (!config.verify_hostname.empty()) {
+#ifndef BSSL_COMPAT
+    if (!SSL_set1_host(client.get(), config.verify_hostname.c_str())) {
+      return false;
+    }
+    SSL_set_hostflags(client.get(), config.hostflags);
+#else
+    std::cout << "WARNING: Skipped SSL_set1_host() & SSL_set_hostflags()" << std::endl;
+    return false;
+#endif
+  }
+
+#ifndef BSSL_COMPAT
+  SSL_set_shed_handshake_config(client.get(), shed_handshake_config);
+  SSL_set_shed_handshake_config(server.get(), shed_handshake_config);
+#else
+  if(shed_handshake_config) {
+    std::cout << "WARNING: Skipped SSL_set_shed_handshake_config()" << std::endl;
+  }
+#endif
+
+  if (!CompleteHandshakes(client.get(), server.get())) {
+    return false;
+  }
+
+  *out_client = std::move(client);
+  *out_server = std::move(server);
+  return true;
+}
+
+static bssl::UniquePtr<SSL_SESSION> g_last_session;
+
+static int SaveLastSession(SSL *ssl, SSL_SESSION *session) {
+  // Save the most recent session.
+  g_last_session.reset(session);
+  return 1;
+}
+
+static bssl::UniquePtr<SSL_SESSION> CreateClientSession(
+    SSL_CTX *client_ctx, SSL_CTX *server_ctx,
+    const ClientConfig &config = ClientConfig()) {
+  g_last_session = nullptr;
+  SSL_CTX_sess_set_new_cb(client_ctx, SaveLastSession);
+
+  // Connect client and server to get a session.
+  bssl::UniquePtr<SSL> client, server;
+  if (!ConnectClientAndServer(&client, &server, client_ctx, server_ctx,
+                              config) ||
+      !FlushNewSessionTickets(client.get(), server.get())) {
+    fprintf(stderr, "Failed to connect client and server.\n");
+    return nullptr;
+  }
+
+  SSL_CTX_sess_set_new_cb(client_ctx, nullptr);
+
+  if (!g_last_session) {
+    fprintf(stderr, "Client did not receive a session.\n");
+    return nullptr;
+  }
+  return std::move(g_last_session);
+}
 
 // Test that |SSL_get_client_CA_list| echoes back the configured parameter even
 // before configuring as a server.
-// TEST(SSLTest, ClientCAList) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-//   bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
-//   ASSERT_TRUE(ssl);
-
-//   bssl::UniquePtr<X509_NAME> name(X509_NAME_new());
-//   ASSERT_TRUE(name);
-
-//   bssl::UniquePtr<X509_NAME> name_dup(X509_NAME_dup(name.get()));
-//   ASSERT_TRUE(name_dup);
-
-//   bssl::UniquePtr<STACK_OF(X509_NAME)> stack(sk_X509_NAME_new_null());
-//   ASSERT_TRUE(stack);
-//   ASSERT_TRUE(PushToStack(stack.get(), std::move(name_dup)));
-
-//   // |SSL_set_client_CA_list| takes ownership.
-//   SSL_set_client_CA_list(ssl.get(), stack.release());
-
-//   STACK_OF(X509_NAME) *result = SSL_get_client_CA_list(ssl.get());
-//   ASSERT_TRUE(result);
-//   ASSERT_EQ(1u, sk_X509_NAME_num(result));
-//   EXPECT_EQ(0, X509_NAME_cmp(sk_X509_NAME_value(result, 0), name.get()));
-// }
+TEST(SSLTest, ClientCAList) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+  bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
+  ASSERT_TRUE(ssl);
+
+  bssl::UniquePtr<X509_NAME> name(X509_NAME_new());
+  ASSERT_TRUE(name);
+
+  bssl::UniquePtr<X509_NAME> name_dup(X509_NAME_dup(name.get()));
+  ASSERT_TRUE(name_dup);
+
+  bssl::UniquePtr<STACK_OF(X509_NAME)> stack(sk_X509_NAME_new_null());
+  ASSERT_TRUE(stack);
+  ASSERT_TRUE(PushToStack(stack.get(), std::move(name_dup)));
+
+  // |SSL_set_client_CA_list| takes ownership.
+  SSL_set_client_CA_list(ssl.get(), stack.release());
+
+  STACK_OF(X509_NAME) *result = SSL_get_client_CA_list(ssl.get());
+  ASSERT_TRUE(result);
+  ASSERT_EQ(1u, sk_X509_NAME_num(result));
+  EXPECT_EQ(0, X509_NAME_cmp(sk_X509_NAME_value(result, 0), name.get()));
+}
 
 // TEST(SSLTest, AddClientCA) {
 //   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
@@ -2495,62 +2528,71 @@
 // SSLVersionTest executes its test cases under all available protocol versions.
 // Test cases call |Connect| to create a connection using context objects with
 // the protocol version fixed to the current version under test.
-// class SSLVersionTest : public ::testing::TestWithParam<VersionParam> {
-//  protected:
-//   SSLVersionTest() : cert_(GetTestCertificate()), key_(GetTestKey()) {}
-
-//   void SetUp() { ResetContexts(); }
-
-//   bssl::UniquePtr<SSL_CTX> CreateContext() const {
-//     const SSL_METHOD *method = is_dtls() ? DTLS_method() : TLS_method();
-//     bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(method));
-//     if (!ctx || !SSL_CTX_set_min_proto_version(ctx.get(), version()) ||
-//         !SSL_CTX_set_max_proto_version(ctx.get(), version())) {
-//       return nullptr;
-//     }
-//     return ctx;
-//   }
-
-//   void ResetContexts() {
-//     ASSERT_TRUE(cert_);
-//     ASSERT_TRUE(key_);
-//     client_ctx_ = CreateContext();
-//     ASSERT_TRUE(client_ctx_);
-//     server_ctx_ = CreateContext();
-//     ASSERT_TRUE(server_ctx_);
-//     // Set up a server cert. Client certs can be set up explicitly.
-//     ASSERT_TRUE(UseCertAndKey(server_ctx_.get()));
-//   }
-
-//   bool UseCertAndKey(SSL_CTX *ctx) const {
-//     return SSL_CTX_use_certificate(ctx, cert_.get()) &&
-//            SSL_CTX_use_PrivateKey(ctx, key_.get());
-//   }
-
-//   bool Connect(const ClientConfig &config = ClientConfig()) {
-//     return ConnectClientAndServer(&client_, &server_, client_ctx_.get(),
-//                                   server_ctx_.get(), config,
-//                                   shed_handshake_config_);
-//   }
-
-//   uint16_t version() const { return GetParam().version; }
-
-//   bool is_dtls() const {
-//     return GetParam().ssl_method == VersionParam::is_dtls;
-//   }
-
-//   bool shed_handshake_config_ = true;
-//   bssl::UniquePtr<SSL> client_, server_;
-//   bssl::UniquePtr<SSL_CTX> server_ctx_, client_ctx_;
-//   bssl::UniquePtr<X509> cert_;
-//   bssl::UniquePtr<EVP_PKEY> key_;
-// };
-
-// INSTANTIATE_TEST_SUITE_P(WithVersion, SSLVersionTest,
-//                          testing::ValuesIn(kAllVersions),
-//                          [](const testing::TestParamInfo<VersionParam> &i) {
-//                            return i.param.name;
-//                          });
+class SSLVersionTest : public ::testing::TestWithParam<VersionParam> {
+ protected:
+  SSLVersionTest() : cert_(GetTestCertificate()), key_(GetTestKey()) {}
+
+  void SetUp() { ResetContexts(); }
+
+  bssl::UniquePtr<SSL_CTX> CreateContext() const {
+    const SSL_METHOD *method = is_dtls() ? DTLS_method() : TLS_method();
+    bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(method));
+    if (!ctx || !SSL_CTX_set_min_proto_version(ctx.get(), version()) ||
+        !SSL_CTX_set_max_proto_version(ctx.get(), version())) {
+      return nullptr;
+    }
+    return ctx;
+  }
+
+  void ResetContexts() {
+    ASSERT_TRUE(cert_);
+    ASSERT_TRUE(key_);
+    client_ctx_ = CreateContext();
+    ASSERT_TRUE(client_ctx_);
+    server_ctx_ = CreateContext();
+    ASSERT_TRUE(server_ctx_);
+    // Set up a server cert. Client certs can be set up explicitly.
+    ASSERT_TRUE(UseCertAndKey(server_ctx_.get())) << ERR_error_string(ERR_get_error(), nullptr);
+  }
+
+  bool UseCertAndKey(SSL_CTX *ctx) const {
+#ifdef BSSL_COMPAT
+    // By default, OpenSSL 3 doesn't like keys less than 2048 bits, so we
+    // have to drop the security level to 1 so that it will accept them.
+    bssl::UniquePtr<EVP_PKEY> pkey {X509_get_pubkey(cert_.get())};
+    if(ossl_EVP_PKEY_bits(pkey.get()) < 2048) {
+      std::cerr << "WARNING: ossl_SSL_CTX_set_security_level(server_ctx_.get(), 1)" << std::endl;
+      ossl_SSL_CTX_set_security_level(ctx, 1);
+    }
+#endif
+    return SSL_CTX_use_certificate(ctx, cert_.get()) &&
+           SSL_CTX_use_PrivateKey(ctx, key_.get());
+  }
+
+  bool Connect(const ClientConfig &config = ClientConfig()) {
+    return ConnectClientAndServer(&client_, &server_, client_ctx_.get(),
+                                  server_ctx_.get(), config,
+                                  shed_handshake_config_);
+  }
+
+  uint16_t version() const { return GetParam().version; }
+
+  bool is_dtls() const {
+    return GetParam().ssl_method == VersionParam::is_dtls;
+  }
+
+  bool shed_handshake_config_ = true;
+  bssl::UniquePtr<SSL> client_, server_;
+  bssl::UniquePtr<SSL_CTX> server_ctx_, client_ctx_;
+  bssl::UniquePtr<X509> cert_;
+  bssl::UniquePtr<EVP_PKEY> key_;
+};
+
+INSTANTIATE_TEST_SUITE_P(WithVersion, SSLVersionTest,
+                         testing::ValuesIn(kAllVersions),
+                         [](const testing::TestParamInfo<VersionParam> &i) {
+                           return i.param.name;
+                         });
 
 // TEST_P(SSLVersionTest, SequenceNumber) {
 //   ASSERT_TRUE(Connect());
@@ -2591,110 +2633,110 @@
 //   EXPECT_EQ(server_read_seq + 1, SSL_get_read_sequence(server_.get()));
 // }
 
-// TEST_P(SSLVersionTest, OneSidedShutdown) {
-//   // SSL_shutdown is a no-op in DTLS.
-//   if (is_dtls()) {
-//     return;
-//   }
-//   ASSERT_TRUE(Connect());
-
-//   // Shut down half the connection. |SSL_shutdown| will return 0 to signal only
-//   // one side has shut down.
-//   ASSERT_EQ(SSL_shutdown(client_.get()), 0);
-
-//   // Reading from the server should consume the EOF.
-//   uint8_t byte;
-//   ASSERT_EQ(SSL_read(server_.get(), &byte, 1), 0);
-//   ASSERT_EQ(SSL_get_error(server_.get(), 0), SSL_ERROR_ZERO_RETURN);
-
-//   // However, the server may continue to write data and then shut down the
-//   // connection.
-//   byte = 42;
-//   ASSERT_EQ(SSL_write(server_.get(), &byte, 1), 1);
-//   ASSERT_EQ(SSL_read(client_.get(), &byte, 1), 1);
-//   ASSERT_EQ(byte, 42);
-
-//   // The server may then shutdown the connection.
-//   EXPECT_EQ(SSL_shutdown(server_.get()), 1);
-//   EXPECT_EQ(SSL_shutdown(client_.get()), 1);
-// }
+TEST_P(SSLVersionTest, OneSidedShutdown) {
+  // SSL_shutdown is a no-op in DTLS.
+  if (is_dtls()) {
+    return;
+  }
+  ASSERT_TRUE(Connect());
+
+  // Shut down half the connection. |SSL_shutdown| will return 0 to signal only
+  // one side has shut down.
+  ASSERT_EQ(SSL_shutdown(client_.get()), 0);
+
+  // Reading from the server should consume the EOF.
+  uint8_t byte;
+  ASSERT_EQ(SSL_read(server_.get(), &byte, 1), 0);
+  ASSERT_EQ(SSL_get_error(server_.get(), 0), SSL_ERROR_ZERO_RETURN);
+
+  // However, the server may continue to write data and then shut down the
+  // connection.
+  byte = 42;
+  ASSERT_EQ(SSL_write(server_.get(), &byte, 1), 1);
+  ASSERT_EQ(SSL_read(client_.get(), &byte, 1), 1);
+  ASSERT_EQ(byte, 42);
+
+  // The server may then shutdown the connection.
+  EXPECT_EQ(SSL_shutdown(server_.get()), 1);
+  EXPECT_EQ(SSL_shutdown(client_.get()), 1);
+}
 
 // Test that, after calling |SSL_shutdown|, |SSL_write| fails.
-// TEST_P(SSLVersionTest, WriteAfterShutdown) {
-//   ASSERT_TRUE(Connect());
-
-//   for (SSL *ssl : {client_.get(), server_.get()}) {
-//     SCOPED_TRACE(SSL_is_server(ssl) ? "server" : "client");
-
-//     bssl::UniquePtr<BIO> mem(BIO_new(BIO_s_mem()));
-//     ASSERT_TRUE(mem);
-//     SSL_set0_wbio(ssl, bssl::UpRef(mem).release());
+TEST_P(SSLVersionTest, WriteAfterShutdown) {
+  ASSERT_TRUE(Connect());
 
-//     // Shut down half the connection. |SSL_shutdown| will return 0 to signal
-//     // only one side has shut down.
-//     ASSERT_EQ(SSL_shutdown(ssl), 0);
-
-//     // |ssl| should have written an alert to the transport.
-//     const uint8_t *unused;
-//     size_t len;
-//     ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
-//     EXPECT_NE(0u, len);
-//     EXPECT_TRUE(BIO_reset(mem.get()));
+  for (SSL *ssl : {client_.get(), server_.get()}) {
+    SCOPED_TRACE(SSL_is_server(ssl) ? "server" : "client");
 
-//     // Writing should fail.
-//     EXPECT_EQ(-1, SSL_write(ssl, "a", 1));
-
-//     // Nothing should be written to the transport.
-//     ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
-//     EXPECT_EQ(0u, len);
-//   }
-// }
+    bssl::UniquePtr<BIO> mem(BIO_new(BIO_s_mem()));
+    ASSERT_TRUE(mem);
+    SSL_set0_wbio(ssl, bssl::UpRef(mem).release());
+
+    // Shut down half the connection. |SSL_shutdown| will return 0 to signal
+    // only one side has shut down.
+    ASSERT_EQ(SSL_shutdown(ssl), 0);
+
+    // |ssl| should have written an alert to the transport.
+    const uint8_t *unused;
+    size_t len;
+    ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
+    EXPECT_NE(0u, len);
+    EXPECT_TRUE(BIO_reset(mem.get()));
+
+    // Writing should fail.
+    EXPECT_EQ(-1, SSL_write(ssl, "a", 1));
+
+    // Nothing should be written to the transport.
+    ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
+    EXPECT_EQ(0u, len);
+  }
+}
 
 // Test that, after sending a fatal alert in a failed |SSL_read|, |SSL_write|
 // fails.
-// TEST_P(SSLVersionTest, WriteAfterReadSentFatalAlert) {
-//   // Decryption failures are not fatal in DTLS.
-//   if (is_dtls()) {
-//     return;
-//   }
-
-//   ASSERT_TRUE(Connect());
-
-//   // Save the write |BIO|s as the test will overwrite them.
-//   bssl::UniquePtr<BIO> client_wbio = bssl::UpRef(SSL_get_wbio(client_.get()));
-//   bssl::UniquePtr<BIO> server_wbio = bssl::UpRef(SSL_get_wbio(server_.get()));
-
-//   for (bool test_server : {false, true}) {
-//     SCOPED_TRACE(test_server ? "server" : "client");
-//     SSL *ssl = test_server ? server_.get() : client_.get();
-//     BIO *other_wbio = test_server ? client_wbio.get() : server_wbio.get();
-
-//     bssl::UniquePtr<BIO> mem(BIO_new(BIO_s_mem()));
-//     ASSERT_TRUE(mem);
-//     SSL_set0_wbio(ssl, bssl::UpRef(mem).release());
-
-//     // Read an invalid record from the peer.
-//     static const uint8_t kInvalidRecord[] = "invalid record";
-//     EXPECT_EQ(int{sizeof(kInvalidRecord)},
-//               BIO_write(other_wbio, kInvalidRecord, sizeof(kInvalidRecord)));
-//     char buf[256];
-//     EXPECT_EQ(-1, SSL_read(ssl, buf, sizeof(buf)));
-
-//     // |ssl| should have written an alert to the transport.
-//     const uint8_t *unused;
-//     size_t len;
-//     ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
-//     EXPECT_NE(0u, len);
-//     EXPECT_TRUE(BIO_reset(mem.get()));
-
-//     // Writing should fail.
-//     EXPECT_EQ(-1, SSL_write(ssl, "a", 1));
-
-//     // Nothing should be written to the transport.
-//     ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
-//     EXPECT_EQ(0u, len);
-//   }
-// }
+TEST_P(SSLVersionTest, WriteAfterReadSentFatalAlert) {
+  // Decryption failures are not fatal in DTLS.
+  if (is_dtls()) {
+    return;
+  }
+
+  ASSERT_TRUE(Connect());
+
+  // Save the write |BIO|s as the test will overwrite them.
+  bssl::UniquePtr<BIO> client_wbio = bssl::UpRef(SSL_get_wbio(client_.get()));
+  bssl::UniquePtr<BIO> server_wbio = bssl::UpRef(SSL_get_wbio(server_.get()));
+
+  for (bool test_server : {false, true}) {
+    SCOPED_TRACE(test_server ? "server" : "client");
+    SSL *ssl = test_server ? server_.get() : client_.get();
+    BIO *other_wbio = test_server ? client_wbio.get() : server_wbio.get();
+
+    bssl::UniquePtr<BIO> mem(BIO_new(BIO_s_mem()));
+    ASSERT_TRUE(mem);
+    SSL_set0_wbio(ssl, bssl::UpRef(mem).release());
+
+    // Read an invalid record from the peer.
+    static const uint8_t kInvalidRecord[] = "invalid record";
+    EXPECT_EQ(int{sizeof(kInvalidRecord)},
+              BIO_write(other_wbio, kInvalidRecord, sizeof(kInvalidRecord)));
+    char buf[256];
+    EXPECT_EQ(-1, SSL_read(ssl, buf, sizeof(buf)));
+
+    // |ssl| should have written an alert to the transport.
+    const uint8_t *unused;
+    size_t len;
+    ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
+    EXPECT_NE(0u, len);
+    EXPECT_TRUE(BIO_reset(mem.get()));
+
+    // Writing should fail.
+    EXPECT_EQ(-1, SSL_write(ssl, "a", 1));
+
+    // Nothing should be written to the transport.
+    ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));
+    EXPECT_EQ(0u, len);
+  }
+}
 
 // Test that, after sending a fatal alert from the handshake, |SSL_write| fails.
 // TEST_P(SSLVersionTest, WriteAfterHandshakeSentFatalAlert) {
@@ -2935,110 +2977,116 @@
 //   // is correct.
 // }
 
-// TEST(SSLTest, SetBIO) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-
-//   bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
-//   bssl::UniquePtr<BIO> bio1(BIO_new(BIO_s_mem())), bio2(BIO_new(BIO_s_mem())),
-//       bio3(BIO_new(BIO_s_mem()));
-//   ASSERT_TRUE(ssl);
-//   ASSERT_TRUE(bio1);
-//   ASSERT_TRUE(bio2);
-//   ASSERT_TRUE(bio3);
-
-//   // SSL_set_bio takes one reference when the parameters are the same.
-//   BIO_up_ref(bio1.get());
-//   SSL_set_bio(ssl.get(), bio1.get(), bio1.get());
-
-//   // Repeating the call does nothing.
-//   SSL_set_bio(ssl.get(), bio1.get(), bio1.get());
-
-//   // It takes one reference each when the parameters are different.
-//   BIO_up_ref(bio2.get());
-//   BIO_up_ref(bio3.get());
-//   SSL_set_bio(ssl.get(), bio2.get(), bio3.get());
-
-//   // Repeating the call does nothing.
-//   SSL_set_bio(ssl.get(), bio2.get(), bio3.get());
-
-//   // It takes one reference when changing only wbio.
-//   BIO_up_ref(bio1.get());
-//   SSL_set_bio(ssl.get(), bio2.get(), bio1.get());
-
-//   // It takes one reference when changing only rbio and the two are different.
-//   BIO_up_ref(bio3.get());
-//   SSL_set_bio(ssl.get(), bio3.get(), bio1.get());
-
-//   // If setting wbio to rbio, it takes no additional references.
-//   SSL_set_bio(ssl.get(), bio3.get(), bio3.get());
-
-//   // From there, wbio may be switched to something else.
-//   BIO_up_ref(bio1.get());
-//   SSL_set_bio(ssl.get(), bio3.get(), bio1.get());
-
-//   // If setting rbio to wbio, it takes no additional references.
-//   SSL_set_bio(ssl.get(), bio1.get(), bio1.get());
-
-//   // From there, rbio may be switched to something else, but, for historical
-//   // reasons, it takes a reference to both parameters.
-//   BIO_up_ref(bio1.get());
-//   BIO_up_ref(bio2.get());
-//   SSL_set_bio(ssl.get(), bio2.get(), bio1.get());
-
-//   // ASAN builds will implicitly test that the internal |BIO| reference-counting
-//   // is correct.
-// }
-
-// static int VerifySucceed(X509_STORE_CTX *store_ctx, void *arg) { return 1; }
-
-// TEST_P(SSLVersionTest, GetPeerCertificate) {
-//   ASSERT_TRUE(UseCertAndKey(client_ctx_.get()));
-
-//   // Configure both client and server to accept any certificate.
-//   SSL_CTX_set_verify(client_ctx_.get(),
-//                      SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
-//                      nullptr);
-//   SSL_CTX_set_cert_verify_callback(client_ctx_.get(), VerifySucceed, NULL);
-//   SSL_CTX_set_verify(server_ctx_.get(),
-//                      SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
-//                      nullptr);
-//   SSL_CTX_set_cert_verify_callback(server_ctx_.get(), VerifySucceed, NULL);
-
-//   ASSERT_TRUE(Connect());
-
-//   // Client and server should both see the leaf certificate.
-//   bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
-//   ASSERT_TRUE(peer);
-//   ASSERT_EQ(X509_cmp(cert_.get(), peer.get()), 0);
-
-//   peer.reset(SSL_get_peer_certificate(client_.get()));
-//   ASSERT_TRUE(peer);
-//   ASSERT_EQ(X509_cmp(cert_.get(), peer.get()), 0);
-
-//   // However, for historical reasons, the X509 chain includes the leaf on the
-//   // client, but does not on the server.
-//   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(client_.get())), 1u);
-//   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(client_.get())),
-//             1u);
-
-//   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(server_.get())), 0u);
-//   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(server_.get())),
-//             1u);
-// }
-
-// TEST_P(SSLVersionTest, NoPeerCertificate) {
-//   SSL_CTX_set_verify(server_ctx_.get(), SSL_VERIFY_PEER, nullptr);
-//   SSL_CTX_set_cert_verify_callback(server_ctx_.get(), VerifySucceed, NULL);
-//   SSL_CTX_set_cert_verify_callback(client_ctx_.get(), VerifySucceed, NULL);
-
-//   ASSERT_TRUE(Connect());
-
-//   // Server should not see a peer certificate.
-//   bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
-//   ASSERT_FALSE(peer);
-//   ASSERT_FALSE(SSL_get0_peer_certificates(server_.get()));
-// }
+TEST(SSLTest, SetBIO) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+
+  bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
+  bssl::UniquePtr<BIO> bio1(BIO_new(BIO_s_mem())), bio2(BIO_new(BIO_s_mem())),
+      bio3(BIO_new(BIO_s_mem()));
+  ASSERT_TRUE(ssl);
+  ASSERT_TRUE(bio1);
+  ASSERT_TRUE(bio2);
+  ASSERT_TRUE(bio3);
+
+  // SSL_set_bio takes one reference when the parameters are the same.
+  BIO_up_ref(bio1.get());
+  SSL_set_bio(ssl.get(), bio1.get(), bio1.get());
+
+  // Repeating the call does nothing.
+  SSL_set_bio(ssl.get(), bio1.get(), bio1.get());
+
+  // It takes one reference each when the parameters are different.
+  BIO_up_ref(bio2.get());
+  BIO_up_ref(bio3.get());
+  SSL_set_bio(ssl.get(), bio2.get(), bio3.get());
+
+  // Repeating the call does nothing.
+  SSL_set_bio(ssl.get(), bio2.get(), bio3.get());
+
+  // It takes one reference when changing only wbio.
+  BIO_up_ref(bio1.get());
+  SSL_set_bio(ssl.get(), bio2.get(), bio1.get());
+
+  // It takes one reference when changing only rbio and the two are different.
+  BIO_up_ref(bio3.get());
+  SSL_set_bio(ssl.get(), bio3.get(), bio1.get());
+
+  // If setting wbio to rbio, it takes no additional references.
+  SSL_set_bio(ssl.get(), bio3.get(), bio3.get());
+
+  // From there, wbio may be switched to something else.
+  BIO_up_ref(bio1.get());
+  SSL_set_bio(ssl.get(), bio3.get(), bio1.get());
+
+  // If setting rbio to wbio, it takes no additional references.
+  SSL_set_bio(ssl.get(), bio1.get(), bio1.get());
+
+  // From there, rbio may be switched to something else, but, for historical
+  // reasons, it takes a reference to both parameters.
+  BIO_up_ref(bio1.get());
+  BIO_up_ref(bio2.get());
+  SSL_set_bio(ssl.get(), bio2.get(), bio1.get());
+
+  // ASAN builds will implicitly test that the internal |BIO| reference-counting
+  // is correct.
+}
+
+static int VerifySucceed(X509_STORE_CTX *store_ctx, void *arg) { return 1; }
+
+TEST_P(SSLVersionTest, GetPeerCertificate) {
+  ASSERT_TRUE(UseCertAndKey(client_ctx_.get()));
+
+  // Configure both client and server to accept any certificate.
+  SSL_CTX_set_verify(client_ctx_.get(),
+                     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
+                     nullptr);
+  SSL_CTX_set_cert_verify_callback(client_ctx_.get(), VerifySucceed, NULL);
+  SSL_CTX_set_verify(server_ctx_.get(),
+                     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
+                     nullptr);
+  SSL_CTX_set_cert_verify_callback(server_ctx_.get(), VerifySucceed, NULL);
+
+  ASSERT_TRUE(Connect());
+
+  // Client and server should both see the leaf certificate.
+  bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
+  ASSERT_TRUE(peer);
+  ASSERT_EQ(X509_cmp(cert_.get(), peer.get()), 0);
+
+  peer.reset(SSL_get_peer_certificate(client_.get()));
+  ASSERT_TRUE(peer);
+  ASSERT_EQ(X509_cmp(cert_.get(), peer.get()), 0);
+
+  // However, for historical reasons, the X509 chain includes the leaf on the
+  // client, but does not on the server.
+  EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(client_.get())), 1u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
+  EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(client_.get())),
+            1u);
+#endif
+
+  EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(server_.get())), 0u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
+  EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(server_.get())),
+            1u);
+#endif
+}
+
+TEST_P(SSLVersionTest, NoPeerCertificate) {
+  SSL_CTX_set_verify(server_ctx_.get(), SSL_VERIFY_PEER, nullptr);
+  SSL_CTX_set_cert_verify_callback(server_ctx_.get(), VerifySucceed, NULL);
+  SSL_CTX_set_cert_verify_callback(client_ctx_.get(), VerifySucceed, NULL);
+
+  ASSERT_TRUE(Connect());
+
+  // Server should not see a peer certificate.
+  bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
+  ASSERT_FALSE(peer);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
+  ASSERT_FALSE(SSL_get0_peer_certificates(server_.get()));
+#endif
+}
 
 // TEST_P(SSLVersionTest, RetainOnlySHA256OfCerts) {
 //   uint8_t *cert_der = NULL;
@@ -3167,19 +3215,19 @@
 //   }
 // }
 
-// static void ExpectSessionReused(SSL_CTX *client_ctx, SSL_CTX *server_ctx,
-//                                 SSL_SESSION *session, bool want_reused) {
-//   bssl::UniquePtr<SSL> client, server;
-//   ClientConfig config;
-//   config.session = session;
-//   EXPECT_TRUE(
-//       ConnectClientAndServer(&client, &server, client_ctx, server_ctx, config));
-
-//   EXPECT_EQ(SSL_session_reused(client.get()), SSL_session_reused(server.get()));
-
-//   bool was_reused = !!SSL_session_reused(client.get());
-//   EXPECT_EQ(was_reused, want_reused);
-// }
+static void ExpectSessionReused(SSL_CTX *client_ctx, SSL_CTX *server_ctx,
+                                SSL_SESSION *session, bool want_reused) {
+  bssl::UniquePtr<SSL> client, server;
+  ClientConfig config;
+  config.session = session;
+  EXPECT_TRUE(
+      ConnectClientAndServer(&client, &server, client_ctx, server_ctx, config));
+
+  EXPECT_EQ(SSL_session_reused(client.get()), SSL_session_reused(server.get()));
+
+  bool was_reused = !!SSL_session_reused(client.get());
+  EXPECT_EQ(was_reused, want_reused);
+}
 
 // static bssl::UniquePtr<SSL_SESSION> ExpectSessionRenewed(SSL_CTX *client_ctx,
 //                                                          SSL_CTX *server_ctx,
@@ -3229,73 +3277,76 @@
 //   OPENSSL_memcpy(inout_key, new_key, kTicketKeyLen);
 // }
 
-// static int SwitchSessionIDContextSNI(SSL *ssl, int *out_alert, void *arg) {
-//   static const uint8_t kContext[] = {3};
-
-//   if (!SSL_set_session_id_context(ssl, kContext, sizeof(kContext))) {
-//     return SSL_TLSEXT_ERR_ALERT_FATAL;
-//   }
-
-//   return SSL_TLSEXT_ERR_OK;
-// }
-
-// TEST_P(SSLVersionTest, SessionIDContext) {
-//   static const uint8_t kContext1[] = {1};
-//   static const uint8_t kContext2[] = {2};
-
-//   ASSERT_TRUE(SSL_CTX_set_session_id_context(server_ctx_.get(), kContext1,
-//                                              sizeof(kContext1)));
-
-//   SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
-//   SSL_CTX_set_session_cache_mode(server_ctx_.get(), SSL_SESS_CACHE_BOTH);
-
-//   bssl::UniquePtr<SSL_SESSION> session =
-//       CreateClientSession(client_ctx_.get(), server_ctx_.get());
-//   ASSERT_TRUE(session);
-
-//   TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
-//                                   session.get(),
-//                                   true /* expect session reused */));
-
-//   // Change the session ID context.
-//   ASSERT_TRUE(SSL_CTX_set_session_id_context(server_ctx_.get(), kContext2,
-//                                              sizeof(kContext2)));
-
-//   TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
-//                                   session.get(),
-//                                   false /* expect session not reused */));
-
-//   // Change the session ID context back and install an SNI callback to switch
-//   // it.
-//   ASSERT_TRUE(SSL_CTX_set_session_id_context(server_ctx_.get(), kContext1,
-//                                              sizeof(kContext1)));
-
-//   SSL_CTX_set_tlsext_servername_callback(server_ctx_.get(),
-//                                          SwitchSessionIDContextSNI);
-
-//   TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
-//                                   session.get(),
-//                                   false /* expect session not reused */));
-
-//   // Switch the session ID context with the early callback instead.
-//   SSL_CTX_set_tlsext_servername_callback(server_ctx_.get(), nullptr);
-//   SSL_CTX_set_select_certificate_cb(
-//       server_ctx_.get(),
-//       [](const SSL_CLIENT_HELLO *client_hello) -> ssl_select_cert_result_t {
-//         static const uint8_t kContext[] = {3};
-
-//         if (!SSL_set_session_id_context(client_hello->ssl, kContext,
-//                                         sizeof(kContext))) {
-//           return ssl_select_cert_error;
-//         }
-
-//         return ssl_select_cert_success;
-//       });
+static int SwitchSessionIDContextSNI(SSL *ssl, int *out_alert, void *arg) {
+  static const uint8_t kContext[] = {3};
 
-//   TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
-//                                   session.get(),
-//                                   false /* expect session not reused */));
-// }
+  if (!SSL_set_session_id_context(ssl, kContext, sizeof(kContext))) {
+    return SSL_TLSEXT_ERR_ALERT_FATAL;
+  }
+
+  return SSL_TLSEXT_ERR_OK;
+}
+
+TEST_P(SSLVersionTest, SessionIDContext) {
+#ifdef BSSL_COMPAT
+  GTEST_SKIP(); // TODO: Investigate failures on BSSL_COMPAT
+#endif
+  static const uint8_t kContext1[] = {1};
+  static const uint8_t kContext2[] = {2};
+
+  ASSERT_TRUE(SSL_CTX_set_session_id_context(server_ctx_.get(), kContext1,
+                                             sizeof(kContext1)));
+
+  SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
+  SSL_CTX_set_session_cache_mode(server_ctx_.get(), SSL_SESS_CACHE_BOTH);
+
+  bssl::UniquePtr<SSL_SESSION> session =
+      CreateClientSession(client_ctx_.get(), server_ctx_.get());
+  ASSERT_TRUE(session);
+
+  TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
+                                  session.get(),
+                                  true /* expect session reused */));
+
+  // Change the session ID context.
+  ASSERT_TRUE(SSL_CTX_set_session_id_context(server_ctx_.get(), kContext2,
+                                             sizeof(kContext2)));
+
+  TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
+                                  session.get(),
+                                  false /* expect session not reused */));
+
+  // Change the session ID context back and install an SNI callback to switch
+  // it.
+  ASSERT_TRUE(SSL_CTX_set_session_id_context(server_ctx_.get(), kContext1,
+                                             sizeof(kContext1)));
+
+  SSL_CTX_set_tlsext_servername_callback(server_ctx_.get(),
+                                         SwitchSessionIDContextSNI);
+
+  TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
+                                  session.get(),
+                                  false /* expect session not reused */));
+
+  // Switch the session ID context with the early callback instead.
+  SSL_CTX_set_tlsext_servername_callback(server_ctx_.get(), nullptr);
+  SSL_CTX_set_select_certificate_cb(
+      server_ctx_.get(),
+      [](const SSL_CLIENT_HELLO *client_hello) -> ssl_select_cert_result_t {
+        static const uint8_t kContext[] = {3};
+
+        if (!SSL_set_session_id_context(client_hello->ssl, kContext,
+                                        sizeof(kContext))) {
+          return ssl_select_cert_error;
+        }
+
+        return ssl_select_cert_success;
+      });
+
+  TRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(),
+                                  session.get(),
+                                  false /* expect session not reused */));
+}
 
 // static timeval g_current_time;
 
@@ -3719,44 +3770,44 @@
 //   EXPECT_EQ(DTLS1_VERSION, SSL_CTX_get_min_proto_version(ctx.get()));
 // }
 
-// static const char *GetVersionName(uint16_t version) {
-//   switch (version) {
-//     case TLS1_VERSION:
-//       return "TLSv1";
-//     case TLS1_1_VERSION:
-//       return "TLSv1.1";
-//     case TLS1_2_VERSION:
-//       return "TLSv1.2";
-//     case TLS1_3_VERSION:
-//       return "TLSv1.3";
-//     case DTLS1_VERSION:
-//       return "DTLSv1";
-//     case DTLS1_2_VERSION:
-//       return "DTLSv1.2";
-//     default:
-//       return "???";
-//   }
-// }
-
-// TEST_P(SSLVersionTest, Version) {
-//   ASSERT_TRUE(Connect());
-
-//   EXPECT_EQ(SSL_version(client_.get()), version());
-//   EXPECT_EQ(SSL_version(server_.get()), version());
-
-//   // Test the version name is reported as expected.
-//   const char *version_name = GetVersionName(version());
-//   EXPECT_EQ(strcmp(version_name, SSL_get_version(client_.get())), 0);
-//   EXPECT_EQ(strcmp(version_name, SSL_get_version(server_.get())), 0);
-
-//   // Test SSL_SESSION reports the same name.
-//   const char *client_name =
-//       SSL_SESSION_get_version(SSL_get_session(client_.get()));
-//   const char *server_name =
-//       SSL_SESSION_get_version(SSL_get_session(server_.get()));
-//   EXPECT_EQ(strcmp(version_name, client_name), 0);
-//   EXPECT_EQ(strcmp(version_name, server_name), 0);
-// }
+static const char *GetVersionName(uint16_t version) {
+  switch (version) {
+    case TLS1_VERSION:
+      return "TLSv1";
+    case TLS1_1_VERSION:
+      return "TLSv1.1";
+    case TLS1_2_VERSION:
+      return "TLSv1.2";
+    case TLS1_3_VERSION:
+      return "TLSv1.3";
+    case DTLS1_VERSION:
+      return "DTLSv1";
+    case DTLS1_2_VERSION:
+      return "DTLSv1.2";
+    default:
+      return "???";
+  }
+}
+
+TEST_P(SSLVersionTest, Version) {
+  ASSERT_TRUE(Connect());
+
+  EXPECT_EQ(SSL_version(client_.get()), version());
+  EXPECT_EQ(SSL_version(server_.get()), version());
+
+  // Test the version name is reported as expected.
+  const char *version_name = GetVersionName(version());
+  EXPECT_EQ(strcmp(version_name, SSL_get_version(client_.get())), 0);
+  EXPECT_EQ(strcmp(version_name, SSL_get_version(server_.get())), 0);
+
+  // Test SSL_SESSION reports the same name.
+  const char *client_name =
+      SSL_SESSION_get_version(SSL_get_session(client_.get()));
+  const char *server_name =
+      SSL_SESSION_get_version(SSL_get_session(server_.get()));
+  EXPECT_EQ(strcmp(version_name, client_name), 0);
+  EXPECT_EQ(strcmp(version_name, server_name), 0);
+}
 
 // Tests that that |SSL_get_pending_cipher| is available during the ALPN
 // selection callback.
@@ -4076,40 +4127,40 @@
 //   }
 // }
 
-// TEST_P(SSLVersionTest, GetServerName) {
-//   ClientConfig config;
-//   config.servername = "host1";
-
-//   SSL_CTX_set_tlsext_servername_callback(
-//       server_ctx_.get(), [](SSL *ssl, int *out_alert, void *arg) -> int {
-//         // During the handshake, |SSL_get_servername| must match |config|.
-//         ClientConfig *config_p = reinterpret_cast<ClientConfig *>(arg);
-//         EXPECT_STREQ(config_p->servername.c_str(),
-//                      SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name));
-//         return SSL_TLSEXT_ERR_OK;
-//       });
-//   SSL_CTX_set_tlsext_servername_arg(server_ctx_.get(), &config);
-
-//   ASSERT_TRUE(Connect(config));
-//   // After the handshake, it must also be available.
-//   EXPECT_STREQ(config.servername.c_str(),
-//                SSL_get_servername(server_.get(), TLSEXT_NAMETYPE_host_name));
-
-//   // Establish a session under host1.
-//   SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
-//   SSL_CTX_set_session_cache_mode(server_ctx_.get(), SSL_SESS_CACHE_BOTH);
-//   bssl::UniquePtr<SSL_SESSION> session =
-//       CreateClientSession(client_ctx_.get(), server_ctx_.get(), config);
-
-//   // If the client resumes a session with a different name, |SSL_get_servername|
-//   // must return the new name.
-//   ASSERT_TRUE(session);
-//   config.session = session.get();
-//   config.servername = "host2";
-//   ASSERT_TRUE(Connect(config));
-//   EXPECT_STREQ(config.servername.c_str(),
-//                SSL_get_servername(server_.get(), TLSEXT_NAMETYPE_host_name));
-// }
+TEST_P(SSLVersionTest, GetServerName) {
+  ClientConfig config;
+  config.servername = "host1";
+
+  SSL_CTX_set_tlsext_servername_callback(
+      server_ctx_.get(), [](SSL *ssl, int *out_alert, void *arg) -> int {
+        // During the handshake, |SSL_get_servername| must match |config|.
+        ClientConfig *config_p = reinterpret_cast<ClientConfig *>(arg);
+        EXPECT_STREQ(config_p->servername.c_str(),
+                     SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name));
+        return SSL_TLSEXT_ERR_OK;
+      });
+  SSL_CTX_set_tlsext_servername_arg(server_ctx_.get(), &config);
+
+  ASSERT_TRUE(Connect(config));
+  // After the handshake, it must also be available.
+  EXPECT_STREQ(config.servername.c_str(),
+               SSL_get_servername(server_.get(), TLSEXT_NAMETYPE_host_name));
+
+  // Establish a session under host1.
+  SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
+  SSL_CTX_set_session_cache_mode(server_ctx_.get(), SSL_SESS_CACHE_BOTH);
+  bssl::UniquePtr<SSL_SESSION> session =
+      CreateClientSession(client_ctx_.get(), server_ctx_.get(), config);
+
+  // If the client resumes a session with a different name, |SSL_get_servername|
+  // must return the new name.
+  ASSERT_TRUE(session);
+  config.session = session.get();
+  config.servername = "host2";
+  ASSERT_TRUE(Connect(config));
+  EXPECT_STREQ(config.servername.c_str(),
+               SSL_get_servername(server_.get(), TLSEXT_NAMETYPE_host_name));
+}
 
 // Test that session cache mode bits are honored in the client session callback.
 // TEST_P(SSLVersionTest, ClientSessionCacheMode) {
@@ -4214,43 +4265,46 @@
 //   X509_cmp(cert, cert);
 // }
 
-// TEST(SSLTest, GetCertificate) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-//   bssl::UniquePtr<X509> cert = GetTestCertificate();
-//   ASSERT_TRUE(cert);
-//   ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
-//   bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
-//   ASSERT_TRUE(ssl);
-
-//   X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
-//   ASSERT_TRUE(cert2);
-//   X509 *cert3 = SSL_get_certificate(ssl.get());
-//   ASSERT_TRUE(cert3);
-
-//   // The old and new certificates must be identical.
-//   EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
-//   EXPECT_EQ(0, X509_cmp(cert.get(), cert3));
-
-//   uint8_t *der = nullptr;
-//   long der_len = i2d_X509(cert.get(), &der);
-//   ASSERT_LT(0, der_len);
-//   bssl::UniquePtr<uint8_t> free_der(der);
-
-//   uint8_t *der2 = nullptr;
-//   long der2_len = i2d_X509(cert2, &der2);
-//   ASSERT_LT(0, der2_len);
-//   bssl::UniquePtr<uint8_t> free_der2(der2);
-
-//   uint8_t *der3 = nullptr;
-//   long der3_len = i2d_X509(cert3, &der3);
-//   ASSERT_LT(0, der3_len);
-//   bssl::UniquePtr<uint8_t> free_der3(der3);
-
-//   // They must also encode identically.
-//   EXPECT_EQ(Bytes(der, der_len), Bytes(der2, der2_len));
-//   EXPECT_EQ(Bytes(der, der_len), Bytes(der3, der3_len));
-// }
+TEST(SSLTest, GetCertificate) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+  bssl::UniquePtr<X509> cert = GetTestCertificate();
+  ASSERT_TRUE(cert);
+#ifdef BSSL_COMPAT
+  ossl_SSL_CTX_set_security_level(ctx.get(), 1);
+#endif
+  ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
+  bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
+  ASSERT_TRUE(ssl);
+
+  X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
+  ASSERT_TRUE(cert2);
+  X509 *cert3 = SSL_get_certificate(ssl.get());
+  ASSERT_TRUE(cert3);
+
+  // The old and new certificates must be identical.
+  EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
+  EXPECT_EQ(0, X509_cmp(cert.get(), cert3));
+
+  uint8_t *der = nullptr;
+  long der_len = i2d_X509(cert.get(), &der);
+  ASSERT_LT(0, der_len);
+  bssl::UniquePtr<uint8_t> free_der(der);
+
+  uint8_t *der2 = nullptr;
+  long der2_len = i2d_X509(cert2, &der2);
+  ASSERT_LT(0, der2_len);
+  bssl::UniquePtr<uint8_t> free_der2(der2);
+
+  uint8_t *der3 = nullptr;
+  long der3_len = i2d_X509(cert3, &der3);
+  ASSERT_LT(0, der3_len);
+  bssl::UniquePtr<uint8_t> free_der3(der3);
+
+  // They must also encode identically.
+  EXPECT_EQ(Bytes(der, der_len), Bytes(der2, der2_len));
+  EXPECT_EQ(Bytes(der, der_len), Bytes(der3, der3_len));
+}
 
 // TEST(SSLTest, SetChainAndKeyMismatch) {
 //   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_with_buffers_method()));
@@ -4920,33 +4974,37 @@
 // }
 
 // The client should gracefully handle no suitable ciphers being enabled.
-// TEST(SSLTest, NoCiphersAvailable) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-
-//   // Configure |client_ctx| with a cipher list that does not intersect with its
-//   // version configuration.
-//   ASSERT_TRUE(SSL_CTX_set_strict_cipher_list(
-//       ctx.get(), "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"));
-//   ASSERT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), TLS1_1_VERSION));
-
-//   bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
-//   ASSERT_TRUE(ssl);
-//   SSL_set_connect_state(ssl.get());
-
-//   UniquePtr<BIO> rbio(BIO_new(BIO_s_mem())), wbio(BIO_new(BIO_s_mem()));
-//   ASSERT_TRUE(rbio);
-//   ASSERT_TRUE(wbio);
-//   SSL_set0_rbio(ssl.get(), rbio.release());
-//   SSL_set0_wbio(ssl.get(), wbio.release());
-
-//   int ret = SSL_do_handshake(ssl.get());
-//   EXPECT_EQ(-1, ret);
-//   EXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(ssl.get(), ret));
-//   uint32_t err = ERR_get_error();
-//   EXPECT_EQ(ERR_LIB_SSL, ERR_GET_LIB(err));
-//   EXPECT_EQ(SSL_R_NO_CIPHERS_AVAILABLE, ERR_GET_REASON(err));
-// }
+TEST(SSLTest, NoCiphersAvailable) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+
+  // Configure |client_ctx| with a cipher list that does not intersect with its
+  // version configuration.
+  ASSERT_TRUE(SSL_CTX_set_strict_cipher_list(
+      ctx.get(), "ECDHE-RSA-AES128-GCM-SHA256"));
+  ASSERT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), TLS1_1_VERSION));
+
+  bssl::UniquePtr<SSL> ssl(SSL_new(ctx.get()));
+  ASSERT_TRUE(ssl);
+  SSL_set_connect_state(ssl.get());
+
+  UniquePtr<BIO> rbio(BIO_new(BIO_s_mem())), wbio(BIO_new(BIO_s_mem()));
+  ASSERT_TRUE(rbio);
+  ASSERT_TRUE(wbio);
+  SSL_set0_rbio(ssl.get(), rbio.release());
+  SSL_set0_wbio(ssl.get(), wbio.release());
+
+  int ret = SSL_do_handshake(ssl.get());
+  EXPECT_EQ(-1, ret);
+  EXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(ssl.get(), ret));
+  uint32_t err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_SSL, ERR_GET_LIB(err));
+#ifdef BSSL_COMPAT
+  EXPECT_EQ(ossl_SSL_R_NO_PROTOCOLS_AVAILABLE, ERR_GET_REASON(err));
+#else
+  EXPECT_EQ(SSL_R_NO_CIPHERS_AVAILABLE, ERR_GET_REASON(err));
+#endif
+}
 
 // TEST_P(SSLVersionTest, SessionVersion) {
 //   SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
@@ -5721,25 +5779,28 @@
 // }
 
 // SSL_CTX_get0_certificate needs to lock internally. Test this works.
-// TEST(SSLTest, GetCertificateThreads) {
-//   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
-//   ASSERT_TRUE(ctx);
-//   bssl::UniquePtr<X509> cert = GetTestCertificate();
-//   ASSERT_TRUE(cert);
-//   ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
-
-//   // Existing code expects |SSL_CTX_get0_certificate| to be callable from two
-//   // threads concurrently. It originally was an immutable operation. Now we
-//   // implement it with a thread-safe cache, so it is worth testing.
-//   X509 *cert2_thread;
-//   std::thread thread(
-//       [&] { cert2_thread = SSL_CTX_get0_certificate(ctx.get()); });
-//   X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
-//   thread.join();
-
-//   EXPECT_EQ(cert2, cert2_thread);
-//   EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
-// }
+TEST(SSLTest, GetCertificateThreads) {
+  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  ASSERT_TRUE(ctx);
+#ifdef BSSL_COMPAT
+  ossl_SSL_CTX_set_security_level(ctx.get(), 1);
+#endif
+  bssl::UniquePtr<X509> cert = GetTestCertificate();
+  ASSERT_TRUE(cert);
+  ASSERT_TRUE(SSL_CTX_use_certificate(ctx.get(), cert.get()));
+
+  // Existing code expects |SSL_CTX_get0_certificate| to be callable from two
+  // threads concurrently. It originally was an immutable operation. Now we
+  // implement it with a thread-safe cache, so it is worth testing.
+  X509 *cert2_thread;
+  std::thread thread(
+      [&] { cert2_thread = SSL_CTX_get0_certificate(ctx.get()); });
+  X509 *cert2 = SSL_CTX_get0_certificate(ctx.get());
+  thread.join();
+
+  EXPECT_EQ(cert2, cert2_thread);
+  EXPECT_EQ(0, X509_cmp(cert.get(), cert2));
+}
 
 // Functions which access properties on the negotiated session are thread-safe
 // where needed. Prior to TLS 1.3, clients resuming sessions and servers
@@ -7167,14 +7228,14 @@
 //   ASSERT_TRUE(CompleteHandshakesForQUIC());
 // }
 
-// extern "C" {
-// int BORINGSSL_enum_c_type_test(void);
-// }
-
-// TEST(SSLTest, EnumTypes) {
-//   EXPECT_EQ(sizeof(int), sizeof(ssl_private_key_result_t));
-//   EXPECT_EQ(1, BORINGSSL_enum_c_type_test());
-// }
+extern "C" {
+int BORINGSSL_enum_c_type_test(void);
+}
+
+TEST(SSLTest, EnumTypes) {
+  EXPECT_EQ(sizeof(int), sizeof(ssl_private_key_result_t));
+  EXPECT_EQ(1, BORINGSSL_enum_c_type_test());
+}
 
 // TEST_P(SSLVersionTest, DoubleSSLError) {
 //   // Connect the inner SSL connections.
@@ -7265,42 +7326,46 @@
 //   }
 // }
 
-// TEST_P(SSLVersionTest, SameKeyResume) {
-//   uint8_t key[48];
-//   RAND_bytes(key, sizeof(key));
-
-//   bssl::UniquePtr<SSL_CTX> server_ctx2 = CreateContext();
-//   ASSERT_TRUE(server_ctx2);
-//   ASSERT_TRUE(UseCertAndKey(server_ctx2.get()));
-//   ASSERT_TRUE(
-//       SSL_CTX_set_tlsext_ticket_keys(server_ctx_.get(), key, sizeof(key)));
-//   ASSERT_TRUE(
-//       SSL_CTX_set_tlsext_ticket_keys(server_ctx2.get(), key, sizeof(key)));
-
-//   SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
-//   SSL_CTX_set_session_cache_mode(server_ctx_.get(), SSL_SESS_CACHE_BOTH);
-//   SSL_CTX_set_session_cache_mode(server_ctx2.get(), SSL_SESS_CACHE_BOTH);
-
-//   // Establish a session for |server_ctx_|.
-//   bssl::UniquePtr<SSL_SESSION> session =
-//       CreateClientSession(client_ctx_.get(), server_ctx_.get());
-//   ASSERT_TRUE(session);
-//   ClientConfig config;
-//   config.session = session.get();
 
-//   // Resuming with |server_ctx_| again works.
-//   bssl::UniquePtr<SSL> client, server;
-//   ASSERT_TRUE(ConnectClientAndServer(&client, &server, client_ctx_.get(),
-//                                      server_ctx_.get(), config));
-//   EXPECT_TRUE(SSL_session_reused(client.get()));
-//   EXPECT_TRUE(SSL_session_reused(server.get()));
-
-//   // Resuming with |server_ctx2| also works.
-//   ASSERT_TRUE(ConnectClientAndServer(&client, &server, client_ctx_.get(),
-//                                      server_ctx2.get(), config));
-//   EXPECT_TRUE(SSL_session_reused(client.get()));
-//   EXPECT_TRUE(SSL_session_reused(server.get()));
-// }
+TEST_P(SSLVersionTest, SameKeyResume) {
+#ifdef BSSL_COMPAT
+  GTEST_SKIP(); // FIXME: Investigate failures on bssl-compat
+#endif
+  uint8_t key[48];
+  RAND_bytes(key, sizeof(key));
+
+  bssl::UniquePtr<SSL_CTX> server_ctx2 = CreateContext();
+  ASSERT_TRUE(server_ctx2);
+  ASSERT_TRUE(UseCertAndKey(server_ctx2.get()));
+  ASSERT_TRUE(
+      SSL_CTX_set_tlsext_ticket_keys(server_ctx_.get(), key, sizeof(key)));
+  ASSERT_TRUE(
+      SSL_CTX_set_tlsext_ticket_keys(server_ctx2.get(), key, sizeof(key)));
+
+  SSL_CTX_set_session_cache_mode(client_ctx_.get(), SSL_SESS_CACHE_BOTH);
+  SSL_CTX_set_session_cache_mode(server_ctx_.get(), SSL_SESS_CACHE_BOTH);
+  SSL_CTX_set_session_cache_mode(server_ctx2.get(), SSL_SESS_CACHE_BOTH);
+
+  // Establish a session for |server_ctx_|.
+  bssl::UniquePtr<SSL_SESSION> session =
+      CreateClientSession(client_ctx_.get(), server_ctx_.get());
+  ASSERT_TRUE(session);
+  ClientConfig config;
+  config.session = session.get();
+
+  // Resuming with |server_ctx_| again works.
+  bssl::UniquePtr<SSL> client, server;
+  ASSERT_TRUE(ConnectClientAndServer(&client, &server, client_ctx_.get(),
+                                     server_ctx_.get(), config));
+  EXPECT_TRUE(SSL_session_reused(client.get()));
+  EXPECT_TRUE(SSL_session_reused(server.get()));
+
+  // Resuming with |server_ctx2| also works.
+  ASSERT_TRUE(ConnectClientAndServer(&client, &server, client_ctx_.get(),
+                                     server_ctx2.get(), config));
+  EXPECT_TRUE(SSL_session_reused(client.get()));
+  EXPECT_TRUE(SSL_session_reused(server.get()));
+}
 
 // TEST_P(SSLVersionTest, DifferentKeyNoResume) {
 //   uint8_t key1[48], key2[48];
@@ -8260,5 +8325,5 @@
 //   }
 // }
 
-// }  // namespace
-// BSSL_NAMESPACE_END
+}  // namespace
+BSSL_NAMESPACE_END
